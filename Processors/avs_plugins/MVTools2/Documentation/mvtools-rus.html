<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ru">
<head>
  <title>MVTools</title>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
  <link rel="stylesheet" type="text/css" href="avisynth.css">
<!-- Automatically generated, don't change: 
$Id: mvtools.htm,v 1.3 2005/07/21 20:37:44 fizick Exp $ 
-->
</head>
<body>
<h1>MVTools</h1>
<h2>Общая информация</h2>
<b>Авторы:</b>Manao, Fizick(Александр Балахнин),  Tsp, TSchniede<br>
<b>Версия:</b> 1.11.4.5<br>
<b>Загрузка:</b> <a href="http://avisynth.org.ru/">http://avisynth.org.ru/</a><br>
<b>Категория:</b> плагины разного назначения (Misc Plugins)<br>
<b>Требования:</b> YV12, YUY2 цветовые форматы
<hr>
<h2>Содержание:
</h2>
<ul>
  <li><a href="#mvtools">I) О MVTools</a></li>
  <li><a href="#functions">II) Описания функций</a></li>
  <li><a href="#examples">III) Примеры</a></li>
  <li><a href="#disclaimer">IV) Отказ от гарантий (Disclaimer) (не
игнорируйте эту часть, хоть мы и не настаиваем на ее изучении)</a></li>
  <li><a href="#revisions">V) Ревизии</a></li>
  <li><a href="#download">VI) Скачать (Download)</a></li>
</ul>
<h2><a name="MVTools"></a>I) О MVTools</h2>
<p>MVTools плагин для AviSynth 2.5 - это коллекция функций 
для оценки и компенсации движения объектов в видео клипах.
Компенсация движения может быть использована для сильного временного понижения шума, 
продвинутых преобразований частоты кадров, реставрации изображений и других задач.
</p>
<p>Плагин содержит серверную функцию оценки движения MVAnalyse (сервер) для нахождения векторов движения 
и несколько клиентских функций компенсации движения (MVCompensate, MVMask и других),
которые используют эти векторы.
</p>
<p>Плагин использует метод сличения блоков (block-matching) для оценки движения 
(подобные методы используются в MPEG2, MPEG4 и т.д).
На стадии анализа плагин разделяет кадры на малые блоки и пробует найти для каждого блока в текущем кадре
наиболее подобный (соответствующий) блок во втором кадре (предыдущем или последующем).
Относительное смещение этих блоков и есть вектор движения.
Основной мерой подобия блоков является сумма абсолютных разностей (SAD) всех пикселов этих двух сравниваемых блоков. 
SAD это величина, показывающая, насколько хороша оценка движения.
</p>
<p>Выходом функции MVAnalyse является специальный клип с информацией о векторах движения в некотором формате. 
</p>
<p>На стадии компенсации клиентские функции плагина читают вектора движения и используют их, 
чтобы передвинуть блоки и сформировать кадр с компенсированным движением
(или реализуют какую-либо другую функцию полной или частичной  компенсации или интерполяции).
Каждый объект (блок) в этом (полностью) скомпенсированном кадре помещен в ту же позицию, как этот объект 
в текущем кадре. Таким образом, мы можем (например) использовать сильное временное понижение шума
даже для достаточно быстро движущихся объектов без производства раздражающих артефактов и призраков
(особенности и края объектов совпадают, если компенсация совершенна).
Плагин может создать компенсированные соседние кадры для каждого текущего кадра и снизить его шум с помощью
внутренней функции. 
Альтернативно, вы можете использовать использовать компенсированные кадры, чтобы создать клип с их чередованием,
понизить его шум с использованием любого внешнего фильтра, 
и выбрать для выхода центральные очищенные кадры (смотри примеры).
</p>
<p>Конечно, оценка  компенсация движения не идеальна и не точна.
В некоторых сложных случаях (видео с затуханием, сверх-быстрым движением, периодическими структурами)
оценка движения может быть полностью неверна, и компенсированный (особенно интерполированный) кадр будет блочным и (или) уродливым.
Трудности также представляют заслонение одного объекта другим или наоборот, открытие. 
Сложные AviSynth скрипты со многими функциями компенсации движения могут съесть огромное количество памяти
и привести к очень медленной обработке.
Это не простой, а достаточно сложный плагин. Используйте его только для подходящих случаев, 
и попытайтесь настроить его параметры.
Есть много обсуждений по поводу использования компенсации движения на (англоязычном) форуме doom9 по AviSynth.
В частности смотрите <a href="http://forum.doom9.org/showthread.php?s=&threadid=76041">старую ветку по MVTools</a>,  
<a href="http://forum.doom9.org/showthread.php?t=102071">ветку по true motion</a>, 
<a href="http://forum.doom9.org/showthread.php?t=84770">новую ветку по MVTools</a> и несколько других. 
Попробуйте почитать сообщения как дополнения к данной документации и спрашивайте там поддержку.
Если вы действительно заинтересовались вопросами оценки и компенсации движения,
вы легко найдете многочисленные научные публикации (используйте WWW поиск).
</p>
<p>Замечания. Данный плагин еще в стадии разработки. Текущая версия имеет некоторые ограничения.
Поддерживается только прогрессивное видео цветового формата YV12, YUY2. 
Используйте преобразование цветовых форматов и попробуйте использовать (разумный) BOB-деинтерлейс
для чересстрочного видео (может также работать разделение на поля SeparateFields с или без SelectEven/SelectOdd).  
Некоторые сложные скрипты (MVBOB, MCBOB) используют MVTools для <a href="http://forum.doom9.org/showthread.php?t=84725"> деинтерлейса с компенсацией движения.</a></br> 
Альтернативно вы можете попробовать использовать <a href="http://forum.doom9.org/showthread.php?t=101859">плагин Motion</a> от mg262.
</p>


<h2><a name="functions"></a>II)Описания функций </h2>

<h3>Общие параметры</h3>
<p>Фильтры, использующие вектора движения (MV), имеют ряд общих параметров.
Это пороги детектирования сцен и флаги использования mmx/isse. Кроме
того фильтры используют один или несколько потоков векторов.
</p>
<var>int thSCD1</var>: порог определения,
изменился ли блок в
текущем кадре относительно предыдущего. Если блок изменился, 
это значит, что предварительный прогноз движения для него в целом
некорректен. Это происходит, например, при смене сцен. То есть это один
из порогов, используемых для отладки механизма детектирования смены сцен.
Его увеличение уменьшит количество блоков,
определяемых как измененные. Это может быть полезно для шумного или мерцающего видео.
Порог сравнивается со значением SAD (Sum
of Absolute Differences - суммой абсолютных различий, значение погрешности,
говорящее о степени несоответствия рассчитанного прогноза движения). 
Для строго идентичных блоков мы имеем SAD=0. Но реальные блоки всегда отличаются из-за сложного движения объектов
(приближение, вращение, деформация), дискретности отсчета пикселов, и шума.
Предположим мы имеем два сравниваемых блока 8х8 с каждым из пикселов отличающихся на 5.
В этом случае SAD будет 8x8x5 = 320 (блок будет зарегистрирован как неизменившийся при thSCD1=400).
Если используются блоки 4x4, величина SAD будет  320/4.
Если используются блоки 16x16, величина SAD будет 320/4.
На самом деле этот параметр масштабируется внутренне, 
и Вы должны всегда использовать величину, приведенную к размерам блока 8x8.
По умолчанию задано 400 (с версии 1.4.1). 
<p><var>int thSCD2</var>: порог, задающий количество блоков, которые
должны измениться, чтобы принять решение о смене сцен. Его диапазон
0...255, 0 соответствует 0 %, 255 - 100 %. По умолчанию задано 130 (что
соответствует 51 %).</p>
<p><var>bool isse</var> : флаг использования ISSE и MMX оптимизации. Установка в false позволяет
отключить ISSE и MMX оптимизацию для отладки. По умолчанию: true. Если Ваш процессор не
поддерживает isse оптимизацию, она все равно будет отключена
(и активировать ее не удастся)</p>

<h3>MVAnalyse</h3>
<code>MVAnalyse</code> (<var>clip, int "blksize", int "blksizeV", int "pel", int "level", int "search", 
int "searchparam", int "pelsearch", bool "isb", int "lambda", bool "chroma", int "delta", 
bool "truemotion", int "lsad", int "pnew", int "plevel", bool "global", int "pzero" int "overlap", int "overlapV",
string "outfile", int "sharp", int "rfilter", clip "clip2x", int "dct", int "divide", bool "mc", int "idx", int "sadx264"</var>)
<p> Оценивает движения методом сличения блоков 
и производит специальный выходной клип с данными по векторам движения 
(используемыми другими программами).<br>
Реализованы некоторые иерархические многоуровневые методы поиска (от грубого масштаба изображения к тонкому).
Функция использует нулевой вектор и векторы соседних блоков как предикторы (начальные приближения) для текущего блока.
Сначала оценивается разница (SAD) для предикторов, 
затем пробный вектор изменяется на некоторую величину в некотором направлении, 
оценивается SAD, и так далее.
Принятый новый вектор для блока - это вектор с минимальной разностью (SAD) 
(с некоторой поправкой-штрафом для согласованности движения) 
</p>
<p><var>blksize</var>: Размер блока (горизонтальный). Возможны только значения 4, 8, 16, 32
(по умолчанию 8). БОльшие блоки менее чувствительны к шумам, и
обрабатываются быстрее, но более грубы.
</p>
<p><var>blksizeV</var> : вертикальный размер блока. По умолчанию равен горизонтальному.
Дополнительные варианты: 4 для blksize=8, 2 и 8 для blksize=16, 16 для blksize=32.</p>
<p><var>pel</var> : Это точность прогнозирования движения. 1 означает
точность до пиксела, 2 - до полу-пиксела, 4 - до четверти пиксела 
(более точное, но медленнее и не всегда лучше из-за большого шага масштаба между уровнями). 
По умолчанию: 2 с версии 1.4.10.
</p>
<p><var>level</var>: Это количество грубых уровней, НЕ используемых при
иерархическом анализе во время нахождения векторов движения. Чем оно
меньше, тем обычно лучше (находятся вектора любой длины). Переменная оставлена главным образом для учебных (тестовых) целей. 
Иногда <var>level</var> полезна для предотвращения очень длинных (ложных) векторов (компьютерной графики и т.п.).
По умолчанию: 0. <br>
</p>
<p><var>search, searchparam, pelsearch</var> : <var>search</var>
определяет тип поиска, а <var>searchparam</var> - дополнительный
параметр (шаг, радиус) поиска, а <var>pelsearch</var> - этот параметр для самого тонкого (pel) уровня:</p>
<ul>
  <li><var>search </var>= 0 : 'Однопроходный Поиск' (OneTimeSearch). <var>searchparam</var>
- шаг между каждыми пробуемыми векторами (если <var>searchparam</var>
больше 1, шаг будет постепенно уменьшаться).</li>
  <li><var>search </var>= 1 : 'N-проходный Поиск'(NStepSearch). N
задается параметром <var>searchparam</var>. Это наиболее хорошо
известный алгоритм поиска векторов движения.</li>
  <li><var>search </var>= 2 : Логарифмический поиск, также
называемый Бриллиантовый поиск (Diamond Search). Параметр <var>searchparam</var>
определяет начальный шаг поиска, и он (шаг) также постепенно
уменьшается. Это метод
поиска по умолчанию (с <var>searchparam</var> = 2 и <var>pelsearch</var> = <var>pel</var> ).</li>
  <li><var>search</var>= 3 : Исчерпывающий поиск, <var>searchparam</var>
- это радиус поиска (сторона квадрата 2*searchparam+1). Метод медленнее, но дает лучшие результаты по значению SAD.</li>
</ul>
<p><var>isb</var> : позволяет выбрать прямое направление поиска (от
предыдущего к текущему кадру) для <var>isb</var>=false либо обратное (от последующего к текущему
кадру) для <var>isb</var>=true (это реализовано и названо именно таким образом, не переспрашивайте :-). 
По умолчанию <var>isb </var>=false.</p>
<p><var>chroma</var> : установка в true позволяет учитывать и цветовую
информацию при оценке движения (false - толькоя яркостную). По умолчанию true. </p>
<p><var>delta</var> : устанавливает кадровый интервал между указанным и
текущим кадром. По умолчанию он равен 1, что означает, что вектора
движения ищутся между текущим и предыдущим
(или следующим) кадром. Установка в 2 позволит искать mvs между кадром
n и n-2 или n+2 (в зависимости от значения <var>isb</var>).</p>

<p>Существуют дополнительные параметры, которые устанавливают согласованность векторов движения
для оценки так называемого истинного движения (true motion). 
Некоторые найденные поиском блоки другого кадра могут быть наиболее подобны образцовым блокам
текущего блока по критерию интенсивности (SAD), но не отвечать истинному движению объекта.
Например, они могут принадлежать другому подобному объекту в другом углу кадра,
или относиться к некоторой периодической структуре.
Параметры "истинного движения" (true motion) пытаются поддерживать поле движения согласованным, слаженным,
вместо некоторого случайного распределения векторов.
Это особенно важно для частичной компенсации и интерполяции движения.
Некоторые параметры являются экспериментальными и могут быль удалены (заменены) 
из последующих версий после тестирования. Пожалуйста, сообщайте ваши заключения.
</p>
<p><var>truemotion</var> это предварительно созданный набор значений этих параметров. 
Он позволяет легко переключать значения по умолчанию сразу всех параметров "истинного движения".
Установите его равным <var>true</var> для поиска истинного движения (высокой согласованности векторов), 
Установите его равным <var>false</var> для поиска векторов движения с наилучшей SAD. 
По умолчанию - <var>true</var> c версии v1.4.10.
В любом случае вы можете настроить каждый параметр индивидуально.</p>
<p><var>lambda</var> : устанавливает согласованность (слаженность, coherence) поля векторов.
Чем выше, тем больше согласованность. Однако, если задать его слишком высоким,
некоторые 'правильные' вектора движения могут быть пропущены. 
Величины около 400 - 2000 (для размера блока 8х8) настоятельно рекомендуются.
Внутренне это коэффициент для штрафа к SAD от квадратичной разности вектора от предиктора (соседей),
масштабированный на 256.<br>
По умолчанию 0 для <var>truemotion</var>=false и 1000*blksize*blksizeV/64 для <var>truemotion</var>=true.
</p>
<p><var>lsad</var>: порог SAD для использования <var>lambda</var>. Локальная <var>lambda</var> уменьшается (плавно с версии 1.10.2)
если величина SAD предиктора вектора (сформированного из соседей) больше чем порог. 
Это предотвращает использование плохих предикторов, но снижает согласованность движения. 
Величины выше 1000 (для размера блока 8) рекомендуются для истинного движения.<br>
По умолчанию 400*blksize*blksizeV/64 для <var>truemotion</var>=false и 1200*blksize*blksizeV/64 для <var>truemotion</var>=true.
</p>
<p><var>pnew</var>: относительный штраф (в масштабе 256) к погрешности (SAD) для нового вектора-кандидата.  
Пробный вектор будет принят как новый вектор, только если 
его SAD со штрафом (SAD + SAD*pnew/256) будет лучше, чем погрешность (SAD) предиктора.
Величины около 50-100 (для размера блока 8х8) рекомендуются для истинного движения. 
Это предотвращает замену вполне хороших предикторов на новый вектор с немного лучшей SAD, 
но другой длиной и направлением.<br>
По умолчанию 0 для <var>truemotion</var>=false и 50 для <var>truemotion</var>=true.
</p>
<p><var>plevel</var>:  режим масштабирования штрафного коэффициента <var>lambda</var> от уровня.  
Величина =0 - без масштабирования, 1 - линейная, 2 - квадратичная зависимость от размера иерархического уровня. 
Заметьте, что длина вектора меньше на более низком уровне.<br>
По умолчанию 0 для <var>truemotion</var>=false и 1 для <var>truemotion</var>=true.
</p>
<p><var>global</var>:  оценить глобальное движение (на каждом уровне) и использовать его как дополнительный предиктор. 
Оценивается только панорамное смещение (ни зум, ни вращение).
Величина = false означает отменить, true - разрешить. 
По умолчанию false для <var>truemotion</var>=false и true для <var>truemotion</var>=true.
</p>
<p><var>pzero</var>: относительный штраф (в масштабе 256) к погрешности (SAD) для нулевого (и глобального) вектора.
Это предотвращает замену вполне хороших предикторов на нулевой вектор с немного лучшей SAD 
(<var>lambda</var> не используется для нулевого и глобального векторов). По умолчанию равен <var>pnew</var> с версии 1.11.
</p>
<p><var>overlap</var>:  величина перекрытия блоков (горизонтальная).  Должна быть четной и меньше размера блока 
(до blksize/2 для MVCompensate). 
Шаг между блоками для оценки движения равен (blksize-overlap). 
N блоков покрывают размер ((blksize-overlap)*N + overlap) на кадре.
Попробуйте значения перекрытия от blksize/4 до blksize/2. 
Чем больше перекрытие, тем больше число блоков, и меньше скорость обработки. 
Величина по умолчанию 0. <br>
Функции, поддерживающие режим перекрытия: MVFlow, MVFlowInter, MVFlowFps (не MVFlowFps2), MVShow, MVMask, MVCompensate, MVDeGrain1, MVDeGrain2, MVDeGrain3.
</p>
<p><var>overlapV</var>:  вертикальная величина перекрытия блоков.  По умолчанию равна горизонтальной.
Должна быть четной для YV12 и меньше размера блока.</p>
<p><var>outfile</var>:  имя файла для вывода данных по векторам движения. 
Эти данные могут быть использованы некоторыми внешними программами 
или может быть следующими версиями MVTools для кодирования второго прохода и т.п. <br>
Производимый двоичный файл имеет заголовок (структура MVAnalysisData, смотри исходный код MVInterface.h), 
и последовательность данных:<br>
номер кадра, данные вектора (Vx, Vy, SAD) каждого блока, 
номер следующего пригодного кадра, данные векторов этого кадра, и т.д.<br>
По умолчанию - пустая строка, не записывать файл.</p>
<p><var>sharp</var>:  метод субпиксельной интерполяции для <var>pel</var>=2,4. <br>
Используйте 0 для мягкой (билинейной) интерполяции, 1 для бикубической (по 4 точкам, Catmull-Rom),
2 для резкой типа Wiener (по 6 точкам, подобно Lanczos).<br>
По умолчанию 2.</p>
<p><var>rfilter</var>:  метод сокращения иерархических уровней. 
Используйте 0 для простого суммирования 4 пикселов (усреднение подобно BilinearResize, старый метод),
испольуйте 1 для фильтра 1/4, 1/2, 1/4 (подобно ReduceBy2) для более гладкой оценки движения.<br>
По умолчанию 1 (с версии 1.11.0.2).
</p>
<p><var>pelclip</var>: увеличенный исходный клип для использования вместо внутренней субпиксельной интерполяции (для pel>1).<br>
Пикселы в строках и столбцах кратных pel (0,2,4,... для pel=2) должны быть оригинальными пикселами источника, 
другие пикселы должны быть интерполированы.<br>
Пример для pel=2: LanczosResize(width*2,height*2,src_left=0.25, src_top=0.25) <br>
(Недавнее замечание: это справедливо для яркостного канала, но не строго соответствует позицмям пикселов цветности внутреней интерполяции в MVTools.
Тем не мене, вектора и компенсация движения вполне подобны для обычныз клипов, 
Строго та же цветность была бы при src_left=0.5 для YUY2 и дополнительно src_top=0.5 для YV12).<br>
Другой полезный пример - интерполятор EEDI2 с направленостью вдоль краев.<br>
Для корректных результатов Вы должны использовать (причем тот же) клип pelclip во всей цепочке MVTools функций, 
использующих тот же исходный клип (и idx).<br>
По умолчанию не определен.
</p>
<p><var>dct</var>: использование DCT (частотный спектр) блоков для расчета отличия блоков (SAD). 
Это может в том числе улучшить оценку векторов движения при мерцаниях и затуханиях яркости.<br>
0 - обычные пространственные блоки, не использовать DCT;<br>
1 - использовать DCT блоков вместо пространственной информации (медленно для 8x8, и очень медленно для других размеров);<br>
2 - смешанный режим с весами пространственной и DCT информации, зависящими от разности средней яркости кадров;<br>
3 - адаптивное поблочное переключение от пространственного к равно смешанному (экспериментальный, чуть быстрее).<br>
4 - адаптивное поблочное переключение от пространственного к смешанному с большим весом DCT (экспериментальный, чуть быстрее).<br>
добавленные в 1.9.5.3 режимы:  (требуют sadx264 0-7, используют быструю SATD функцию, только яркость!) <BR>
5 - SATD вместо SAD для яркости<BR>
6 - аналогично 2, но используя SATD<BR>
7 - аналогично 3, но используя SATD<BR>
8 - аналогично 4, но используя SATD<BR>
9 - подобно 2, используя SATD и вес диапазон от только SAD до равных SAD & SATD<BR>
10 - подобно 3/4, использовать SATD вес на SAD, только на сильных изменения яркости<BR>
По умолчанию = 0.
</p>
<p><var>divide</var>: пост-обработка векторов движения путем деления каждого блока на 4 одинаковых меньших подблока.<br>
0 - не делить;<br>
1 - делить блоки и присвоить оригинальный вектор всем 4 подблокам;<br>
2 - делить блоки и присвоить подблокам медианые (с 2 соседними) вектора;<br>
По умолчанию = 0. Размеры блоков и перекрытия должны быть выбраны подходящими после внутреннего деления. 
</p>
<p><var>mc</var>: дополнительно хранить скомпенсированные по движению кадры в клипе векторов (используется в MVDenoise). 
По умолчанию false (не хранить для экономии памяти) с версии v1.11.4.
</p>
<p><var>idx</var> : индекс  клипа. Он позволяет повторно внутренне использовать (разделить)
несколькими вызовами данного фильтра (или другими функциями) 
вычисленные по кадрам клипа многоуровневые данные  
для более быстой обработки и экономии памяти. 
Это особенно полезно для pel=2 для избежания повторного расчета интерполяции пикселов
при выполнении поиска вперед и назад для того же клипа. Если вы используете idx, то должны
задавать только положительные числа, и вы должны использовать
 то же значение только для фильтров, работающих с тем же клипом (иначе
анализ не будет работать правильно).
 По умолчанию, задается уникальное отрицательное число
 для каждого вызова фильтра (который при этом создает собственные многоуровневые данные).</p>
</p>
<p><var>sadx264</var>: использовать SAD функции из кодека x264 если они доступлы для данного размера блока<BR>
0 - (по умолчанию) автоматически детектировать процессор и выбрать оптимальный алгоритм SAD.<BR>
1 - использовать MMX 16x16, 16x8, 8x8, 8x4, 4x4 (8x16, 4x8 используются только для цветности)<BR>
2 - использовать MMX 16x16, 16x8, 8x8, 8x4 (8x16, используются только для цветности) с выравниванием блоков до 32 байт<BR>
3 - использовать MMX 16x16, 16x8, 8x8, 8x4 (8x16, только цветность) с выравниванием блоков до 64 байт, лучший для Pentium M<BR>
4 - использовать SSE2 16x16, 16x8 (без специального выравнивания)<BR>
5 - использовать SSE2 16x16, 16x8, выравнивание блоков до 64 байт (хорошо для Core)<BR>
6 - использовать SSE3 16x16, 16x8 (кажется работает быстрее только на Pentium 4E или Core1)<BR>
7 - использовать SSSES3 16x16, 16x8, выровненные до 64 байта блоки (хорошо на Core2)<BR>
Режимы 8-12 предназначены для отладки - используйте dct >4 вместо них.<BR>
Использование sadx264 > 7 означает: использовать выбранный вместо SAD для любой яркостной/цветностной SAD, где возможно!<BR>
for SAD / SATD mix and luma only use dct<BR>
8 - использовать SSD mmx, работает аналогично 1<BR>
9 - использовать SATD mmx, работает аналогично 1<BR>
10 - использовать SATD SSE2, работает аналогично 2<BR>
11 - использовать SATD SSSE3, работает аналогично 2<BR>
12 - использовать SATD SSSE3 с PHADD для 8xY, работает аналогично 2<BR>
По умолчанию 0, используйте -1 или >=13, чтобы использовать старый v1.9.4 код вместо функций SAD из x264<BR>
</p>

<p>Попробуйте использовать функцию <code>MVShow</code> для контроля оцененного поля движения
и настройки параметров.</p>

<p>Замечание: MVAnalyse (если Pel=2) учитывает признак разделенного на поля видео (послеr SeparateFields) 
и автоматически производит коррекцию векторов с учетом вертикального смещения полей разной четности. 
Попробуйте использовать AssumeFrameBased если вам это не нужно.</p>

<h3>MVCompensate</h3>
<p><code>MVCompensate</code> (<var>clip, clip "vectors", bool "scbehavior", int "mode", int "thSAD", 
bool "fields", clip "pelclip", int "idx"</var>)
</p>
<p>Выполняет полную компенсацию движения кадра. Это означает, что блоки
указываемые векторами движения в предыдущем кадре (или последующем, в зависимости от
установок <code>MVAnalyse</code>) будут двигаться вдоль векторов с
целью достичь своих мест в текущем кадре.
</p>
<p><var>scbehavior</var> (по умолчанию true), определяет, какой кадр
будет сохранен при смене сцен. Если true, кадр оставляется неизменным.
Иначе указанный кадр копируется в текущий.</p>
<p><var>mode</var> может быть 0 , 1 (по умолчанию). Mode=0 ранее
означала использование компенсации, созданной во время поиска векторов. Сейчас сведена к mode=1.
Mode=1 означает перерасчет этой компенсации по векторам (так как возможно вы хотите
использовать вектора к другому клипу чем тот, в котором выполнялся
поиск). Режим Mode=2 теперь отменен.</p>
<p><var>thSAD</var> - это порог SAD для безопасной (фиктивной) компенсации. 
Если SAD блока выше чем thSAD, то плок плохой,
и мы используем блок из источника вместо компенсированного блока. 
По умолчанию 10000 (практически отменена).
<p><var>fields</var>: если true и <var>pel=2</var>, добавляет соответствующий 
вертикальный сдвиг (на полпиксела) полей основанного на полях видео.
 Попробуйте использовать это для деинтерлейса (не для понижения шума)<br>
По умолчанию false.
</p>
<p><var>pelclip</var>:  увеличенный исходный клип для использования вместо внутренней субпиксельной интерполяции (для pel=2)
(как в MVAnalyse).<br>
По умолчанию не определен.
</p>
<p><var>idx</var> работает аналогично <var>idx</var>
в <code>MVAnalyse</code>.
</p>
<p>Обработка перекрывающихся блоков реализована  как оконное суммирование блоков 
(аналогично FFT3DFilter, величина overlap до blksize/2) для снижения артефактов блочности. 
</p>

<h3>MVDenoise</h3>
<p><code>MVDenoise</code> (<var>clip,
clip mvs [,...], bool "Y", bool "U", bool "V", int "thT", int "thSAD",
int "thMV"</var>)
</p>
<p>Выполняет базовое временнОе шумоподавление с
компенсацией движения из нескольких клипов векторов mvs. Для опорных кадров выполняется компенсация
движения и затем они сливаются с текущим кадром. Два порога
используются для предотвращения артефактов.
</p>
<p>Первый порог, <var>thT</var>,
определяет, надо ли пиксель, взятый из
предыдущего или следующего кадра, включать в процесс суммирования. Если
этот пиксель отличается более чем на
<var>thT</var> от пикселя текущего кадра, то он не используется.
</p>
<p>Второй, <var>thSAD</var>, определяет,
будет ли блок изменен или нет (по тем же правилам, что и
<var> thSCD1</var>). Если блок изменился, пиксель не сливается с
соответствующими из предыдущего и последующего кадров.</p>
<p><var>thMV</var>
это длина вектора, выше которой блок не используется для шумопонижения.</p>
<p>Наконец, <var>Y</var>, <var>U</var> и <var>V</var> говорят, какие
плоскости должны быть обработаны шумоподавителем.
</p>
<p>По умолчанию: <var>Y</var>, <var>U</var>
и <var>V</var> установлены в true (да), <var>thT</var>
= 10, <var>thSAD</var> = 200 и <var>thMV</var> = 30.
</p>
<p>Это устаревшая функция. Обработка перекрывающихся блоков реализована как простое последовательное покрытие блоками слева направо, сверху вниз.
Данная функция использует скомпенсированные по движению кадры, хранящиеся в клипах векторов.
</p>

<h3>MVMask</h3>
<p><code>MVMask</code> (<var>clip, clip "vectors", int "ml", float "gamma", 
int "kind", int "Ysc"</var>)
</p>
<p>Создает клип масок на основе данных векторов движения.
Маска определяется данными по блокам, но интерполируется до полного размера кадра.
Маска создается как в яркостном канале, так и в плоскостях цветности.
Величины в маске могут быть от 0 (мин) до 255 (макс).</p>
<p>Параметр <var>kind</var> определяет разновидность маски.
<p>Режим <var>kind=0</var> создает маску движения исходя из длины векторов
движения. Функция строит маску лучше, чем
<a href="masktools.htm#motionmask"> MotionMask</a> (
<a href="masktools.htm"> MaskTools</a> ), так
как вектора движения намного более достоверны, чем алгоритм в
MotionMask.
Значение маски 0 означает отсутствие
движения вообще (длина вектора нулевая). Чем больше длина вектора, 
тем больше величина маски (насыщается до 255), масштаб 
определяется параметром <var>ml</var>.
</p> 
<p><var>kind=1</var> позволяет построить маску из величин SAD (суммы абсолютных разностей) 
вместо длин векторов. Это может быть полезно, чтобы выявить проблемные области с плохой оценкой движения.
(Используется внутренний коэффициент blocksize*blocksize/4 для нормализации масштаба <var>ml</var>.)
<p><var>kind=2</var> позволяет построить маску окклюзий (разрывности, заграждения, occlusion) (плохих блоков из-за разрыва, растяжения). 
В настоящей версии используется некоторая нормализованная сумма положительных разностей движения блоков. 
Она может масштабироваться <var>ml</var>.</p>
<p><var>kind=3</var> позволяет построить маску из величин горизонтальной составляющей 
векторов движения  в единицах pel, плюс 128. Масштабные коэффициенты не используются.
</p> 
<p><var>kind=4</var> позволяет построить маску из величин вертикальной составляющей 
векторов движения  в единицах pel, плюс 128. Масштабные коэффициенты не используются.
</p> 
<p><var>kind=5</var> - цветная карта движения как x,y компоненты векторов, 
 показанные на цветовых плоскостях U, V (в единицах pel, плюс 128, масштабные коэффициенты не используются).
</p> 
<var>gamma</var> используется для определения показателя степени
зависимости выхода от входа. 
<var>gamma</var> = 1.0 подразумевает
линейную зависимость, а <var>gamma</var> = 2.0 дает квадратичную.</p>
<var>И наконец, Ysc</var> есть величина, принимаемая маской при смене сцены.
</p>
<p>По умолчанию: <var>kind</var>=0, <var>ml</var> = 100, <var>gamma</var> = 1.0, 
и <var>Ysc</var> = 0.
</p>

<h3>MVSCDetection</h3>

<p><code>MVSCDetection</code> (<var>clip, clip "vectors", int "Ysc"</var>)
</p>
<p>Создает клип маски смены сцены на основе данных векторов движения. 
Маска создается для каналов яркости и цветоразности. Выход без смены сцены равен 0.</p>
<p><var>Ysc</var> - это величина, принимаемая маской при смене сцены, по умолчанию 255.</p>

<h3>MVShow</h3>
<p><code>MVShow</code> (<var>clip,
clip "vectors", int "scale", int "sil", int "tol', bool "showsad"</var>)
</p>
<p>Показывает вектора движения. Параметр <var>scale</var>
позволяет увеличить вектора движения, например для увеличения точности
(когда <var>pel</var> &gt; 1 и <var>scale</var> = 1, невозможно увидеть
изменения менее чем на 1 пиксель).
<var>sil</var> позволяет увидеть различные уровни анализа
(когда для поиска векторов движения задан иерархический анализ и
интересно увидеть что произойдет при более высоких уровнях).
<var>tol</var> - порог допуска (толерантности). Если искажения, вызванные вектором
движения больше <var>tol</var>, то вектор не показывается. Наконец, <var>showsad</var>
позволяет показать среднее значение SAD картинки после компенсации.</p>
<p>По умолчанию: <var>scale</var> = 1, <var>sil</var> = 0, <var>tol</var>
= 20000 и <var>showsad</var> = false (что обеспечивает показ всех
векторов).</p>

<h3>MVChangeCompensate</h3>
<p><code>MVChangeCompensate</code> (<var>clip vectors, clip</var>)</p>
<p>Позволяет изменить компенсированные блоки, хранимые в
потоке векторов движения <var>vectors</var>.</p>

<h3>MVIncrease</h3>
<p><code>MVIncrease</code> (<var>clip, clip "vectors", int "horizontal",
int "vertical", int "idx"</var>)</p>
<p>Позволяет использовать вектора, рассчитанные для версии клипа с
уменьшенными размерами для выполнения компенсации клипа оригинального
размера.</p>
<p><var>horizontal</var> горизонтальное соотношение
между шириной оригинального и уменьшенного клипа.</p>
<p><var>vertical</var> вертикальное соотношение между
высотой оригинального и уменьшенного клипа.</p>
<p><var>idx</var> работает так же, как и в <code>MVAnalyse</code></p>

<h3>MVDepan</h3>
<p><code>MVDepan</code> (<var>clip, clip "vectors", bool "zoom", bool "rot",
float "pixaspect", float "error", bool "info", string "log", float "wrong", float "zerow", int "range"</var>) </p>
<p>Получает вектора движения, оценивает глобальное
движение и помещает данные в выходной кадр в специальном формате для
плагина <a href="depan.htm">DePan</a> (от Fizick).</p>
<p>Меж-кадровое глобальное движение (панорамирование, зум, вращение)
оценивается итерационной процедурой, с использованием только хороших
блоков. </p>
<p>Отвергаемые блоки: 1) вблизи границ кадра; 2) с большим SAD
(по параметру <var>thSCD1</var>); 3) с движением, отличающимся от соседей и
глобального.</p>
<p>Параметры <var>zoom</var> и <var>rot</var> включают оценку зума и
вращения, <var>pixaspect</var> это аспект
пиксела (1.094 для стандартного PAL, 0.911 для стандартного NTSC), <var>error</var>
это максимум отличия от среднего движения.</p>
<p>Оцениваемое глобальное движение кадра выключается в нулевое
для больших ошибок движения <var>error</var> или на смене
сцены (по параметрам <var>thSCD1, thSCD2</var>).
</p>
<p>Параметр <var>info</var> позволяет вывести
информацию по глобальному движению для отладки. </p>
<p>Параметр <var>log</var> позволяет задать имя лог-файла для вывода значений в формате DeShaker, DePan.</p>
<p><var>wrong</var> определяет предел для отброса блоков очень отличных от соседей.
</p>
<p><var>zerow</var> определяет вес нулеых вектров движения (для уменьшения их влияния).
</p>
<p><var>range</var> - число предыдущих (и также последующих) кадров (полей) соседних с запрошенным кадром, 
для которых оценивается движение.</p>
<p>Значения по умолчанию: <var>zoom</var> = true, <var>rot</var> =
true, <var>pixaspect</var> = 1.0, <var>error</var> = 15.0, <i>info</i> = false, <var>wrong</var>=10, <var>zerow</var>=0.05, <var>range</var>=0.</p>
<p>Для оценки глобального движения чересстрочного видео, вы должны разделить поля 
(как для MVAnalyse, так и MVDepan).</p>

<h3>MVFlow</h3>

<p><code>MVFlow</code> (<var>clip, clip "vectors", float "time", int "mode", bool "fields", clip "pelclip", int "idx"</var>)
</p>
<p>Делает компенсацию движения кадра не по блокам (как MVCompensation), а по пикселам. (Flow - течение).
Вектор движения каждого пиксела вычисляется путем билинейной интерполяции векторов движения
текущего и соседних блока (в соответствии с положением пиксела).
Это означает, что пикселы, указываемые вектором в опорном кадре 
будут двигаться (течь) вдоль вектора, чтобы достичь их мест в текущем кадре. 
Данный метод компенсации движения течением не производит блочных артефактов, и хорош для понижения шума, 
но иногда может создать очень странные деформированные картины :). 
Оценка истинного движения настоятельно рекомендуется для этой функции.
Компенсация движения может быть полной или частичной (в промежуточное время).<br>
Ограничение: вектора с компонентами выше 127 будут сброшены к нулевой длине.
</p>
<p><var>time</var>:  процент компенсации движения (по умолчанию=100.0, полная компенсация), 
определяет временной момент между опорным и текущим кадром.</p>
<p><var>mode</var>: режим может быть или 0 (по умолчанию), или 1. <br>
mode=0 - поднести пикселы к каждому месту целевого кадра. Это основной рабочий режим.<br>
mode=1 - сдвинуть пикселы от каждого места источника (опорного). 
Это отладочный (учебный) режим с некоторыми пустыми местами (с нулевой интенсивностью). 
Он может быть использован для генерации маски окклюзий.
</p>
<p><var>fields</var>: если true и <var>pel=2</var>, добавляет соответствующий 
вертикальный сдвиг (на полпиксела) полей основанного на полях видео.
 Попробуйте использовать это для деинтерлейса (не для понижения шума)<br>
По умолчанию false.
</p>
<p><var>pelclip</var>:  увеличенный исходный клип для использования вместо внутренней субпиксельной интерполяции (для pel=2)
(как в MVAnalyse).<br>
По умолчанию не определен.
</p>
<p><var>idx</var> (может) работать как указано для <var>idx</var> в MVAnalyse.</p>

<h3>MVFlowInter</h3>

<p><code>MVFlowInter</code> (<var>clip, clip "mvbw", clip "mvfw", float "time", float "ml", clip "pelclip", int "idx"</var>)
<p>Функция интерполяции движения. Это не то же самое (но подобное) функции MVInterpolate более старых версий MVTools.
Она использует обратные "mvbw" и прямые "mvfw" вектора движения,
чтобы создать изображение в некоторый промежуточный момент времени между текущим и следующим (на delta) кадром.
Она использует по-пиксельную компенсацию движения (методом MVFlow) из обоих кадров. 
Используются внутренние прямая и обратная маски окклюзий - разрывности (методом MVMask <var>kind=2</var>) 
и временные взвешивающие факторы, чтобы произвести выходное изображение с минимальными артефактами.
Оценка истинного движения настоятельно рекомендуется для этой функции.</p>
<p><var>time</var>:  положение интерполяционного момента времени между кадрами (в процентах, по умолчанию=50.0, посредине)</p> 
<p><var>ml</var>:  масштабный параметр маски. Меньшие величины соответствуют более сильной маске окклюзий 
(как в функции MVMask, используйте ее для настройки и отладки). По умолчанию=100.
<p><var>pelclip</var>:  увеличенный исходный клип для использования вместо внутренней субпиксельной интерполяции (для pel=2)
(как в MVAnalyse).<br>
По умолчанию не определен.
</p>
<p><var>idx</var> (может) работать как указано для <var>idx</var> в MVAnalyse.</p>

<h3>MVFlowFps</h3>

<p><code>MVFlowFps</code> (<var>clip, clip "mvbw", clip "mvfw", int "num", int "den", int "mask", float "ml", clip "pelclip", int "idx"</var>)
<p>Будет изменять частоту кадров (fps) клипа (и число кадров).
Функция может быть использована для преобразования частоты, эффектов замедления движения и т.п.
Она использует обратные "mvbw" и прямые "mvfw" вектора движения 
чтобы создать интерполированные изображения в некоторые промежуточные моменты времени между кадрами.
Функция использует по-пиксельный метод компенсации движения (как MVFlow, MVFlowInter). 
Используются внутренние прямая и обратная маски окклюзий - разрывности (методом MVMask <var>kind=2</var>) 
и временные взвешивающие факторы, чтобы произвести выходное изображение с минимальными артефактами.
Оценка истинного движения настоятельно рекомендуется для этой функции.</p>
<p><var>num</var>:  fps числитель выходной частоты кадров. По умолчанию = 25. 
<p><var>den</var>:  fps знаменатель (по умолчанию = 1). Результирующая частота кадров fps = num/den.
В частности для удвоенной NTSC fps=2*29.97 используйте num=60000, den=1001, 
а для удвоенной NTSC FILM fps=2*23.976 используйте num=48000, den=1001.</p>  
Причем если <var>num</var> или <var>den</var> равны нулю, подразумевается удвоенная частота входного клипа (с версии 1.8).</p> 
<p><var>mask</var>: режим обработки:<br>
mask=0 для простых прямой и обратной масок разрывности (использовался в версиях до 1.4.x, самый быстрый);<br>
mask=1 для подобных масок с дополнительным переходом к статическим нулевым векторам в областях рахрывности 
(подобный v1.5.x);<br>
mask=2 для использования дополнительных векторов из смежных кадров для снижения ореолов движущихся объектов
в областях разрывности (v1.8, медленный). ПО умолчанию =2.</p>
<p><var>ml</var>:  масштабный параметр маски. Большие величины соответствуют более слабой маске 
разрывности 
(как в функции MVMask, используйте ее для настройки и отладки). По умолчанию=100.
<p><var>pelclip</var>:  увеличенный исходный клип для использования вместо внутренней субпиксельной интерполяции (для pel=2)
(как в MVAnalyse).<br>
По умолчанию не определен.
</p>
<p><var>idx</var> (может) работать как указано для <var>idx</var> в MVAnalyse.</p>

<h3>MVFlowFps2</h3>

<p><code>MVFlowFps2</code> (<var>clip, clip "mvbw", clip "mvfw", clip "mvbw2", clip "mvfw2", 
int "num", int "den", int "mask", float "ml", clip "pelclip", int "idx", int "idx2"</var>)
<p>Будет изменять частоту кадров (fps) клипа (и число кадров) подобно MVFlowFps, 
но с немного лучшим качеством (и более медленной обработкой), за счет внешнего 
перекрытия блоков.<br>
(Замечание: MVFlowFps теперь имеет более эффективный режим внутреннего перекрытия блоков, и  MVFlowFps2
 является устаревшей. MVFlowFps2 не работает корректно с overlap в MVAnalyse.) <br>
В дополнении к обратным "mvbw" и прямым "mvfw" векторам движения оригинального исходного клипа,
функция MVFlowFps2 использует обратные "mvbw2" и прямые "mvfw2" вектора движения второго (модифицированного) клипа-источника. 
Второй клип должен быть сделан из оригинального исходного клипа путем обрезки (то есть диагонального сдвига)
 на половину размера блока.
Это может быть сделано командой <code>Crop(a,a,-b,-b)</code>, 
где a=b=4 должны использоваться для blksize=8, a=b=8 для blksize=16, и a=2, b=6 для blksize=4 (смотри пример).
Границы блоков будут на разных частях объектов.
MVFlowFps2 обращает сдвиг внутренне и усредняет вектора движения двух источников 
для снижения ошибок оценки движения.
Функция использует по-пиксельный метод компенсации движения (как MVFlow, MVFlowInter). 
Используются внутренние прямая и обратная маски окклюзий - разрывности (методом MVMask <var>kind=2</var>) 
и временные взвешивающие факторы, чтобы произвести выходное изображение с минимальными артефактами.
Оценка истинного движения настоятельно рекомендуется для этой функции.</p>
<p><var>num</var>:  fps числитель выходной частоты кадров. По умолчанию=0. 
Причем если <var>num</var> или <var>den</var> равны нулю, подразумевается удвоенная частота входного клипа.</p> 
<p><var>den</var>:  fps знаменатель (по умолчанию=0). Результирующая частота кадров fps = num/den.
В частности для удвоенной NTSC fps=2*29.97 используйте num=60000, den=1001, 
а для удвоенной NTSC FILM fps=2*23.976 используйте num=48000, den=1001.</p>  
<p><var>mask</var>: режим обработки:<br>
mask=0 для простых прямой и обратной масок разрывности (использовался в версиях до 1.4.x, самый быстрый);<br>
mask=1 для подобных масок с дополнительным переходом к статическим нулевым векторам в областях разрывности 
(подобный v1.5.x);<br>
mask=2 для использования дополнительных векторов из смежных кадров для снижения ореолов движущихся объектов
в областях разрывности (v1.8, медленный). ПО умолчанию =2.</p>
<p><var>ml</var>:  масштабный параметр маски. Большие величины соответствуют более слабой маске окклюзий 
(как в функции MVMask, используйте ее для настройки и отладки). По умолчанию=100.
<p><var>pelclip</var>:  увеличенный исходный клип для использования вместо внутренней субпиксельной интерполяции (для pel=2)
(как в MVAnalyse).<br>
По умолчанию не определен.
</p>
<p><var>idx</var> (может) работать как указано для <var>idx</var> в MVAnalyse.</p>
<p><var>idx2</var> это индекс MVAnalyse второго (смещенного) клипа clip (не должен совпадать с первым idx).</p>

<h3>MVBlockFps</h3>

<p><code>MVBlockFps</code> (<var>clip, clip "mvbw", clip "mvfw", int "num", int "den", int "mode", float "thres", int "idx"</var>)
<p>Данная функция использует основанную на блоках частичную компенсацию блоков
для изменения частоты кадров (fps) клипа (и число кадров).
Она использует обратные "mvbw" и прямые "mvfw" вектора движения 
чтобы создать интерполированные изображения в некоторые промежуточные моменты времени между кадрами.
Некоторые внутренние прямые и обратные маски и временные взвешивающие факторы 
используются для производства выходного изображения. 
(алгоритм основан на функции MVInter старой версии MVTools 1.9.12.) 
Это быстрее, чем MVFlowFps, но может дать блочность и другие артефакты.
Оценка истинного движения настоятельно рекомендуется для этой функции.</p>
<p><var>num</var>:  fps числитель выходной частоты кадров. По умолчанию = 25. 
<p><var>den</var>:  fps знаменатель (по умолчанию = 1). Результирующая частота кадров fps = num/den.
В частности для удвоенной NTSC fps=2*29.97 используйте num=60000, den=1001, 
а для удвоенной NTSC FILM fps=2*23.976 используйте num=48000, den=1001.</p>  
Причем если <var>num</var> или <var>den</var> равны нулю, подразумевается удвоенная частота входного клипа.</p> 
<p><var>mode</var>: режим обработки:<br>
0 - среднее от приведенных прямой и обратной частичных компенсаций движения (быстрый, по умолчанию).<br>
1 - статическая медиана.<br>
2 - динамическая медиана.<br>
3 - взвешенная по времени комбинация принесенных прямых блоков, маскированных смещенными обратными,
и принесенных обратных, маскированных смещенными прямыми.<br>
4 - режим 3, смешанный с простым статическим усреднением по маске разрывности смещенных блоков.<br>
5 - маска разрывности (для отладки).
</p><p><var>thres</var>: порог количества разрывов на блок, для бинаризации маски. 
По умолчнию=0, что внутренне = blksize*blksizeV/4.
</p>
<p><var>idx</var> (может) работать как указано для <var>idx</var> в MVAnalyse для увеличения скорости.</p>

<h3>MVFlowBlur</h3>

<p><code>MVFlowBlur</code> (<var>clip, clip "mvbw", clip "mvfw", float "blur", int "prec", clip "pelclip", int "idx"</var>)
<p>Экспериментальная простая функция размытия движения (motion blur). 
Она может быть использована для создания эффекта Фильма (чтобы имитировать конечное время открытия затвора кинокамеры).
Она использует обратные "mvbw" и прямые "mvfw" вектора движения
для создания и наложения многих копий частично компенсированных пикселов 
в промежуточные моменты времени в некотором интервале размытия вокруг текущего кадра.
Используется по-пиксельная компенсация (метод MVFlow). 
Оценка истинного движения настоятельно рекомендуется для этой функции.</p>
<p><var>blur</var>: временной интервал размытия между кадрами, время открытия затвора (в процентах, по умолчанию=50.0)</p> 
<p><var>prec</var>: точность размытия в единицах пикселов.
 Максимальный шаг между компенсированными размытыми пикселами. По умолчанию =1 (наиболее точно).
<p><var>pelclip</var>:  увеличенный исходный клип для использования вместо внутренней субпиксельной интерполяции (для pel=2)
(как в MVAnalyse).<br>
По умолчанию не определен.
</p>
<p><var>idx</var> (может) работать как указано для <var>idx</var> в MVAnalyse.</p>

<h3>MVDeGrain1, MVDeGrain2 и MVDeGrain3</h3>

<p><code>MVDeGrain1</code> (<var>clip, clip "mvbw", clip "mvfw", int "thSAD", int "thSADC", int "plane", int "limit", clip "pelclip", int "idx"</var>)</p>
<p><code>MVDeGrain2</code> (<var>clip, clip "mvbw", clip "mvfw", clip "mvbw2", clip "mvfw2", int "thSAD", int "thSADC", int "plane", int "limit", clip "pelclip", int "idx"</var>)</p>
<p><code>MVDeGrain3</code> (<var>clip, clip "mvbw", clip "mvfw", clip "mvbw2", clip "mvfw2",
   clip "mvbw3", clip "mvfw3",int "thSAD", int "thSADC", int "plane", int "limit", clip "pelclip", int "idx"</var>)</p>
<p>Производит динамическое понижение шума с компенсацией движения. 
Блоки опорных предыдущих и последующих кадров компенсируются и затем усредняются с текущим кадром
с весовыми факторами зависящими от разницы блоков от текущего (SAD). Функции поддерживают режим перекрытия блоков (overlap).
Обработка перекрывающихся блоков реализована  как оконное суммирование блоков 
(аналогично FFT3DFilter, величина overlap до blksize/2) для снижения артефактов блочности.</p>
<p>MVDeGrain1 имеет временной радиус 1 (использует вектора предыдущего <var>mvfw</var> 
и последующего <var>mvbw</var> кадров).</p>
MVDeGrain2 имеет временной радиус 2 (использует вектора двух предыдущих <var>mvfw2, mvfw</var> 
и двух последующих <var>mvbw, mvbw2</var> кадров). 
MVDeGrain3 имеет временной радиус 3 (использует вектора трех предыдущих <var>mvfw3, mvfw2, mvfw</var> 
и трех последующих <var>mvbw, mvbw2, mvbw3</var> кадров). 
Он медленнее, но дает чуть лучшие результаты (более сильное подавление шума).</p>
<p>Параметр "thSAD" определяет мягкий порог суммы абсолютных разностей блоков (SAD), 
выше которого блоки не дают вклад при усреднении. Блоки с малым SAD имеют наибольший вес.
Вы должны ввести величину thSAD приведенную к блоку 8x8.
Малые величины могут привести к шахматному понижению шума, большие величины могу привести к призракам и артефактам.
<br>
По умолчанию : <var>thSAD</var>=400.
<p><var>"thSADC"</var> есть аналогичный порог для каналов цветности.<br>
По умолчанию, если не определен, то одинаковые для яркости и цветности <var>thSADC</var>=thSAD. 
Если определен, то <var>thSAD</var> используется для цветности, а <var>thSAD</var>для яркости.</p>
<p>Параметр <var>plane</var> устанавливает обрабатываемые цветовые плоскости:<br> 
0 - яркость, 1 - цветность U, 2 - цветность V, 3 - обе цветности, 4 - все. По умолчанию 4.
</p>
<p><var>limit</var>: предел изменения пиксела (подобно плагину DeGrainMedian, для предотвращения некоторых артефактов). 
По умолчанию 255 (нет предела). 
</p>
<p><var>pelclip</var>:  увеличенный исходный клип для использования вместо внутренней субпиксельной интерполяции (для pel=2)
(как в MVAnalyse).<br>
По умолчанию не определен.
</p>
<p><var>idx</var> (может) работать как указано для <var>idx</var> в MVAnalyse.</p>

<h3>MVRecalculate</h3>

<p><code>MVRecalculate</code> (<var>clip, clip vectors, int "thSAD", int "blksize", int "blksizeV", 
int "search", int "searchparam", int "lambda", bool "chroma", 
bool "truemotion", int "lsad", int "pnew", int "overlap", int "overlapV",
string "outfile", int "sharp", clip "pelclip", int "dct", int "divide", bool "mc", int "idx", int "sadx264"</var>)
</p>
<p>Уточняет ранее оцененные (MVAnalyse) вектора движения <var>vectors</var> (и остальные данные) 
для другого клипа clip или для новых параметров (например меньших размеров блоков), после деления divide, и т.п.
Этот двух-стадийный метод может также быть полезным для более стабильной (устойчивой) оценки движения.
Уточнение производится только на самом тонком уровне. 
Интерполированные вектора старых блоков используются как начальные приближения для новых векторов,
с пересчетом  SAD. 
Новые векторы только плохого качества, с SAD выше порога <var>"thSAD"</var>, будут уточняться поиском. 
Вы должны ввести величину <var>thSAD</var>, приведенную (масштабированную) к размерам блока 8x8.
По умолчанию <var>thSAD</var>=200.</p>
Другие параметры - те же, что в MVAnalyse (но вы можете изменить значения параметров). 
Используйте другое значение idx, если клип или блоки - другие.
</p>

<h2><a name="examples"></a>III) Примеры</h2>
<р> Во всех примерах предполагается, что в скрипте уже определен некий исходный клип <var>source</var>:</p>
<pre>source = AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр, и.т.п.
</pre>

<p>Показать вектора движения (вперед) :
</p>
<pre>vectors = source.MVAnalyse(isb = false)
MVShow(vectors)</pre>

<p>Показать аналогичное назад:
</p>
<pre>vectors = source.MVAnalyse(isb = true)
source.MVShow(vectors)</pre>

<p>Использование MVMask :
</p>
<pre>vectors = source.MVAnalyse(isb = false)
source.MVMask(vectors)</pre>

<p>Для шумоподавления:
</p>
<pre>backward_vec2 = source.MVAnalyse(isb = true, lambda = 1000, delta=2)
backward_vec1 = source.MVAnalyse(isb = true, lambda = 1000, delta=1)
forward_vec1 = source.MVAnalyse(isb = false, lambda = 1000, delta=1)
forward_vec2 = source.MVAnalyse(isb = false, lambda = 1000, delta=2)
return source.MVDenoise(backward_vec2,backward_vec1,forward_vec1,forward_vec2,tht=10,thsad=300)</pre>
<p>Чтобы убрать блочность компенсации, хранимой в потоке векторов
движения:</p>
<pre>vectors = source.MVAnalyse(isb = false, lambda = 1000)
compensation = source.MVCompensate(vectors, mode = 0)
compensation = compensation.Deblock() # используем функцию DeBlock
vectors = vectors.MVChangeCompensate(compensation)</pre>
<p>Чтобы
понизить шум c <var>pel</var> = 2, эффективно :</p>
<pre>backward_vec2 = source.MVAnalyse(isb = true, lambda = 1000, delta = 2, pel = 2, idx = 1)
backward_vec1 = source.MVAnalyse(isb = true, lambda = 1000, delta = 1, pel = 2, idx = 1)
forward_vec1 = source.MVAnalyse(isb = false, lambda = 1000, delta = 1, pel = 2, idx = 1)
forward_vec2 = source.MVAnalyse(isb = false, lambda = 1000, delta = 2, pel = 2, idx = 1)
source.MVDenoise(backward_vec2,backward_vec1,forward_vec1,forward_vec2,tht=10,thsad=300)</pre>

<p>Чтобы
использовать MVIncrease : </p>
<pre>vectors = source.reduceby2().mvanalyse(isb = true)
source.MVIncrease(vectors, horizontal = 2, vertical = 2)</pre>

<p>Чтобы использовать MVDepan с плагином <a href="depan.htm">Depan</a> для чересстрочного видео
(пример функции DepanStabilize):</p>
<pre>source = source.AssumeTFF().SeparateFields() # установи корректный порядок полей
vectors = source.MVAnalyse(isb = false)
globalmotion = source.MVDepan(vectors, pixaspect=1.094, thSCD1=400)
DepanStabilize(source, data=globalmotion, cutoff=2.0, mirror=15, pixaspect=1.094)
Weave()
</pre>

<p>Чтобы сгладить проблемные (блочные) области компенсированного кадра с маской заграждения:</p>
<pre>vectors = source.MVAnalyse(isb = false, lambda = 1000)
compensation = source.MVCompensate(vectors) # или используйте MVFlow функцию здесь
# приготовим размытый кадр с некоторой сильной функцией блюра или deblock:
blurred = compensation.DeBlock(quant=51) # используем функцию DeBlock
badmask = source.MVMask(vectors, kind = 2, ml=50)
overlay(compensation,blurred,mask=badmask) # или используйте более быструю MaskedMerge
</pre>

<p>Чтобы восстановить испорченные кадры интерполяцией c MVFlowInter:</p>
<pre>backward_vectors = source.MVAnalyse(isb = true, truemotion=true, pel=2, delta=2, idx=1)
forward_vectors = source.MVAnalyse(isb = false, truemotion=true, pel=2, delta=2, idx=1)
inter = source.MVFlowInter(backward_vectors, forward_vectors, time=50, ml=70, idx=1)
# Предположим плохие кадры 50 и 60
source.trim(0,49) ++ inter.trim(49,-1) \
 ++ source.trim(51,59) ++ inter.trim(59,-1) ++ source.trim(61,0)
</pre>

<p>Чтобы изменить частоту кадров с MVFlowFps:</p>
<pre># предполагаем прогрессивный PAL 25 fps источник
backward_vec = source.MVAnalyse(isb = true, truemotion=true, pel=2, idx=1)
# мы используем яные номера idx для более быстрой обработки
forward_vec = source.MVAnalyse(isb = false, truemotion=true, pel=2, idx=1)
source.MVFlowFps(backward_vec, forward_vec, num=50, den=1, ml=100, idx=1) # получили 50
</pre>

<p>Чтобы удвоить частоту видео кадров с MVFlowFps для самой быстрого проигрывания (почти) в реальном времени:</p>
<pre># предполагаем прогрессивный PAL 25 fps или NTSC фильм 23.976 источник
backward_vec = source.MVAnalyse(blksize=16, isb = true, chroma=false, pel=1, searchparam=1, idx=1)
# мы используем яные номера idx для более быстрой обработки
forward_vec = source.MVAnalyse(blksize=16, isb = false, chroma=false, pel=1, searchparam=1, idx=1)
source.MVFlowFps(backward_vec, forward_vec, num=2*FramerateNumerator(source), \
   den=FramerateDenominator(source), mask=0, idx=1)
</pre>

<p>Чтобы удвоить частоту видео кадров с MVFlowFps для 'наилучших' результатов (но медленной обработки):</p>
<pre># предполагаем прогрессивный PAL 25 fps или NTSC фильм 23.976 источник
backward_vec = source.MVAnalyse(overlap=4, isb = true, pel=2, search=3, idx=1)
# используем перекрытие блоков, полупиксельную точность и исчерпывающий поиск
forward_vec = source.MVAnalyse(overlap=4, isb = false, pel=2, search=3, idx=1)
source.MVFlowFps(backward_vec, forward_vec, num=2*FramerateNumerator(source), \
   den=FramerateDenominator(source), idx=1)
</pre>

<p>Чтобы изменить частоту (fps) с MVFlowFps2:</p>
<pre># Предполагаем прогрессивный PAL 25 к/с источник. Преобразуем его к 50 к/с.
backward_vec = source.MVAnalyse(isb = true, truemotion=true, pel=2, idx=1, search=3)
# мы используем явное указание idx для более быстрой обработки и полный поиск
forward_vec = source.MVAnalyse(isb = false, truemotion=true, pel=2, idx=1, search=3)
cropped = source.crop(4,4,-4,-4) # обрезка на половину размера блока 8
backward_vec2 = cropped.MVAnalyse(isb = true, truemotion=true, pel=2, idx=2, search=3)
forward_vec2 = cropped.MVAnalyse(isb = false, truemotion=true, pel=2, idx=2, search=3)
source.MVFlowFps2(backward_vec,forward_vec,backward_vec2,forward_vec2,num=50,idx=1,idx2=2) 
</pre>

<p>Чтобы генерировать приятное размытие движения с MVFlowBlur:</p>
<pre>backward_vectors = source.MVAnalyse(isb = true, truemotion=true)
forward_vectors = source.MVAnalyse(isb = false, truemotion=true)
source.MVFlowBlur(backward_vectors, forward_vectors, blur=15)
</pre>

<p>Понижение шума с некоторым внешним фильтром (который использует три кадра: предыдущий, текущий, следующий):</p>
<pre>backward_vectors = source.MVAnalyse(isb = true, truemotion=true, delta = 1, idx = 1)
# мы используем явное idx для более быстрой обработки
forward_vectors = source.MVAnalyse(isb = false, truemotion=true, delta = 1, idx = 1)
forward_compensation = source.MVFlow(forward_vectors, idx=1, thSCD1=500) # или используйте MVCompensate
backward_compensation = source.MVFlow(backward_vectors, idx=1, thSCD1=500) # или используйте MVCompensate 
# создадим чередующиеся трех-кадровые последовательности
interleave(forward_compensation, source, backward_compensation) 

DeGrainMedian() # поместите  предпочитаемый Вами временной (пространственно-временной) фильтр здесь

selectevery(3,1) # возвращает фильтрованные только центральные (не компенсированные) кадры
</pre>

<p>Чтобы использовать предварительно отфильтрованный клип для более надежной оценки движения,  
но компенсировать движение нефильтрованного клипа (на примере подавления шума):</p>

<pre># Используем некий шумоподавитель (блюр) или стабилизатор яркости для предварительной фильтрации
prefiltered = source.DeGrainMedian() 
backward_vectors = prefiltered.MVAnalyse(isb = true, truemotion=true, delta = 1, idx = 1)
# мы используем явное idx для более быстрой обработки
forward_vectors = prefiltered.MVAnalyse(isb = false, truemotion=true, delta = 1, idx = 1)
# используем нефильтрованный оригинальный клип для компенсации движения (с другим idx)
forward_compensation = source.MVFlow(forward_vectors, idx=2) # или используйте MVCompensate(mode=1)
backward_compensation = source.MVFlow(backward_vectors, idx=2) # или используйте MVCompensate(mode=1) 
# создадим чередующиеся трех-кадровые последовательности
interleave(forward_compensation, source, backward_compensation) 

DeGrainMedian() # поместите предпочитаемый Вами временной (пространственно-временной) фильтр здесь

selectevery(3,1) # возвращает фильтрованные только центральные (не компенсированные) кадры
</pre>

<p>Чтобы подавить шум функцией MVDegrain2 с перекрывающимися блоками и субпиксельной точностью :</p>
<pre>backward_vec2 = source.MVAnalyse(isb = true, delta = 2, pel = 2, overlap=4, sharp=1, idx = 1)
backward_vec1 = source.MVAnalyse(isb = true, delta = 1, pel = 2, overlap=4, sharp=1, idx = 1)
forward_vec1 = source.MVAnalyse(isb = false, delta = 1, pel = 2, overlap=4, sharp=1, idx = 1)
forward_vec2 = source.MVAnalyse(isb = false, delta = 2, pel = 2, overlap=4, sharp=1, idx = 1)
source.MVDegrain2(backward_vec1,forward_vec1,backward_vec2,forward_vec2,thSAD=400, idx=1)</pre>

<p>Чтобы подавить шум чересстрочного источника функцией MVDegrain1 с перекрывающимися блоками и субпиксельной точностью:</p>
<pre>fields=source.AssumeTFF().SeparateFields() # или AssumeBFF
backward_vec = fields.MVAnalyse(isb = true, delta = 2, pel = 2, overlap=4, sharp=2, idx = 1)
forward_vec = fields.MVAnalyse(isb = false, delta = 2, pel = 2, overlap=4, sharp=2, idx = 1)
fields.MVDegrain1(backward_vec,forward_vec,thSAD=400,idx=1)
Weave()</pre>

<p>Чтобы подавить шум чересстрочного источника функцией функцией MVDegrain2i :</p>
<pre>function MVDegrain2i(clip "source", int "overlap", int "dct", int "idx")
{
overlap=default(overlap,0) # величина перекрытия (от 0 до 4 для blksize=8)
dct=default(dct,0) # используйте dct=1 для клиров с некоторыми мерцаниями
idx=default(idx,1) # используйте различные idx для разных источников в том же скрипте
fields=source.SeparateFields() # разделим на поля
backward_vec2 = fields.MVAnalyse(isb = true, delta = 2, pel = 2, overlap=overlap, idx = idx,dct=dct)
forward_vec2 = fields.MVAnalyse(isb = false, delta = 2, pel = 2, overlap=overlap, idx = idx,dct=dct)
backward_vec4 = fields.MVAnalyse(isb = true, delta = 4, pel = 2, overlap=overlap, idx = idx,dct=dct)
forward_vec4 = fields.MVAnalyse(isb = false, delta = 4, pel = 2, overlap=overlap, idx = idx,dct=dct)
fields.MVDegrain2(backward_vec2,forward_vec2,backward_vec4,forward_vec4,thSAD=400,idx=idx)
Weave()
}

source=AVISource("video.avi")
mvdegrain2i(source,4,0,1)
</pre>

<p>Как использовать внешний клип субпиксельной интерполяции:</p>
<pre># Загрузим Eedi2 плагин (<a href="http://bengal.missouri.edu/~kes25c/">от tritical</a>) с функцией интерполяции с учетом направлений краев
LoadPlugin("Eedi2.dll")
# создадим увеличенный клип из источника
ups = source.LanczosResize(2*width(source), 2*height(source), src_left=0.25, src_top=0.25)
bv = source.MVAnalyse(isb = true, pel = 2, overlap=4, pelclip=ups, idx = 1)
source.MVCompensate(bv, pelclip=ups, idx=1)
</pre>

<p>Как использовать с MT фильтром и специальной <a href="http://forum.doom9.org/showthread.php?t=94996">многопоточной версией AviSynth</a>:</p>
<pre># Загрузим плагин MT от TSP
LoadPlugin("MT.dll")
avisource("some.avi")
global idx1 = 10  # глобальная подсказка от IanB
MT("""
idx1 = idx1 + 1 
# различные потоки для верней и нижне половины кадра должны иметь разные idx (трюк Foxishadis)
backward_vec2 = MVAnalyse(isb = true, delta = 2, pel = 2, overlap=4, sharp=1, idx = idx1)
backward_vec1 = MVAnalyse(isb = true, delta = 1, pel = 2, overlap=4, sharp=1, idx = idx1)
forward_vec1 = MVAnalyse(isb = false, delta = 1, pel = 2, overlap=4, sharp=1, idx = idx1)
forward_vec2 = MVAnalyse(isb = false, delta = 2, pel = 2, overlap=4, sharp=1, idx = idx1)
last.MVDegrain2(backward_vec1,forward_vec1,backward_vec2,forward_vec2,thSAD=400,idx=idx1)
""",2) # two threads

# Замечание: Режим SetMTMode(2) многопоточного AviSynth также поддерживается MVTools с версии 1.8.4.1 (бета тестирование)
</pre>

<p>Некоторый пример с SetMTMode:</p>
<pre>
SetMTMode(5)
FFmpegSource("some.avi") # avisource не работает с SetMTMode на моих машинах - TSchniede

SetMTMode(2)
idx = 1
backward_vec2 = MVAnalyse(isb = true, delta = 2, pel = 2, overlap=4, sharp=1, idx = idx)
backward_vec1 = MVAnalyse(isb = true, delta = 1, pel = 2, overlap=4, sharp=1, idx = idx)
forward_vec1 = MVAnalyse(isb = false, delta = 1, pel = 2, overlap=4, sharp=1, idx = idx)
forward_vec2 = MVAnalyse(isb = false, delta = 2, pel = 2, overlap=4, sharp=1, idx = idx)
last.MVDegrain2(backward_vec1,forward_vec1,backward_vec2,forward_vec2,thSAD=400,idx=idx)
</pre>

<p>Как использовать предварительно фильтрованный клип и 
пересчитать данные движения для исходного клипа (пример MVFlowFPS)</p>
<pre>
prefiltered = source.DeGrainMedian() # некоторое сглаживание
backward = prefiltered.MVAnalyse(isb=true, idx=1, blksize=16)
forward = prefiltered.MVAnalyse(isb=false, idx=1, blksize=16)
# пересчитать для оригинального клипа и другого размера блоков
forward_re = MVRecalculate(source, forward, idx=2, blksize=8, thSAD=100)
backward_re = MVRecalculate(source, backward, idx=2, blksize=8, thSAD=100)
source.MVFlowFps(backward_re, forward_re, num=50, den=1, idx=2)</pre>

<h2><a name="disclaimer"></a>IV) Отказ (от гарантий)</h2>
<p>Плагин распространяется на условиях лицензии GNU GPL, без всяких гарантий.
Смотрите 'gpl-rus.txt'.<br>
Документация распространяется на условиях лицензии <a href="http://creativecommons.org/licenses/by-sa/3.0/">CreativeCommons BY-SA 3.0 license.</a><br>
<p>Прошу рассмотреть возможность финансовой <a href="http://avisynth.org.ru/donate-rus.html">поддержки</a>.</p>
<p>MVTools использует части кода из следующих проектов:<br>
Увеличение маски (Resizer) (SimpleResize.cpp) из плагина SimpleResize для Avisynth от Tom Barry. http://www.trbarry.com<br>
Быстрое DCT (fdct_mmx.asm) из XVID MPEG-4 VIDEO CODEC. http://www.xvid.org<br>
DCT общее преобразование (смотри fftwlite.h) из библиотеки FFTW (как вызов DLL). http://www.fftw.org<br>
SATD (pixel-32.asm, pixel.asm) и альтернативная SADx264 (sad-a.asm, x86inc.asm, x86inc-32.asm, cpu-32.asm) из проекта x264. http://www.videolan.org/developers/x264.html
(Loren Merritt, Laurent Aimar, Alex Izvorski et al).
</p>

<h2><a name="revisions"></a>V) Ревизии </h2>
<small>
<p>1.11.4.5 (15.11.2008 by Fizick)</p>
<ul>
<li>MVBlockFps: Исправил ошибку левого края</li>
</ul>
<p>1.11.4.4 (15.10.2008 by Fizick)</p>
<ul>
<li>Восстановил старый размер приращения внутреннего кэша как перед версией v1.11.4.2 (есть сообщения о авариях).</li>
</ul>
<p>1.11.4.3 (08.10.2008 by Fizick)</p>
<ul>
<li>MVDenoise: исправил ошибку v.1.11.4 с коррекцией яркости.</li>
<li>MVCompensate: устранил потенциальную утечку памяти (в конструкторе).</li>
</ul>
<p>1.11.4.2 (26.09.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: сократил неиспользуемое компенсацией пространство памяти из клипа векторов (параметр mc).</li>
<li>Уменьшил рост внутреннего кэша.</li>
<li>Все MVFlow функции: исправлена старая пшибка с пикселами для pel=4.</li>
<li>MVAnalyse: добавил параметр rfilter (сглаживающий метод)</li>
<li>MVBlockFps: добавил поддержку YUY2 и pelclip.</li>
<li>Маленькие изменения для стабильности с MT.</li>
</ul>
<p>1.11.0.1 beta (08.09.2008 by Fizick)</p>
<ul>
<li>Новая MVBlockFps для простого поблочного изменения fps (почти в реальном времени :-).</li>
<li>MVAnalyse: более сглаживающий метод сокращения иерархических уровней кадра (подобно ReduceBy2) для сглаживания на каждом уровне.</li>
<li>MVAnalyse: добавил параметр pzero стоимости нулевого вектора для более согласованных векторов движения 
(теперь включено по умолчанию, установите в 0, если вам нужен старый алгоритм).</li>
<li>MVAnalyse: понизил внутреннее ограничение снизу pelsearch с pel до 1 (кто-то просил для скорости в ущерб точности).</li>
<li>MVFlowFps,MVFlowFps2, MVFlowInter: удалил параметр thSAD.</li>
<li>Все функции: удалил параметр mmx.</li>
</ul>
<p>1.10.2.1 (28.08.2008 jn Fizick)</p>
<ul>
<li>MVDegrain1-3: исправил старую ошибку округления, приводящую к некоторому изменению цвета 
(некоторая благодарность Didee за сообщение, хотя оно могло бы быть более настойчивое и в официальной ветке форума по MVTools :).</li>
<li>Уточнил (надеюсь) документацию о pelclip.</li>
</ul>
<p>1.10.2.0 публичная beta (27.08.2008 от Fizick)</p>
<ul>
<li>Отладил и переименовал MVRefine обратно в MVRecalculate :).</li>
<li>MVAnalyse: изменил порог LSAD с резкого на плавный для немного более согласованного движения в плохих областях.</li>
<li>MVAnalyse: исправил старую ошибку для (редко используемого случая) различных величин 
горизонтального и вертикального перекрытия блоков.</li>
</ul>
<p>1.10.1.0 не публичная (22.08.2008 by Fizick)</p>
<ul>
<li>Заменил MVRecalculate более общей функцией MVRefine, которая может уточнять вектора.</li>
</ul>
<p>1.10.0.0 не публичная (18.08.2008 от Fizick)</p>
<ul>
<li>Добавлена функция MVRecalculate для пересчета SAD (как просил Didee).</li>
<li>Исправлены возможные утечки памяти (спасибо josey_wells за замечание)</li>
<li>Другие изменения ветви v.1.9.6.x от josey_wells пока не включены -
 слишком много работы для анализа нового кода и многочисленных косметических переписываний,
  то есть основана на 1.9.5.7</li>
</ul>
<p>1.9.6.x-1.9.7.x ветвь (01.08.2008-26.08.2008 от josey_wells)</p>
<ul>
<li>Добавлены MVAnalyseMulti, MVDegrain, MVMultiExtract функции с внутренней многопоточностью
(которая не требует специального AviSynth, SetMTMode или MT) </li>
<li>Некоторые исправления ошибок (утечки памяти), объединение кода (переписывание)
 для улучшений стабильности и производительности.
Также есть многочисленные изменения из-за добавления класса потоков, семафора, критической секции, 
файлов потоков, для MVDegrain, MVAnalyseMulti, а также вынесение общего кода 
MVDegrain в отдельный базовый класс, перемещение общего кода и т.д.
Нет изменений алгоритмов. 
Смотри <a href="http://forum.doom9.org/showthread.php?t=84770">сообщения форума</a>
 после августа 2008 для загрузки, синтаксиса и обсуждения.</li>
</ul>
<p>1.9.5.7 публичная бета (03.07.2008 от Fizick)</p>
<ul>
<li>Исправил Overlap_2xY_mmx</li>
<li>Добавил (неполный?) список используемых проектов к документации.</li>
</ul>
<p>1.9.5.6 (02.07.2008 от TSchniede)</p>
<ul>
<li>Улучшил Overlap_2xY_mmx, оптимизировал CheckMV2 и LumaSAD.</li>
</ul>
<p>1.9.5.5 (28.06.2008 от TSchniede)</p>
<ul>
<li>Улучшил по умолчанию 2xY SAD и добавил более быстрый 2xY SAD.</li>
</ul>
<p>1.9.5.4 (27.06.2008 by TSchniede)</p>
<ul>
<li>Перенес код авто-детектирования процессора из x264.</li>
<li>Теперь используется x264 SAD автодетектирование по умолчанию</li>
<li>Слил с 1.9.5.1, вновь разрешил режим 32x16 (только для функций не x264)</li>
</ul>
<p>1.9.5.3 (26.06.2008 by TSchniede)</p>
<ul>
<li>Импортировал функции SSD & SATD.</li>
<li>доступ к ним используя sadx264 > 7 или dct > 4.</li>
</ul>
<p>1.9.5.2 (24.06.2008 by TSchniede)</p>
<ul>
<li>Буферировал блок источника в выровненной области перед вычисленем SAD.
Это исправляет крахи если блок источника был невыровнен, из-за overlaped блоков.
В худшем случае это на < 1% медленнее, по большей части это увеличивает производительность.</li>
</ul>
<p>1.9.5.1 public beta (21.06.2008 by Fizick)</p>
<ul>
<li>Включил изменения версии v.1.9.5 от TSchniede.</li>
</ul>
<p>1.9.5 (21.06.2008 by TSchniede), основана на v.1.9.3</p>
<ul>
<li>MVAnalyse: добавил опцию sadx264.</li>
<li>Внутренние модификации - выровнена память плоскостей яркости и цветности, и 
 модифицирована MVTools для интерфейса SAD функций, используемых в x264.</li>
<li>незначительные исправления (деактивировал DebugPrint возможные проблемы)</li>
</ul>
<p>1.9.4.1 beta (12.06.2008 от Fiziick, выпущена 21.06.2008)</p>
<ul>
<li>Исправлено для pel=4 с sharp=2 (спасибо Pustovetov за сообщение и поправку).</li>
<li>MVCompensate: добавлен размер блока 16x2 (сообщение AVIL).</li>
</ul>
<p>1.9.4 бета (08.06.2008 от Fizick)</p>
<ul>
<li>MVAnalyse и др.: добавил размер блока 32x16 (запрос MAG79).</li>
</ul>
<p>1.9.3.1 (05.06.2008 от Fizick)</p>
<ul>
<li>MVIncrease: была неработоспособна (спасибо MAG79 за выявление).</li>
</ul>
<p>1.9.3 (20.04.2008 от Fizick)</p>
<ul>
<li>MVAnalyse: Исправлена ошибка для pelclip (глюк с версии 1.8.5).</li>
<li>MVDegrain: добавил thSADC как порог для цветности (запрос Terranigma).</li>
</ul>
<p>1.9.2 (29.01.2008 от Fizick, но все ошибки были найдены josey_wells)</p>
<ul>
<li>MVDegrain3: исправлена ошибка в коде для блока 16x8; исправлена опечатка (MVDegrain2 вместо MVDegrain3) в сообщениях.</li>
<li>MVAnalyse: исправлена старая ошибка в NStepSearch.</li>
</ul>
<p>1.9.1 бета (15.12.2007 от Fizick)</p>
<ul>
<li>MVAnalyse: увеличил скорость (на 20%) оценки глобального движения (другой метод).</li>
<li>MVAnalyse: добавил ассемблерную оптимизацию для SAD малых блоков (скорость на 50%).</li>
<li>MVMask: Добавил kind=5 цветную карту движения как x,y компоненты векторов, 
 показанные на цветовых плоскостях U, V.</li>
</ul>
<p>1.9.0 (04.12.2007 от Fizick)</p>
<ul>
<li>Добавил MVDegrain3.</li>
</ul>
<p>1.8.6 (02.12.2007 от Fizick)</p>
<ul>
<li>Добавил маски составляющих x,y векторов движения к MVMask (как просил Terka).</li>
</ul>
<p>1.8.5.1 (12.11.2007 от нас:)</p>
<ul>
<li>Слил изменения v1.8.4.3 и v1.8.5, добавил пример MT.</li>
</ul>
<p>1.8.4.3 (05.10.2007 by Tsp)</p>
<ul>
<li>Реализовал детектирование пропусков внутреннего кэш-буфера с ростом буфера (как предложил IanB).</li>
</ul>
<p>1.8.5 (05.11.2007 by Fizick)</p>
<ul>
<li>Добавил параметр pelsearch как параметр поиска (радиус) на самом тонком уровне (просил Terranigma).</li>
<li>Уменьшил внутренний буфер для уменьшения используемой памяти, немного изменены критические секции.</li>
<li>Добавил блоки 16x2 (просил ab_99).</li>
</ul>
<p>1.8.4.2 (25.10.2007 by Tsp)</p>
<ul>
<li>Добавлена критическая секция в интерполяции кадров для исправления редкой ошибки при многопоточной обработке.</li>
</ul>
<p>1.8.4.1 (23.10.2007 by Tsp)</p>
<ul>
<li>Реализован безопасный к потокам доступ к внутреннему буферу 
для корректной многопоточной обработки с SetMTmode(2) в версии Avisynth MT (для многоядерных процессоров).</li>
</ul>
<p>1.8.4 (22.08.2007 by Fizick)</p>
<ul>
<li>divide теперь работает вместе с overlap.</li>
</ul>
<p>1.8.3 (17-20.08.2007 by Fizick)</p>
<ul>
<li>MVFlowFps: переименовал параметр "mode" в "mask", mask=2 по умолчанию.</li>
<li>MVFlowFps2: добавил параметр "mask".</li>
<li>MVFlowFPS, MVFlowFPS2: Восстановил значения по умолчанию num=25, den=1 (как было в версиях 1.7 и ранее)</li>
<li>MVDegrain1, MVGegrain2 - добавил параметр "limit".</li>
</ul>
<p>1.8.2 beta (30.07.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: исправил (увеличил) радиус поиска на самом детальном уровне для pel>1.</li>
<li>Добавил возможность pel=4 для четверть-пиксельной точности.</li>
<li>Переименовал параметр "clip2x" в "pelclip".</li>
</ul>
<p>1.8.1 beta (28.06.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: добавил пост-обработку векторов движения путем деления блоков на подблоки 
для снижения размера зоны интерполяции векторов движения.</li>
<li>MVFlowFps: добавлен параметр "mode" для выбора метода обработки в разрвыных областях (и скорости).</li>
<li>Некоторые внутренние изменения (padding в MVAnalysisData, заголовок к кадрам векторных потоков и др.).</li>
</ul>
<p>1.8.0 beta (22.06.2007 by Fizick)</p>
<ul>
<li>MVFlowInter, MVFlowFPS, MVFlowFPS2, MVMask: улучшил маску разрывности по протяженности</li>
<li>MVFlowInter, MVFlowFPS, MVFlowFPS2: уменьшил ореолы объектов в областях разрывности использованием векторов движения смежных кадров</li>
<li>MVFlowInter, MVFlowFPS, MVFlowFPS2: отменил маску SAD и параметр thSAD</li>
<li>MVFlowFPS, MVFlowFPS2: изменил значение выходного fps на удвоенное от входного< (num, den = 0)/li>
<li>MVShow: исправил показываемое положение векторов</li>
<li>Добавил сообщения об ошибке при пропущенных векторных клипах</li>
</ul>
<p>1.7.0 beta (05.06.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: добавил параметры blksizeV и overlapV для неквадратных блоков 8x4 и 16x8.</li>
</ul>
<p>1.6.4 (30.05.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: изменил порядок векторов для Исчерпывающего поиска (расширяющиеся квадраты).</li>
<li>MVAnalyse: исправил ошибку с dct=3.</li>
<li>MVFlowFps, MVFlowFPS2, MVFlowInter: теперь смешивают кадры с плохой оценкой движения (на сменах сцен, вспышках).</li>
<li>MVFlowFps, MVFlowFPS2: исправил ошибку с параметром thSAD (и соответтствующей маской).</li>
</ul>
<p>1.6.3 (06.05.2007 by Fizick)</p>
<ul>
<li>MVDepan: больше совместимости с DepanEstimate (параметр range и т.д.).</li>
</ul>
<p>1.6.2 (11.11.2006 by Fizick)</p>
<ul>
<li>MVAnalyse: изменил режим DCT=2 на зависящий от глобальной яркости.</li>
</ul>
<p>1.6.1 beta (25.10.2006 by Fizick)</p>
<ul>
<li>MVAnalyse: добавил экспериментальный режим DCT, чтобы улучшить оценку движения при мерцаниях и затуханиях яркости (быстрый только для blksize=8).</li>
</ul>
<p>1.5.8 beta (14.10.2006 by Fizick)</p>
<ul>
<li>Многие функции: добавил параметр <var>clip2x</var> для использования 2X увеличенного клипа вместо внутренней субпиксельной интерполяции для pel=2</li>
<li>MVFlowFps, MVFlowFps2: добавил параметр <var>thSAD</var>; используем локальное смешение пикселов соседних кадров
 в областях с плохими векторами движения</li>
<li>MVFlowFps, MVFlowFps2: могут использовать вектора движения для произвольного расстояния между кадрами <var>delta</var></li>
<li>MVFlowFps, MVFlowFps2: исправил ошибку видео с большими делимыми и делителями (спасибо Trixter за доклад)</li>
<li>MVCompensate: добавил экспериментальный параметр <var>fields</var>
 чтобы компенсировать вертикальное смещение полей основанного на полях видео для pel=2</li>
<li>MVAnalyse: изменил параметр pnew на относительный к величине SAD</li>
</ul>
<p>1.5.3 beta (01.10.2006 by Fizick)</p>
<ul>
<li>MVAnalyse: улучшил оценку нулевого движения для разделенного на поля видео для pel=2</li>
<li>Временно вернул MVIncrease, MVChangeCompensation, MVDenoise (с хранением компенсации в клипе векторов)</li>
<li>Присоединил v1.4.12-1.4.13 изменения</li>
</ul>
<p>1.5.1 beta (05.09.2006 by Fizick)</p>
<ul>
<li>Присоединил v1.4.11 изменения</li>
</ul>
<p>1.5.0 beta (23.08.2006 by Fizick)</p>
<ul>
<li>Скорректировал интерполяцию предикторов векторов (от грубой к тонкой шкале) для overlap>0.</li>
<li>MVFlowInter: добавил параметр thSAD.</li>
<li>MVFlowInter: локальное смешивание пикселов соседних кадров
 в регионах с плохими векторами движения.</li>
<li>Удалил хранение компенсации в клипе векторов.</li>
<li>Удалил функции MVIncrease, MVChangeCompensation, MVDenoise 
(она использовала компенсацию в клипе векторов, и не поддерживала перекрытие).</li>
<li>Удалил режим петли mode=2 MVCompensation, режим mode=0 тепрь обрабатывается как mode=1.</li>
<li>Добавил параметр thSAD к MVCompensation для безопасной (фиктивной) компенсации как просил Didee.</li>
</ul>
<p>1.4.13 (28.09.2006 by Fizick)</p>
<ul>
<li>Исправлена ошибка с возможными ошибочными указателями кадров в ядре (MVClip.Update), 
маскируемая кэшированием (спасибо IanB за совет)</li>
</ul>
<p>1.4.12 (25.09.2006 by Fizick)</p>
<ul>
<li>Вроде исправлена ошибка с кэшированием кадров в MVDenoise (и возможно в MVDegrain) (спасибо il9ad за доклад)</li>
</ul>
<p>1.4.11 (06.09.2006 by Fizick)</p>
<ul>
<li>Подправил интерполяцию предикторов векторов (от грубого до тонкого масштаба) для overlap>0.</li>
<li>Исправлена ошибка с шириной для overlap=0, YV12 в MVDegrain1 (спасибо Boulder за доклад)</li>
</ul>
<p>1.4.10 (18.08.2006 by Fizick)</p>
<ul>
<li>Подправил обработку правого и нижнего края в MVCompensate для произвольных размеров кадра.</li>
<li>Изменил значения по умолчанию в MVAnalyse: pel=2, truemotion=true, sharp=2.</li>
</ul>
<p>1.4.9 (14.08.2006 by Fizick)</p>
<ul>
<li>Исправил ошибку в MMX оптимизации к режиму перекрытия в MVDeGrain, MVCompensate для YUY2 с blksize=8
 (спасибо TSchniede за доклад).</li>
</ul>
<p>1.4.8 (31.07.2006 by Fizick)</p>
<ul>
<li>Добавил некоторую MMX оптимизацию к режиму перекрытия в MVDeGrain, MVCompensate.</li>
<li>Исправил ошибку с последними (не обрабатываемыми) строками в MVDeGrain.</li>
</ul>
<p>1.4.7 (25.07.2006 by Fizick)</p>
<ul>
<li>Снизил сеточность перекрытия в MVDeGrain1, MVDeGrain2, MVCompensate.</li>
<li>Добавил пример с MVDeGrain1 для чересстоочного</li>
</ul>
<p>1.4.6 (24.07.2006 by Fizick)</p>
<ul>
<li>Снижено шумоподавление в MVDeGrain1, MVDeGrain2.</li>
<li>Параметр plane в MVDeGrain1, MVDeGrain2 теперь работает :)</li>
</ul>
<p>1.4.5 (22.07.2006 by Fizick)</p>
<ul>
<li>Добавлен параметр plane в MVDeGrain1, MVDeGrain2.</li>
</ul>
<p>1.4.4 (19.07.2006 by Fizick)</p>
<ul>
<li>Исправил значение по умолчанию thSAD=400 в MVDeGrain1, MVDeGrain2.</li>
<li>Исправил ошибку с цветовой плоскостью V в MVChangeCompensate.</li>
</ul>
<p>1.4.3 (17.07.2006 by Fizick)</p>
<ul>
<li>Снизил сеточность перекрытия в MVDeGrain1, MVDeGrain2.</li>
</ul>
<p>1.4.2 (16.07.2006 by Fizick)</p>
<ul>
<li>Исправил ошибку доступа к памяти в MVDeGrain1, MVDeGrain2. Спасибо krieger2005 за доклад.</li>
</ul>
<p>1.4.1 (23.06.2006 by Fizick)</p>
<ul>
<li>Изменил режим MVDeGrain1, MVDeGrain2 на взвешивание по SAD.</li>
<li>Изменил thSCD1 по умолчанию с 300 до 400.</li>
</ul>
<p>1.4.0 (19.06.2006 by Fizick)</p>
<ul>
<li>Добавил MVDeGrain1, MVDeGrain2 ограниченные усредняющие шумоподавители.</li>
<li>Исправил масштаб thSAD в MVDenoise.</li>
<li>Исправил документацию о SAD.</li>
</ul>
<p>1.3.1 (11.06.2006 by Fizick)</p>
<ul>
<li>Добавил бикубический метод субпиксельной интерполяции для pel=2 (с iSSE оптимизацией для sharp=1,2).</li>
<li>Ассемблерная SSE оптимизация скорости для метода компенсации с перекрытием блоков.</li>
</ul>
<p>1.3.0 (05.06.2006 by Fizick)</p>
<ul>
<li>Реализовал компенсацию движения перекрывающихся блоков в MVCompensation(mode=1).</li>
<li>Изменил режим по умолчанию на mode=1 в MVCompensation как наиболее универсальный.</li>
<li>Добавил метод резкой субпиксельной интерполяции для pel=2.</li>
<li>Исправил ошибку для blksize=16 с YUY2.</li>
<li>(Список на будущее: ассемблерная SSE оптимизация скорости для новых методов компенсации и интерполяции.)</li>
</ul>
<p>1.2.6 beta (21.05.2006 by Fizick)</p>
<ul>
<li>Добавил опцию выводить данные по векторам движения в лог файл, как просил Endre.</li>
</ul>
<p>1.2.5 (08.05.2006 by Fizick)</p>
<ul>
<li>Снижен вес нулевого вектора, погрешнось итераций в MVDepan</li>
</ul>
<p>1.2.4 (07.04.2006 by Fizick)</p>
<ul>
<li>Исправлена ошибка v.1.2.3 в режиме info в MVDepan</li>
</ul>
<p>1.2.3 (31.03.2006 by Fizick)</p>
<ul>
<li>Реализована обработка разделеного на поля чересстрочного видео в MVDepan;</li>
<li>добавлена опция лог-файла в MVDepan.</li>
</ul>
<p>1.2.2 beta (01.03.2006 by Fizick)</p>
<ul>
<li>Исправлена ошибка сдвига кадра v1.2.1 MMX YUY2 преобразования (спасибо <b>WorBry</b> за сообщение)</li>
</ul>
<p>1.2.1 beta (20.02.2006 by Fizick)</p>
<ul>
<li>Fixed bug of v1.2,</li>
<li>Скорость восстановлена,</li>
<li>MMX YUY2 преобразование (из Avisynth 2.6 функции от sh0dan) </li>
<li>Но режим overlap кажется все еще работает неверно</li>
</ul>
<p>1.2 beta (17.02.2006 by Fizick)</p>
<ul>
<li>YUY2 формат (кроме MVIncrease), без оптимизации </li>
</ul>
<p>1.1.1 (16.02.2006 by Fizick)</p>
<ul>
<li>Удалил фильтры DeBlock и Corrector (не используют вектора движения, будут отдельными плагинами)</li>
<li>Документировал старую функцию MVSCDetection.</li>
<li>Очистил проект от неиспользуемых исходных файлов.</li>
</ul>

<p>1.1 (не публичный выпуск 9.01.2006 by Fizick)</p>
<ul>
<li>Достаточно большая ревизия (бета). Новая опция для оценки движения перекрывающихся блоков в MVAnalyse 
для использования в MVFlow, MVFlowInter, MVFlowFps для улучшенной компенсации движения.</li>
<li>Таблицы для интерполяции движения.</li>
<li>Небольшая коррекция величины смещения в MVFlowFps2.</li>
</ul>
<p>1.0.3 (Выпущена 30.12.2005 by Fizick)</p>
<ul>
<li>Исправил ошибку смещения в MVFlowInter, MVFlowFps (введенную в v1.0.2).</li>
</ul>
<p>1.0.2 (Выпущена 28.12.2005 by Fizick)</p>
<ul>
<li>Скорректровал величину смещения в MVFlow (немного).</li>
</ul>
<p>1.0.1 (Выпущена 24.12.2005 by Fizick)</p>
<ul>
<li>Исправил утечку памяти в MVAnalyse с глобальным движением (спасибо <b>AI</b> за доклад).</li>
<li>Удалил пенальти для нулевого вектора-предиктора в MVAnalyse (был введен в v1.0).</li>
<li>Изменил chroma=true по умолчанию в MVAnalyse.</li>
<li>Добавил пример предварительной фильтрации.</li>
</ul>
<p>1.0 (Выпущена 29.11.2005 by Fizick)</p>
<ul>
<li>Восстановил нулевой вектор как предиктор в MVAnalyse.</li>
<li>Изменил масштаб времени блюра в MVFlowBlur (100 это полностью открытый затвор теперь) как просил <b>Mug Funky</b>.</li>
</ul>
<p>0.9.13.3 (Выпущена 27.11.2005 by Fizick)</p>
<ul>
<li>Добавил вектор глобального движения (простой метод) в качестве предиктора в MVAnalyse.</li>
<li>Поиск векторов прекращается (для скорости), если найден хороший предиктор (с SAD &lt; pnew).</li>
<li>Параметр <var>scale</var> в MVShow теперь работает правильно.</li>
<li>Отменил вывод некоторой отладочной и профилирующей инфомации (для увеличения скорости).</li>
<li>Изменил значение по умолчанию <var>prec</var>=1 (было 2) в MVFlowBlur.</li>
</ul>
<p>0.9.13.2 (Выпущена 22.11.2005 by Fizick)</p>
<ul>
<li>Исправил ошибку в MVFlowFps, MVFlowFps2 для нецелых частот.</li>
</ul>
<p>0.9.13.1 (Выпущена 21.11.2005 by Fizick)</p>
<ul>
<li>Исправил ошибку в MVFlowFps, MVFlowFps2, MVFlowInter, MVFlowBlur (введенную в 0.9.13).</li>
<li>Убрал параметр <var>plen</var> из MVAnalyse как бесполезный.</li>
</ul>
<p>0.9.13 (Выпущена 20.11.2005 by Fizick)</p>
<ul>
<li>Добавил <var>truemotion</var> пресет к MVAnalyse.</li>
<li>Добавил экспериментальную MVFlowFps2.</li>
<li>Изменил метод округления при интерполяции вектора во всех MVFLow... функциях.</li>
<li>Немного отредактирована документация, обновлена русская.</li>
</ul>
<p>0.9.12.4 (Выпущена 15.11.2005 by Fizick)</p>
<ul>
<li>Изменил тип параметра <var>ml</var> в MVMask, MVFlowInter, MVFlowFps с int на float.</li>
<li>Добавил проверки диапазона параметров <var>ml, time, blur</var>.</li>
<li>Исправил малую возможную ошибку (emms).</li>
<li>Частично обновил документацию. Но я не уверен, что <b>sh0dan</b> запрашивал <b>имено такое</b> обновление :). 
Это все еще не руководство пользователя, а справочник по функциям.</li>
</ul>
<p>0.9.12.3 (Выпущена 14.11.2005 by Fizick)</p>
<ul>
<li>Исправлена ошибка для цветности для ширины не кратной 16 в MVMask (введена в v0.9.11).</li>
<li>Некоторая оптимизация скорости MVFlowFps.</li>
<li>Переустановил размер внутренего буфера кадров в превоначальную величину 10. Пробуйте разные версии.</li>
</ul>
<p>0.9.12.2 (Выпущена 13.11.2005 by Fizick)</p>
<ul>
<li>Добавил экспериментальный точную но медленую функцию MVFlowBlur как запрашивал <b>scharfis_brain</b>.</li>
<li>Временно изменил разиер внутреннего буфера на 5.</li>
</ul>
<p>0.9.12.1 (Выпущена 12.11.2005 by Fizick)</p>
<ul>
<li>Добавил экспериментальную функцию MVFlowFps.</li>
<li>Убрал функцию MVInter.</li>
<li>Временно изменил размер внутреннего буфера кадров с 10 до 3 для снижения использования памяти. 
Скорость должна быть протестирована для сложных скриптов.</li>
</ul>
<p>0.9.12 (Выпущена 09.11.2005 by Fizick)</p>
<ul>
<li>Добавлена функция MVFlowInter. Функция MVInter будет удалена из следующего выпуска (она хуже).</li>
<li>Изменил масштаб <var>ml</var> для kind=2 MVMask до более оптимального умолчания.</li>
<li>Исправил небольшую ошибку в Bilinear.asm (странные пикселы у правой границы для pel=2).</li>
</ul>
<p>0.9.11.1 (Выпущена 06.11.2005 by Fizick)</p>
<ul>
<li>Добавил поддержку полу-пикселов pel=2 к MVFlow.</li>
<li>Увеличен максимальный <var>quant</var> с 51 до 60 в DeBlock для очень сильного подавления блочности.</li>
<li>Исправлена документация.</li>
</ul>
<p>0.9.11 (Выпущена 04.11.2005 by Fizick)</p>
<ul>
<li>Улучшена MVMask: Заменен булевый параметр <var>showsad</var> на целый <var>kind</var>, 
добавил опцию маски окклюзий, изменил код билинейного масштабирования на более корректный и быстрый SimpleResize.</li>
</ul>
<p>0.9.10.1 (Выпущена 01.11.2005 by Fizick)</p>
<ul>
<li>Исправил ошибку с малым изменением яркости и цветности в MVInter (ошибка округления).</li>
<li>Интерполяция векторов в MVFlow и маски в MVInter теперь корректны (благодаря исправлению ошибки в SimpleResize).</li>
</ul>
<p>0.9.10 (Выпущена 31.10.2005 by Fizick)</p>
<ul>
<li>Добавлены некоторые опции оценки истинного (сглаженного) движения к MVAnalyse</li>
<li>Добавлена функция MVFlow для по-пиксельной компенсации</li>
<li>Добавлена функция MVInter для интерполяции движения (очень экспериментальная).</li>
</ul>
<p>0.9.9.1 (Выпущена 20.01.2005 by Manao)</p>
<ul>
  <li>Больше нет необходимости в stlport_vcxxxx.dll </li>
</ul>
<p>0.9.9</p>
<ul>
  <li>Добавлена функция: Corrector </li>
  <li>Добавлена
функция: MVIncrease </li>
  <li>Возможен новый размер
блока: 16 </li>
  <li>Новый параметр в MVAnalyse : <var>chroma</var></li>
  <li>Изменения в ядре</li>
</ul>
<p>0.9.8.5</p>
<ul>
  <li>MVCompensate изменена: новый параметр idx,
работающий как idx в
MVAnalyse, и позволяющий увеличить скорость при многократной
компенсации тех же кадров. </li>
</ul>
<p>0.9.8.4</p>
<ul>
  <li>Оценка движения (ME) теперь берет в расчет и
цветовую информацию, как просил tsp. </li>
</ul>
<p>0.9.8.3</p>
<ul>
  <li>Добавлена функция Corrector, как просил scharfi. </li>
</ul>
<p>0.9.8.2</p>
<ul>
  <li>Новая функция MVDepan (добавлена Fizick) для
плагина Depan. </li>
</ul>
0.9.8
<ul>
  <li>Вновь некоторые изменения в синтаксисе фильтров.Сильно изменено
ядро, в основном с целью выигрыша по скорости где возможно. Однако, по
умолчанию выигрыш в скорости не заметен, необходимо корректно
сконфигурировать анализирующий фильтр с помощью параметра "idx" для
выигрыша в скорости (в режиме "pel" = 2). </li>
  <li>Устранены
ошибки в MVDenoise, и цветовом шумоподавлении в
MVDenoise. </li>
  <li>Теперь фильтры, стоящие ниже по
цепочке фильтров, говорят фильтру анализа, если нуждаются в
компенсации, так что вы не должны об этом заботиться на стадии анализа.</li>
</ul>
<p>0.9.7</p>
<ul>
  <li>Вновь многое переписано. Отключены
интерполирующие фильтры (на
время), все другие фильтры работают и предположительно, стабильны.
Слегка изменен синтаксис, и будет меняться до достижения версии 1.0
(если она однажды будет достигнута). Изменения затронули главным
образом <code>MVAnalyse</code>. Новый фильтр:
 <code>MVChangeCompensate</code>. </li>
</ul>
<p>0.9.6.2</p>
<ul>
<li> Исправлена ошибка в параметрах <code>MVMask</code>.</li>
</ul>

<p>0.9.6.1</p>
<ul>
<li>Lot of bugfixes for the existing filters. MVMask, MVShow, MVCompensate, MVDenoise and MVSCDetection, and MVAnalyse should work . 
Other may crash unexpectedly.</li>
<li>Now, for the three new filters. Two have nothing to do with motion compensation, 
but I didn't want to put them in separate binaries, since they'll mainly be used with filters from this package. 
The third one uses vectors, and integrates somehow the two others.</li> 
<li>QDeQuant(clip c, int quant, int level) : takes a clip and quantizes it, using an approximation of the H264 DCT. 
It filters the three planes ( 4x4 blocks for each of them, so the chroma isn't processed as in H264 ). 
It's not exactly the H264 DCT because at q1, it's lossless, and a q51 it's not that bad, but you can raise quant over 51. 
Level is the reference level of the picture. 
By default it's zero, but it can be set, for example, to 128. 
The picture is then treates as if pixels were ranging from -128 to 127, hence avoiding errors around 128.</li>
<li>Deblock(clip c, int quant, int aOffset, int bOffset ) : takes a clip, and deblock it using H264 deblocking, 
as if the picture was made only of inter blocks. This time, quant ranges from 0 to 51 as in H264, and has the same impact. 
aOffset and bOffset allow to raise / lower the quant when deciding for some internal thresholds. 
They are set by default to 0. Be warned that the filter should do nothing at quant < 16, if aOffset and bOffset are both zero. 
It's a wanted behavior ( thus it respect the partially the norm ).</li>
<li>EncDenoise(clip c, clip vectors, bool scbehavior, int quant, int aOffset, int bOffset, int thSCD1, int thSCD2) : 
it merges Deblock, QDeQuant and MVCompensate, taking from them the name and behavior of their parameters. 
It basically does a h264 encode as if all blocks were 8x8 inter blocks. 
Reference frame is the previous frame output by the filter ( if it is the correct one, else it's the previous frame of the source ), 
mvs are those given by mvanalyse on the source. The reference frame is compensated by the vectors, 
then the residual difference is quantized / dequantized and added to the result of the motion compensation. 
Finally, the frame is deblocked, and serves as reference for the next one.</li>
</ul>

<p>0.9.5.3</p>
<ul>
<li>Mainly a bugfixe ( several filters were affected by a silly bug , and MVCompensate now do padded motion compensation, 
and compensate also the chroma ( though it rounds the vector to odd coordinates to do so )</li>
<li>A new feature, as asked by Fizick, for mvcompensate : 
"scbehavior", a boolean set to true by default, will allow you to keep the previous frame over a scenechange if you set it to false.</li>
</ul>

<p>0.9.5.2</p>
<ul>
<li>MVMask has two new parameters : showsad (bool) which allows to build the mask of the SAD values instead of the mask of the vectors' length. Ysc allows you to set the value taken by the mask on scene changes</li>
<li>MVCompensate : behavior modification on scene changes. Now, the current frame is left untouched if a scene change was detected.</li>
<li>New filter : MVSCDetection, with one parameter, Ysc, which works as previously.</li>
<li>MVInterpolate, MVConvertFPS and MVBlur are enabled, but may be buggy ( though I wasn't able to make MVConvertFPS crash )</li>
</ul>

<p>0.9.5</p>
<ul>
  <li>Очень существенно переписано
исполняемое ядро. Вектора теперь
ищутся с точностью от пикселя и выше (в связи с тем, что никакой другой
фильтр, кроме MVShow, еще не может работать с большей точностью).
Механизм поиска сейчас быстрый (что не обязательно подразумевает, что и
фильтры, использующие его информацию тоже быстрые)</li>
  <li>Новый параметр в MVAnalyse : lambda. Смотри документацию выше о
том, как он работает</li>
  <li>MVDenoise работает лучше.</li>
</ul>
<p>0.9.4</p>
<ul>
  <li>Вектора можно сохранять в файле. С этой
целью в фильтре MVAnalyse
добавлен параметр filename="C:\foo.bar". Если файл не существует,
вектора будут сохраняться в нем. Если он существует, то вектора будут
из него читаться. Но обратите внимание:
    <ul>
      <li>Файл для целого фильма будет около 500 MБ</li>
      <li>Сохранение / считывание файла требует в этот момент наличие
прямого доступа к кадрам, потому его можно использовать только во время
кодирования фильма, но не в процессе случайного доступа к его кадрам.</li>
      <li>Прирост скорости не настолько велик, как я надеялся, так как
SAD-ы не могут быть сохранены (это требует слишком много места) и
должны пересчитываться.</li>
    </ul>
  </li>
  <li>Фильтр
MVDenoise теперь работает на 5 кадрах, и его параметры
теперь "thT" и "sadT" (смотрите в документации как они работают). Он
работает&nbsp; весьма приятно (очень хорошо для тяжелого
шумоподавления)</li>
  <li>Порог детектирования смены сцен
слегка изменен. Теперь блок
изменяется, если его SAD больше thSCD1. По умолчанию thSCD1 = 300, и
thSCD2 = 130. Работает хорошо (лучше, чем предыдущий SCD-механизм).</li>
</ul>
<p>0.9.3</p>
<ul>
  <li>Последние чистки в механизме поиска векторов.Теперь должно
работать слегка быстрее</li>
  <li>Больше
параметров поиска, устанавливаемых пользователем, особенно
алгоритм поиска. Смотри документацию </li>
  <li>Обеспечивается
работа клиент / сервер. Теперь сначала
используется MVAnalyse, а потом уже желаемый фильтр. Смотри
документацию и примеры, которые я изменил.</li>
  <li>MVCompensate отделена от MVShow (это более логично). На данный
момент не работает с цветовыми компонентами (поведение аналогично
MVShow в последних версиях)</li>
  <li>Некоторые чистки в MVBlur / MVInterpolate / MVConvertFPS, но
работают они примерно так-же. Теперь MVBlur выполняет размытие в
пределах кадра, а не между текущим и предыдущим кадром.</li>
  <li>Проделано
половина работы для записи векторов в файл. Но
результирующий файл будет больше (около 500 MБ - 1 ГБ, я думаю).</li>
  <li>MVDenoise слегка быстрее (по крайней мере - должен быть)</li>
  <li>Оптимизировано копирование в фильтре, благодаря функциям
копирования AviSynth.</li>
  <li>MVShow может отображать
средний SAD компенсации (с использованием
showsad = true)</li>
</ul>
<p>0.9.2.1</p>
<ul>
  <li>Возвращена функция MVInterpolate.</li>
  <li>MVConvertFPS должна работать и на последних кадрах клипа</li>
</ul>
<p>0.9.2</p>
<ul>
  <li>MVInterpolate больше не существует.</li>
  <li>MVBlur и MVConvertFPS улучшены. Они так же обзавелись новыми
параметрами, смотрите об этом в документации.</li>
  <li>в MVShow возвращен режим компенсации ( MVShow(cm = true) )</li>
</ul>
<p>0.9.1 - 12.05.2004</p>
<ul>
  <li>Первая версия переименованная в MVTools. </li>
</ul>
<p>0.1-0.6 - Выпущена 24.01.2004 - 01.04.2004 by Manao</p>
<ul>
  <li>Первые публичные версии MotionVectors (Motion.dll). </li>
</ul>
</small>

<h2><a name="download"></a>VI) Скачать (Download)</h2>

<h3><a href="mvtools-v1.11.4.5.zip">Download MVTools v.1.11.4.5</a></h3>

<h3>Есть также новая <a href="mvtools2-rus.html">MVTools v2.0 ветвь</a> разработки.</h3> 

<p>Старая версия MVTools v.0.9.9.1 может быть скачена с <a href="http://manao4.free.fr/">сайта Manao</a></p>

<p><kbd>$English Date: 2006/09/17 17:47:05 - более свежие версии пока не на CVS $<br>
Русский перевод версии 0.9.9.1 08.07.2005 Turyst04 <a
 href="mailto:Turyst04@nextmail.ru">Turyst04@nextmail.ru</a><br>
Редакция и дополнения 14.07.2005 Fizick http://bag.hotmail.ru<br>
Подробное введение, добавленные функции и примеры 31.10.2005-2008 Fizick http://avisynth.org.ru</kbd></p>
</body>
</html>

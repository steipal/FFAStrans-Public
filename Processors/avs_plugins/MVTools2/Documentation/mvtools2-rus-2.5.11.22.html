<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ru">
<head>
  <title>MVTools</title>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1251"/>
  <link rel="stylesheet" type="text/css" href="avisynth.css"/>
</head>
<body>
<h1>MVTools</h1>
<h2>Общая информация</h2>
<p>
<b>Авторы:</b>Manao, Fizick(Александр Балахнин), Tsp, TSchniede, SEt<br>
<b>Версия:</b> 2<br>
<b>Загрузка:</b> <a href="http://avisynth.org.ru/mvtools/mvtools2-rus.html#download">http://avisynth.org.ru/</a><br>
<b>Категория:</b> плагины разного назначения (Misc Plugins)<br>
<b>Требования:</b> YV12, YUY2 цветовые форматы
</p>
<hr>
<h2>Содержание:
</h2>
<ul>
  <li><a href="#mvtools">I) О MVTools</a></li>
  <li><a href="#version2">Ia) О MVTools версии 2</a></li>
  <li><a href="#functions">II) Описания функций</a></li>
  <li><a href="#examples">III) Примеры</a></li>
  <li><a href="#disclaimer">IV) Отказ от гарантий (Disclaimer) (не
игнорируйте эту часть, хоть мы и не настаиваем на ее изучении)</a></li>
  <li><a href="#revisions">V) Ревизии</a></li>
  <li><a href="#download">VI) Скачать (Download)</a></li>
</ul>
<h2><a name="MVTools"></a>I) О MVTools</h2>
<p>MVTools плагин для AviSynth 2.5 - это коллекция функций
для оценки и компенсации движения объектов в видео клипах.
Компенсация движения может быть использована для сильного временного понижения шума,
продвинутых преобразований частоты кадров, реставрации изображений и других задач.
</p>
<p>Плагин содержит серверную функцию оценки движения MAnalyse (сервер) для нахождения векторов движения
и несколько клиентских функций компенсации движения (MCompensate, MMask и других),
которые используют эти векторы.
</p>
<p>Плагин использует метод сличения блоков (block-matching) для оценки движения
(подобные методы используются в MPEG2, MPEG4 и т.д).
На стадии анализа плагин разделяет кадры на малые блоки и пробует найти для каждого блока в текущем кадре
наиболее подобный (соответствующий) блок во втором кадре (предыдущем или последующем).
Относительное смещение этих блоков и есть вектор движения.
Основной мерой подобия блоков является сумма абсолютных разностей (SAD) всех пикселов этих двух сравниваемых блоков.
SAD это величина, показывающая, насколько хороша оценка движения.
</p>
<p>Выходом функции MAnalyse является специальный клип с информацией о векторах движения в некотором формате.
</p>
<p>На стадии компенсации клиентские функции плагина читают вектора движения и используют их,
чтобы передвинуть блоки и сформировать кадр с компенсированным движением
(или реализуют какую-либо другую функцию полной или частичной  компенсации или интерполяции).
Каждый объект (блок) в этом (полностью) скомпенсированном кадре помещен в ту же позицию, как этот объект
в текущем кадре. Таким образом, мы можем (например) использовать сильное временное понижение шума
даже для достаточно быстро движущихся объектов без производства раздражающих артефактов и призраков
(особенности и края объектов совпадают, если компенсация совершенна).
Плагин может создать компенсированные соседние кадры для каждого текущего кадра и снизить его шум с помощью
внутренней функции.
Альтернативно, вы можете использовать использовать компенсированные кадры, чтобы создать клип с их чередованием,
понизить его шум с использованием любого внешнего фильтра,
и выбрать для выхода центральные очищенные кадры (смотри примеры).
</p>
<p>Конечно, оценка  компенсация движения не идеальна и не точна.
В некоторых сложных случаях (видео с затуханием, сверх-быстрым движением, периодическими структурами)
оценка движения может быть полностью неверна, и компенсированный (особенно интерполированный) кадр будет блочным и (или) уродливым.
Трудности также представляют заслонение одного объекта другим или наоборот, открытие.
Сложные AviSynth скрипты со многими функциями компенсации движения могут съесть огромное количество памяти
и привести к очень медленной обработке.
Это не простой, а достаточно сложный плагин. Используйте его только для подходящих случаев,
и попытайтесь настроить его параметры.
Есть много обсуждений по поводу использования компенсации движения на (англоязычном) форуме doom9 по AviSynth.
В частности смотрите <a href="http://forum.doom9.org/showthread.php?t=76041">старую ветку по MVTools</a>,
<a href="http://forum.doom9.org/showthread.php?t=102071">ветку по true motion</a>,
<a href="http://forum.doom9.org/showthread.php?t=84770">новую ветку по MVTools</a> и несколько других.
Попробуйте почитать сообщения как дополнения к данной документации и спрашивайте там поддержку.
Если вы действительно заинтересовались вопросами оценки и компенсации движения,
вы легко найдете многочисленные научные публикации (используйте WWW поиск).
</p>
<p>Замечания. Данный плагин еще в стадии разработки. Текущая версия имеет некоторые ограничения.
Поддерживается только прогрессивное видео цветового формата YV12, YUY2.
Используйте преобразование цветовых форматов и попробуйте использовать (разумный) BOB-деинтерлейс
для чересстрочного видео (может также работать разделение на поля SeparateFields с или без SelectEven/SelectOdd).
Некоторые сложные скрипты (MVBOB, MCBOB, TempGaussMC) используют MVTools для <a href="http://forum.doom9.org/showthread.php?t=84725"> деинтерлейса с компенсацией движения.</a><br/>
Альтернативно вы можете попробовать использовать <a href="http://forum.doom9.org/showthread.php?t=101859">плагин Motion</a> от mg262.
</p>

<h2><a name="version2"></a>Ia) О MVTools версии 2</h2>

<p>MVTools версии 2 является значительным внутренним и внешним обновлением.
Главными целями MVTools v2.x являются ясность и стабильность
(в частности для многопоточного окружения с многоядерными процессорами),
и конечно улучшение производительности и использования памяти.</p>
<p>Основное средство достижения целей - удаление внутреннего буфера MVTools
с мистическим (для многих людей) индексом (idx) и некоторых других внутренних трюков
(смотри ветку <a href="http://forum.doom9.org/showthread.php?t=131033">MVTools without idx</a>).
Чтобы реализовать это без ухудшения производительности, мы используем нормальный эффективный кадровый кэш Avisynth
 и вводим новую обязательную подготовительную стадию (перед оценкой движения <code>MAnalyse</code>).
На этой стадии новая функция <code>MSuper</code> будет получать клип-источник и готовить специальный супер клип "super"
с многоуровневыми (иерархически масштабированными) данными по кадрам
(в предыдущих версиях MVTools 0.X-1.X эти многоуровневые данные готовились, хранились и кэшировались внутренне
 с idx как индексом псевдоклипа этих "суперкадров").
Суперклип затем используется как функцией <code>MAnalyse</code>, так и клиентскими функциями  компенсации движения.</p>
<p>Соответствующие изменения синтаксиса: некоторые параметры (pel, sharp)
функции <code>MAnalyse</code> перемещены в функцию <code>MSuper</code>.</p>
<p>Другое существенное внешнее изменение - замена всех именованных клиповых параметров на неименованные
(обязательные, без двойных кавычек в описании) для нормальной работы подразумеваемого клипа "last" в Avisynth.</p>
<p>Также в v2.0 введена более быстрая планарная обработка для YUY2.</p>
<p>С версии 2.2 MVTools.dll переименована в MVTools2.dll, и
с версии 2.3  все функции переименованы из MVxxx в Mxxx (например из MVAnalyse в MAnalyse),
так вы можете продолжать использовать старый MVTools 1.x с вашими старыми скриптами,
и Вы способны создавать и использовать новые скрипты с MvTools 2.x без изменения загружаемых dll.</p>
<p>Я также имею намерение удалить (не переносить) некоторые устаревшие функции типа
MVDenoise, MVFlowFps2 (пожалуйста, голосуйте).</p>
<p>Полный список изменений смотри в разделе <a href="#revisions">Ревизии</a>.</p>
<p>Вообще говоря, новая MVTools 2.0 должна давать  результаты, подобные версии 1.11.4.
Улучшения алгоритмов планируется в версии v2.1 и позже.</p>
<p>Примечание: Версия 2 пока имеет альфа (бета?) статус (она должна быть вполне стабильна для обработки,
но некоторый синтаксис может поменяться).
Приветствуются сообщения о возможных ошибках и предложения (запросы).</p>
<p>Последнее замечание: версии MVTools ветви 1.x больше не разрабатываются и не поддерживаются (Fizick).
</p>

<h2><a name="functions"></a>II)Описания функций </h2>

<h3>Общие параметры</h3>
<p>Фильтры, использующие вектора движения (MV), имеют ряд общих параметров.
Это пороги детектирования сцен и флаги использования mmx/isse. Кроме
того, фильтры используют один или несколько потоков векторов.
</p>
<p>
<var>thSCD1</var> (int): порог определения,
изменился ли блок в
текущем кадре относительно предыдущего. Если блок изменился,
это значит, что предварительный прогноз движения для него в целом
некорректен. Это происходит, например, при смене сцен. То есть это один
из порогов, используемых для отладки механизма детектирования смены сцен.
Его увеличение уменьшит количество блоков,
определяемых как измененные. Это может быть полезно для шумного или мерцающего видео.
Порог сравнивается со значением SAD (Sum
of Absolute Differences - суммой абсолютных различий, значение погрешности,
говорящее о степени несоответствия рассчитанного прогноза движения).
Для строго идентичных блоков мы имеем SAD=0. Но реальные блоки всегда отличаются из-за сложного движения объектов
(приближение, вращение, деформация), дискретности отсчета пикселов, и шума.
Предположим мы имеем два сравниваемых блока 8х8 с каждым из пикселов отличающихся на 5.
В этом случае SAD будет 8x8x5 = 320 (блок будет зарегистрирован как неизменившийся при thSCD1=400).
Если используются блоки 4x4, величина SAD будет  320/4.
Если используются блоки 16x16, величина SAD будет 320/4.
На самом деле этот параметр масштабируется внутренне,
и Вы должны всегда использовать величину, приведенную к размерам блока 8x8.
По умолчанию задано 400 (с версии 1.4.1).
</p>
<p><var>thSCD2</var> (int): порог, задающий количество блоков, которые
должны измениться, чтобы принять решение о смене сцен. Его диапазон
0...255, 0 соответствует 0 %, 255 - 100 %. По умолчанию задано 130 (что
соответствует 51 %).</p>
<p><var>isse</var> (bool): флаг использования ISSE, MMX и других оптимизирующих иннструкций процессора. Установка в false позволяет
отключить оптимизацию для отладки. По умолчанию: true (включенв). Если Ваш процессор не
поддерживает оптимизацию, она все равно будет отключена
(и активировать ее не удастся)</p>
<p><var>planar</var> (bool): логический флаг использования специального планарного цветового формата для YUY2 клипов
как на входе, так и на выходе функций.
Это использует специальный трюк для хранения кадров с планарной цветовой организацией данных
(отдельные плоскости Y, U, V в памяти) в нормальном чередующемся формате YUY2 кадров как контейнере.
Таким способом  мы можем избежать многочисленных внутренних преобразований из чередующегося в планарный формат и увеличить скорость.
Вы можете преобразовать нормальный чередующийся YUY2 исходный клип в планарный формат функцией <code>Interleaved2planar</code>
из <a href="http://home.pages.at/kassandro/RemoveGrain/">плагина RemoveGrain от kassandro</a>,
и преобразовать конечный результат функцией <code>Planar2interleaved</code>.
Этот специальный планарный YUY2 также поддерживается плагином Removegrain от Kassandro, плагином MaskTools2 от Manao и некоторыми другими.
Данный трюк не будет нужен в Avisynth v2.6 с внутренней поддержкой планарного формата YV16.
Данный параметр игнорируется для клипов в формате YV12. Примечание: суперклип всегда планарный.
По умолчанию planar=false.  </p>

<h3>MSuper</h3>

<p><code>MSuper</code> (<var>clip, int "hpad", int "vpad", int "pel", int "levels", bool "chroma",
int "sharp", int "rfilter", clip "pelclip", bool "isse", bool "planar"</var>)
</p>
<p>Получает исходный клип и готовит специальный "super" клип с многоуровневыми (иерархически масштабированными) данными по кадрам.
Суперклип используется как функцией <code>MAnalyse</code>, так и клиентскими функциями  компенсации движения.<br>
Для хранения и передачи его параметров мы используем аудио свойства суперклипа (а именно, num_audio_samples) в качестве трюка.
Аудио в суперклипе убито. Это является одной из причин, почему мы дополнительно используем исходный клип в клиентских функциях.
Вы можете посмотреть суперклип сами (он использует обычный формат).
</p>
<p><var>hpad</var> : горизонтальное дополнение (бордюр), добавляемый к исходному кадру (слева и справа).
Небольшое дополнение добавляется для более корректной оценки движения вблизи границ кадра.
(В MVTools до версии v2.0, всегда внутренне использовалась величина дополнения, равная размеру блока.
Теперь это не строго, а рекомендация). По умолчанию 8.
</p>
<p><var>vpad</var> : вертикальное дополнение (бордюр), добавляемый к исходному кадру. По умолчанию 8.
</p>
<p><var>pel</var> :  точность прогнозирования движения. 1 означает
точность до целого пиксела, 2 - до полу-пиксела, 4 - до четверти пиксела
(более точное, но медленнее и не всегда лучше из-за большого шага масштаба между уровнями).
По умолчанию: 2 с версии 1.4.10.
</p>
<p><var>levels</var> : число иерархических уровней в кадрах супер клипа.
MAnalyse нуждается во всех уровнях,
но для других клиентских функций достаточно одного самого тонкого уровня (более грубые не используются).
По умолчанию : 0 (авто, создаются все возможные уровни).
</p>
<p><var>chroma</var> : установка в true позволяет готовить и цветовую информацию в суперклипе (false - только яркостную). По умолчанию true. </p>
<p><var>sharp</var>:  метод субпиксельной интерполяции для <var>pel</var>=2,4. <br/>
Используйте 0 для мягкой (билинейной) интерполяции, 1 для бикубической (по 4 точкам, Catmull-Rom),
2 для резкой типа Wiener (по 6 точкам, подобно Lanczos).<br/>
По умолчанию 2.</p>
<p><var>rfilter</var>:  фильтр сглаживания и сокращения (пополам) иерархических уровней.<br/>
0 - простое усреднение 4 пикселов подобно нефильтрованной SimpleResize (старый метод);<br/>
1 - треугольный (смещенный) фильтр подобно ReduceBy2 для большего сглаживания;<br/>
2 - треугольный фильтр подобно BilinearResize для еще большего сглаживания;<br/>
3 - квадратичный фильтр для еще большего сглаживания;<br/>
4 - кубический фильтр подобно BicubicResize(b=1,c=0) для еще большего сглаживания.<br/>
По умолчанию 2 (с версии 2.3.1).
Вы можете также попытаться применить некоторый внешний фильтр к суперклипу или его грубой нижней части (соответствующей вырезкой и наложением).
</p>
<p><var>pelclip</var>: опциональный увеличенный исходный клип для использования вместо внутренней субпиксельной интерполяции (для pel>1).<br/>
Пикселы в строках и столбцах кратных pel (0,2,4,... для pel=2) должны быть оригинальными пикселами источника,
другие пикселы должны быть интерполированы.<br/>
Пример для pel=2: LanczosResize(width*2,height*2,src_left=0.25, src_top=0.25) <br/>
(Недавнее замечание: это справедливо для яркостного канала, но не строго соответствует позициям пикселов цветности внутренней интерполяции в MVTools.
Тем не менее, вектора и компенсация движения вполне подобны для обычных клипов,
Строго та же цветность была бы при src_left=0.5 для YUY2 и дополнительно src_top=0.5 для YV12).<br/>
Другой полезный пример - интерполятор EEDI2 с направленностью вдоль краев.<br/>
По умолчанию не определен.
</p>


<h3>MAnalyse</h3>
<p><code>MAnalyse</code> (<var>clip super, int "blksize", int "blksizeV", int "level", int "search",
int "searchparam", int "pelsearch", bool "isb", int "lambda", bool "chroma", int "delta",
bool "truemotion", int "lsad", int "plevel", bool "global", int "pnew", int "pzero", int "pglobal", int "overlap", int "overlapV",
string "outfile", int "dct", int "divide", int "sadx264", int "badSAD", int "badrange", bool "isse", bool "meander", bool "temporal", bool "trymany"</var>)
</p>
<p> Получает подготовленный многоуровневый суперклип, оценивает движение методом сличения блоков
и производит специальный выходной клип с данными по векторам движения
(используемый другими функциями).<br/>
Реализованы некоторые иерархические многоуровневые методы поиска (от грубого масштаба изображения к тонкому).
Функция использует нулевой вектор и векторы соседних блоков как предикторы (начальные приближения) для текущего блока.
Сначала оценивается разница (SAD) для предикторов,
затем пробный вектор изменяется на некоторую величину в некотором направлении,
оценивается SAD, и так далее.
Принятый новый вектор для блока - это вектор с минимальной разностью (SAD)
(с некоторой поправкой-штрафом для согласованности движения)
</p>
<p><var>super</var> : (неименованный)  многоуровневый суперклип, подготовленный функцией MSuper.</p>
<p><var>blksize</var>: Размер блока (горизонтальный). Возможны только значения 4, 8, 16, 32
(по умолчанию 8). БОльшие блоки менее чувствительны к шумам, и
обрабатываются быстрее, но более грубы.
</p>
<p><var>blksizeV</var> : вертикальный размер блока. По умолчанию равен горизонтальному.
Дополнительные варианты: 4 для blksize=8, 2 и 8 для blksize=16, 16 для blksize=32.</p>
<p><var>levels</var>: Положительная величина - это количество уровней, используемых при
иерархическом анализе во время нахождения векторов движения. <br>
Отрицательная или нулевая величина - это количество грубых уровней, НЕ используемых при
иерархическом анализе во время нахождения векторов движения. Чем оно
меньше, тем обычно лучше (находятся вектора любой длины). Переменная оставлена главным образом для учебных (тестовых) целей.
Иногда <var>levels</var> полезна для предотвращения очень длинных (ложных) векторов (компьютерной графики и т.п.).
По умолчанию = 0 с версии 2.5 (используются все уровни).
</p>
<p><var>search, searchparam, pelsearch</var> : <var>search</var>
определяет тип поиска, а <var>searchparam</var> - дополнительный
параметр (шаг, радиус) поиска, а <var>pelsearch</var> - этот параметр радиуса для самого тонкого (pel) уровня:
</p>
<ul>
  <li><var>search </var>= 0 : 'Однопроходный Поиск' (OneTimeSearch). <var>searchparam</var>
- шаг между каждыми пробуемыми векторами (если <var>searchparam</var>
больше 1, шаг будет постепенно уменьшаться).</li>
  <li><var>search </var>= 1 : 'N-проходный Поиск'(NStepSearch). N
задается параметром <var>searchparam</var>. Это наиболее хорошо
известный алгоритм поиска векторов движения.</li>
  <li><var>search </var>= 2 : Логарифмический поиск, также
называемый Бриллиантовый поиск (Diamond Search). Параметр <var>searchparam</var>
определяет начальный шаг поиска, и он (шаг) также постепенно
уменьшается.</li>
  <li><var>search</var>= 3 : Исчерпывающий поиск, <var>searchparam</var>
- это радиус поиска (сторона квадрата 2*searchparam+1). Метод медленнее, но дает лучшие результаты по значению SAD.</li>
  <li><var>search </var>= 4 : поиск шестиугольниками (Hexagon), параметр <var>searchparam</var> определяет диапазон. (подобно x264).</li>
  <li><var>search </var>= 5 : поиск Нечетными мульти шестиугольниками (UMH), параметр <var>searchparam</var> определяет диапазон. (подобно x264).</li>
  <li><var>search </var>= 6 : чисто Горизонтальный исчерпывающий поиск, <var>searchparam</var> это радиус (ширина 2*radius+1). </li>
  <li><var>search </var>= 7 : чисто Вертикальный исчерпывающий поиск, <var>searchparam</var> это радиус (высота 2*radius+1). </li>
</ul>
<p>
По умолчанию: <var>search</var>=4, <var>searchparam</var>=2, <var>pelsearch</var>=<var>pel</var>.</p>
<p><var>isb</var> : позволяет выбрать прямое направление поиска (от
предыдущего к текущему кадру) для <var>isb</var>=false либо обратное (от последующего к текущему
кадру) для <var>isb</var>=true (это реализовано и названо именно таким образом, не переспрашивайте :-).
По умолчанию <var>isb </var>=false.</p>
<p><var>chroma</var> : установка в true позволяет учитывать и цветовую
информацию при оценке движения (false - только яркостную). По умолчанию true. </p>
<p><var>delta</var> : устанавливает кадровый интервал между указанным и
текущим кадром. По умолчанию он равен 1, что означает, что вектора
движения ищутся между текущим и предыдущим
(или следующим) кадром. Установка в 2 позволит искать mvs между кадром
n и n-2 или n+2 (в зависимости от значения <var>isb</var>).
Если delta отрицательна или ноль, то -delta это абсолютный номер зафикированного опорного кадра.
В этом случае, the <var>isb</var> игнорируется.
Только некоторые функции совместимы с фиксированным опорным кадром (MCompensate, MFlow, MMask, MShow).</p>
<p>Существуют дополнительные параметры, которые устанавливают согласованность векторов движения
для оценки так называемого истинного движения (true motion).
Некоторые найденные поиском блоки другого кадра могут быть наиболее подобны образцовым блокам
текущего блока по критерию интенсивности (SAD), но не отвечать истинному движению объекта.
Например, они могут принадлежать другому подобному объекту в другом углу кадра,
или относиться к некоторой периодической структуре.
Параметры "истинного движения" (true motion) пытаются поддерживать поле движения согласованным, слаженным,
вместо некоторого случайного распределения векторов.
Это особенно важно для частичной компенсации и интерполяции движения.
Некоторые параметры являются экспериментальными и могут быль удалены (заменены)
из последующих версий после тестирования. Пожалуйста, сообщайте ваши заключения.
</p>
<p><var>truemotion</var> это предварительно созданный набор значений этих параметров.
Он позволяет легко переключать значения по умолчанию сразу всех параметров "истинного движения".
Установите его равным <var>true</var> для поиска истинного движения (высокой согласованности векторов),
Установите его равным <var>false</var> для поиска векторов движения с наилучшей SAD.
По умолчанию - <var>true</var> c версии v1.4.10.
В любом случае вы можете настроить каждый параметр индивидуально.</p>
<p><var>lambda</var> : устанавливает согласованность (слаженность, coherence) поля векторов.
Чем выше, тем больше согласованность. Однако, если задать его слишком высоким,
некоторые 'правильные' вектора движения могут быть пропущены.
Величины около 400 - 2000 (для размера блока 8х8) настоятельно рекомендуются.
Внутренне это коэффициент для штрафа к SAD от квадратичной разности вектора от предиктора (соседей),
масштабированный на 256.<br>
По умолчанию 0 для <var>truemotion</var>=false и 1000*blksize*blksizeV/64 для <var>truemotion</var>=true.
</p>
<p><var>lsad</var>: порог SAD для использования <var>lambda</var>. Локальная <var>lambda</var> уменьшается (плавно с версии 1.10.2)
если величина SAD предиктора вектора (сформированного из соседей) больше чем порог.
Это предотвращает использование плохих предикторов, но снижает согласованность движения.
Величины выше 1000 рекомендуются для истинного движения. Величина приводится к блоку 8x8 (с версии 2.0.11).<br>
По умолчанию 400 для <var>truemotion</var>=false и 1200 для <var>truemotion</var>=true.
</p>
<p><var>pnew</var>: относительный штраф (в масштабе 256) к погрешности (SAD) для нового вектора-кандидата.
Пробный вектор будет принят как новый вектор, только если
его SAD со штрафом (SAD + SAD*pnew/256) будет лучше, чем погрешность (SAD) предиктора.
Величины около 50-100 (для размера блока 8х8) рекомендуются для истинного движения.
Это предотвращает замену вполне хороших предикторов на новый вектор с немного лучшей SAD,
но другой длиной и направлением.<br>
По умолчанию 0 для <var>truemotion</var>=false и 50 для <var>truemotion</var>=true.
</p>
<p><var>plevel</var>:  режим масштабирования штрафного коэффициента <var>lambda</var> от уровня.
Величина =0 - без масштабирования, 1 - линейная, 2 - квадратичная зависимость от размера иерархического уровня.
Заметьте, что длина вектора меньше на более низком уровне.<br>
По умолчанию 0 для <var>truemotion</var>=false и 1 для <var>truemotion</var>=true.
</p>
<p><var>global</var>:  оценить глобальное движение (на каждом уровне) и использовать его как дополнительный предиктор.
Оценивается только панорамное смещение (ни зум, ни вращение).
Величина = false означает отменить, true - разрешить.
По умолчанию false для <var>truemotion</var>=false и true для <var>truemotion</var>=true.
</p>
<p><var>pzero</var>: относительный штраф (в масштабе 256) к погрешности (SAD) для нулевого вектора.
Это предотвращает замену вполне хороших предикторов на нулевой вектор с немного лучшей SAD
(<var>lambda</var> не используется для нулевого вектора). По умолчанию равен <var>pnew</var> с версии 1.11.
</p>
<p><var>pglobal</var>: относительный штраф (в масштабе 256) к погрешности (SAD) для глобального предиктора.
(<var>lambda</var> не используется для глобального вектора). По умолчанию равен 0.
</p>
<p><var>overlap</var>:  величина перекрытия блоков (горизонтальная).  Должна быть четной и меньше размера блока
(до blksize/2 для MCompensate).
Шаг между блоками для оценки движения равен (blksize-overlap).
N блоков покрывают размер ((blksize-overlap)*N + overlap) на кадре.
Попробуйте значения перекрытия от blksize/4 до blksize/2.
Чем больше перекрытие, тем больше число блоков, и меньше скорость обработки.
Величина по умолчанию 0. <br>
Функции, поддерживающие режим перекрытия: MFlow, MFlowInter, MFlowFps, MShow, MMask, MCompensate, MDeGrain1, MDeGrain2, MDeGrain3.
</p>
<p><var>overlapV</var>:  вертикальная величина перекрытия блоков.  По умолчанию равна горизонтальной.
Должна быть четной для YV12 и меньше размера блока.</p>
<p><var>outfile</var>:  имя файла для вывода данных по векторам движения.
Эти данные могут быть использованы некоторыми внешними программами
или может быть следующими версиями MVTools для кодирования второго прохода и т.п. <br>
Производимый двоичный файл имеет заголовок (структура MVAnalysisData, смотри исходный код MVInterface.h),
и последовательность данных:<br>
номер кадра, данные вектора (Vx, Vy, SAD) каждого блока,
номер следующего пригодного кадра, данные векторов этого кадра, и т.д.<br>
По умолчанию - пустая строка, не записывать файл.</p>
<p><var>dct</var>: использование DCT (частотный спектр) блоков для расчета отличия блоков (SAD).
Это может в том числе улучшить оценку векторов движения при мерцаниях и затуханиях яркости.<br>
0 - обычные пространственные блоки, не использовать DCT;<br>
1 - использовать DCT блоков вместо пространственной информации (медленно для 8x8, и очень медленно для других размеров);<br>
2 - смешанный режим с весами пространственной и DCT информации, зависящими от разности средней яркости кадров;<br>
3 - адаптивное поблочное переключение от пространственного к равно смешанному (экспериментальный, чуть быстрее).<br>
4 - адаптивное поблочное переключение от пространственного к смешанному с большим весом DCT (экспериментальный, чуть быстрее).<br>
добавленные в 1.9.5.3 режимы:  (требуют sadx264 0-7, используют быструю SATD функцию, только яркость!) <BR>
5 - SATD вместо SAD для яркости<BR>
6 - аналогично 2, но используя SATD<BR>
7 - аналогично 3, но используя SATD<BR>
8 - аналогично 4, но используя SATD<BR>
9 - подобно 2, используя SATD и вес диапазон от только SAD до равных SAD и SATD<BR>
10 - подобно 3/4, использовать SATD вес на SAD, только на сильных изменения яркости<BR>
По умолчанию = 0.
</p>
<p><var>divide</var>: пост-обработка векторов движения путем деления каждого блока на 4 одинаковых меньших подблока.<br>
0 - не делить;<br>
1 - делить блоки и присвоить оригинальный вектор всем 4 подблокам;<br>
2 - делить блоки и присвоить подблокам медианные (с 2 соседними) вектора;<br>
По умолчанию = 0. Размеры блоков и перекрытия должны быть выбраны подходящими после внутреннего деления.
</p>
<p><var>sadx264</var>: использовать SAD функции из кодека x264 если они доступны для данного размера блока<BR>
0 - (по умолчанию) автоматически детектировать процессор и выбрать оптимальный алгоритм SAD.<BR>
1 - использовать MMX 16x16, 16x8, 8x8, 8x4, 4x4 (8x16, 4x8 используются только для цветности)<BR>
2 - использовать MMX 16x16, 16x8, 8x8, 8x4 (8x16, используются только для цветности) с выравниванием блоков до 32 байт<BR>
3 - использовать MMX 16x16, 16x8, 8x8, 8x4 (8x16, только цветность) с выравниванием блоков до 64 байт, лучший для Pentium M<BR>
4 - использовать SSE2 16x16, 16x8 (без специального выравнивания)<BR>
5 - использовать SSE2 16x16, 16x8, выравнивание блоков до 64 байт (хорошо для Core)<BR>
6 - использовать SSE3 16x16, 16x8 (кажется работает быстрее только на Pentium 4E или Core1)<BR>
7 - использовать SSSES3 16x16, 16x8, выровненные до 64 байта блоки (хорошо на Core2)<BR>
Режимы 8-12 предназначены для отладки - используйте dct >4 вместо них.<BR>
Использование sadx264 > 7 означает: использовать выбранный вместо SAD для любой яркостной/цветностной SAD, где возможно!<BR>
for SAD / SATD mix and luma only use dct<BR>
8 - использовать SSD mmx, работает аналогично 1<BR>
9 - использовать SATD mmx, работает аналогично 1<BR>
10 - использовать SATD SSE2, работает аналогично 2<BR>
11 - использовать SATD SSSE3, работает аналогично 2<BR>
12 - использовать SATD SSSE3 с PHADD для 8xY, работает аналогично 2<BR>
По умолчанию 0, используйте -1 или >=13, чтобы использовать старый v1.9.4 код вместо функций SAD из x264<BR>
</p>
<p><var>badSAD</var>: порог SAD для более широкого повторного поиска для плохих блоков. Величина приводится к блоку 8х8.
По умолчанию 10000 (отключающая величина), рекомендованные значения около 1000-2000.<br>
</p>
<p><var>badrange</var>: диапазон (радиус) широкого поиска для плохих блоков.
По умолчанию 24 (в единицах пикселов изображения). Используйте положительные величины для поиска UMH
и негативные величины для Исчерпывающего поиска.
</p>
<p><var>meander</var>: Менять ли направление просмотра рядов блоков попеременно слева направо и справа налево. По умолчанию True с версии 2.5.1.
</p>
<p><var>temporal</var>: использовать ли временной предиктор из векторов движения предыдущего кадра. По умолчанию False. (несовместим с SetMTmode)
</p>
<p><var>trymany</var>: попробовать начать поиски вокруг нескольких предикторов (кроме самого токого уровня). По умолчанию false.
</p>


<p>Попробуйте использовать функцию <code>MShow</code> для контроля оцененного поля движения
и настройки параметров.</p>

<p>Замечание: MAnalyse (если Pel=2) учитывает признак разделенного на поля видео (после SeparateFields)
и автоматически производит коррекцию векторов с учетом вертикального смещения полей разной четности.
Попробуйте использовать AssumeFrameBased, если вам это не нужно.</p>

<h3>MCompensate</h3>
<p><code>MCompensate</code> (<var>clip source, clip super, clip vectors, bool "scbehavior", float "recursion", int "thSAD",
bool "fields", float "time", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Выполняет полную компенсацию движения кадра. Это означает, что блоки
указываемые векторами движения в предыдущем кадре (или последующем, в зависимости от
установок <code>MAnalyse</code>) будут двигаться вдоль векторов с
целью достичь своих мест в текущем кадре.
</p>
<p><var>source</var> : (неименованный) исходный клип, обычно last.</p>
<p><var>super</var> : (неименованный)  многоуровневый суперклип, подготовленный функцией MSuper.</p>
<p><var>vectors</var> (неименованный) клип с векторами движения, произведенный функцией MAnalyse.</p>
<p><var>scbehavior</var> (по умолчанию true), определяет, какой кадр
будет сохранен при смене сцен. Если true, кадр оставляется неизменным.
Иначе указанный кадр копируется в текущий. Аналогично для дополнения на правом и нижнем краях.</p>
<p><var>recursion</var> - это процентный вес ранее компенсированных кадров в новую компенсацию
в специальном рекурсивном режиме. Остальной вес берется (однородно) из заданного опорного кадра (используемого в обычном режиме).
Recursion=100 - это полная рекурсия, подобно кольцевому режиму mode=2 старых версий MVTools v0.9.x.
Не используйте рекурсивный режим, если вы не знаете, что вы делаете. По умолчанию recursion=0.</p>
<p><var>thSAD</var> - это порог SAD для безопасной (фиктивной) компенсации.
Если SAD блока выше чем thSAD, то плок плохой,
и мы используем блок из источника source вместо компенсированного блока.
По умолчанию 10000 (практически отменена).
</p>
<p><var>fields</var>: если true и <var>pel</var>=2 или 4, добавляет соответствующий
вертикальный сдвиг (на полпиксела) полей основанного на полях видео.
 Попробуйте использовать это для деинтерлейса (не для понижения шума)<br/>
По умолчанию false.
</p>
<p><var>time</var>:  процент компенсации движения (по умолчанию =100.0, полная компенсация),
определяет момент времени между опорным и текущим кадром.</p>
<p>Обработка перекрывающихся блоков реализована  как оконное суммирование блоков
(аналогично FFT3DFilter, величина overlap до blksize/2) для снижения артефактов блочности.
</p>


<h3>MMask</h3>
<p><code>MMask</code> (<var>clip source, clip vectors, int "ml", float "gamma",
int "kind", int "Ysc", float "time", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Создает клип масок из исходного клипа на основе данных векторов движения vectors.
Маска определяется данными по блокам, но интерполируется до полного размера кадра.
Маска создается как в яркостном канале, так и в плоскостях цветности.
Величины в маске могут быть от 0 (мин) до 255 (макс).</p>
<p>Параметр <var>kind</var> определяет разновидность маски.
</p>
<p>Режим <var>kind=0</var> создает маску движения исходя из длины векторов
движения. Функция строит маску лучше, чем
функция <code>MotionMask</code> плагина MaskTools, так
как вектора движения намного более достоверны, чем алгоритм в
MotionMask.
Значение маски 0 означает отсутствие
движения вообще (длина вектора нулевая). Чем больше длина вектора,
тем больше величина маски (насыщается до 255), масштаб
определяется параметром <var>ml</var>.
</p>
<p><var>kind=1</var> позволяет построить маску из величин SAD (суммы абсолютных разностей)
вместо длин векторов. Это может быть полезно, чтобы выявить проблемные области с плохой оценкой движения.
(Используется внутренний коэффициент blocksize*blocksize/4 для нормализации масштаба <var>ml</var>.)
</p>
<p><var>kind=2</var> позволяет построить маску окклюзий (разрывности, заграждения, occlusion) (плохих блоков из-за разрыва, растяжения).
В настоящей версии используется некоторая нормализованная сумма положительных разностей движения блоков.
Она может масштабироваться <var>ml</var>.</p>
<p><var>kind=3</var> позволяет построить маску из величин горизонтальной составляющей
векторов движения  в единицах pel плюс 128. Может быть использован масштабный коэффициент <var>ml</var>.
</p>
<p><var>kind=4</var> позволяет построить маску из величин вертикальной составляющей
векторов движения  в единицах pel плюс 128. Может быть использован масштабный коэффициент <var>ml</var>.
</p>
<p><var>kind=5</var> - цветная карта движения как x,y компоненты векторов,
 показанные на цветовых плоскостях U, V (в единицах pel, плюс 128. Может быть использован масштабный коэффициент <var>ml</var>).
</p>
<p>
<var>gamma</var> используется для определения показателя степени
зависимости выхода от входа.
<var>gamma</var> = 1.0 подразумевает
линейную зависимость, а <var>gamma</var> = 2.0 дает квадратичную.</p>
<p>
<var>Ysc</var> есть величина, принимаемая маской при смене сцены.
</p>
<p><var>time</var>:  процент компенсации движения (по умолчанию =100.0, полная компенсация),
определяет момент времени между опорным и текущим кадром.</p>
<p>По умолчанию: <var>kind</var>=0, <var>ml</var> = 100, <var>gamma</var> = 1.0,
и <var>Ysc</var> = 0.
</p>

<h3>MSCDetection</h3>

<p><code>MSCDetection</code> (<var>clip source, clip vectors, int "Ysc", int "thSCD1", int "thSCD2", bool "isse"</var>)
</p>
<p>Создает клип маски смены сцены на основе данных векторов движения vectors.
Маска создается для каналов яркости и цветоразности. Выход без смены сцены равен 0.</p>
<p><var>Ysc</var> - это величина, принимаемая маской при смене сцены, по умолчанию 255.</p>

<h3>MShow</h3>
<p><code>MShow</code> (<var>clip super, clip vectors, int "scale", int
"sil", int "tol", bool "showsad", int "number", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Показывает вектора движения vectors на дополненном бордюрами клипе, загружая суперклип (с версии 2.0.11).<br/>
Параметр <var>scale</var>
позволяет увеличить вектора движения, например для увеличения точности
(когда <var>pel</var> &gt; 1 и <var>scale</var> = 1, невозможно увидеть
изменения менее чем на 1 пиксель).<br/>
<var>sil</var> позволяет увидеть различные уровни анализа
(когда для поиска векторов движения задан иерархический анализ и
интересно увидеть что произойдет при более высоких уровнях).<br/>
<var>tol</var> - порог допуска (толерантности). Если искажения, вызванные вектором
движения больше <var>tol</var>, то вектор не показывается. <br/>
Наконец, <var>showsad</var>
позволяет показать среднее (приведенное к блоку 8х8) значение  SAD картинки после компенсации
и количество (ThSCD2) плохих (ThSCD1) блоков.</p>
<p><var>number</var> позволяет пометить заданный блок (с данным номером) как белый. По умолчанию =-1.
</p>
<p>По умолчанию: <var>scale</var> = 1, <var>sil</var> = 0, <var>tol</var>
= 20000 и <var>showsad</var> = false (что обеспечивает показ всех
векторов).</p>


<h3>MDepan</h3>
<p><code>MDepan</code> (<var>clip, clip vectors, clip "mask", bool "zoom", bool "rot", float
"pixaspect", float "error", bool "info", string "log", float "wrong", float "zerow", int "range",
int "thSCD1", int "thSCD2", bool "isse", bool planar</var>)
</p>
<p>Получает вектора движения vectors, оценивает глобальное
движение и помещает данные в выходной кадр в специальном формате для
плагина <a href="depan.htm">DePan</a> (от Fizick).</p>
<p>Меж-кадровое глобальное движение (панорамирование, зум, вращение)
оценивается итерационной процедурой, с использованием только хороших
блоков. </p>
<p>Отвергаемые блоки: 1) вблизи границ кадра или по маске; 2) с большим SAD
(по параметру <var>thSCD1</var>); 3) с движением, отличающимся от соседей и
глобального.</p>
<p><var>mask</var> клип (если задан) используется для задания весов векторов блоков равными
соответствующим значениям пикселов кадра маски в центре блока (используйте полностью черный, чтобы отвергнуть блок).
Если клип маски не задан, то отвергаются 4 блока у каждой границы (старый до v2.4.3 алгоритм.)</p>
<p>Параметры <var>zoom</var> и <var>rot</var> включают оценку зума и
вращения, <var>pixaspect</var> это аспект
пиксела (1.094 для стандартного PAL, 0.911 для стандартного NTSC), <var>error</var>
это максимум отличия от среднего движения.</p>
<p>Оцениваемое глобальное движение кадра выключается в нулевое
для больших ошибок движения <var>error</var> или на смене
сцены (по параметрам <var>thSCD1, thSCD2</var>).
</p>
<p>Параметр <var>info</var> позволяет вывести
информацию по глобальному движению для отладки. </p>
<p>Параметр <var>log</var> позволяет задать имя лог-файла для вывода значений в формате DeShaker, DePan.</p>
<p><var>wrong</var> определяет предел для отброса блоков очень отличных от соседей.
</p>
<p><var>zerow</var> определяет вес нулевых
векторов движения (для уменьшения их влияния).
</p>
<p><var>range</var> - число предыдущих (и также последующих) кадров (полей) соседних с запрошенным кадром,
для которых оценивается движение.</p>
<p>Значения по умолчанию: <var>zoom</var> = true, <var>rot</var> =
true, <var>pixaspect</var> = 1.0, <var>error</var> = 15.0, <i>info</i> = false, <var>wrong</var>=10, <var>zerow</var>=0.05, <var>range</var>=0.</p>
<p>Для оценки глобального движения чересстрочного видео, вы должны разделить поля
(как для MAnalyse, так и MDepan).</p>

<h3>MFlow</h3>

<p><code>MFlow</code> (<var>clip source, clip super, clip vectors, float "time", int "mode", bool "fields",
int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Делает компенсацию движения кадра не по блокам (как MCompensate), а по пикселам. (Flow - течение).
Вектор движения каждого пиксела вычисляется путем билинейной интерполяции векторов движения
текущего и соседних блоков (в соответствии с положением пиксела).
Это означает, что пикселы, указываемые вектором в опорном кадре
будут двигаться (течь) вдоль вектора, чтобы достичь их мест в текущем кадре.
Данный метод компенсации движения течением не производит блочных артефактов, и хорош для понижения шума,
но иногда может создать очень странные деформированные картины :).
Оценка истинного движения настоятельно рекомендуется для этой функции.
Компенсация движения может быть полной или частичной (в промежуточное время).
</p>
<p><var>source</var> : (неименованный) исходный клип, обычно last.</p>
<p><var>super</var> : (неименованный)  многоуровневый суперклип, подготовленный функцией MSuper.</p>
<p><var>vectors</var> (неименованный) клип с векторами движения, произведенный функцией MAnalyse.</p>
<p><var>time</var>:  процент компенсации движения (по умолчанию=100.0, полная компенсация),
определяет временной момент между опорным и текущим кадром.</p>
<p><var>mode</var>: режим может быть или 0 (по умолчанию), или 1. <br>
mode=0 - поднести пикселы к каждому месту целевого кадра. Это основной рабочий режим.<br>
mode=1 - сдвинуть пикселы от каждого места источника (опорного).
Это отладочный (учебный) режим с некоторыми пустыми местами (с нулевой интенсивностью).
Он может быть использован для генерации маски окклюзий.
</p>
<p><var>fields</var>: если true и <var>pel</var> =2 или 4, добавляет соответствующий
вертикальный сдвиг (на полпиксела) полей основанного на полях видео.
 Попробуйте использовать это для деинтерлейса (не для понижения шума)<br>
По умолчанию false.
</p>

<h3>MFlowInter</h3>

<p><code>MFlowInter</code> (<var>clip source, clip super, clip mvbw, clip mvfw, float "time", float "mL",
bool "blend", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Функция интерполяции движения. Это не то же самое (но подобное) функции MVInterpolate более старых версий MVTools.
Она использует обратные "mvbw" и прямые "mvfw" вектора движения,
чтобы создать изображение в некоторый промежуточный момент времени между текущим и следующим (на delta) кадром.
Она использует по-пиксельную компенсацию движения (методом MFlow) из обоих кадров.
Используются внутренние прямая и обратная маски окклюзий - разрывности (методом MMask <var>kind=2</var>)
и временные взвешивающие факторы, чтобы произвести выходное изображение с минимальными артефактами.
Оценка истинного движения настоятельно рекомендуется для этой функции.</p>
<p><var>source</var> : (неименованный) исходный клип, обычно last.</p>
<p><var>super</var> : (неименованный)  многоуровневый суперклип, подготовленный функцией MSuper.</p>
<p><var>mvbw, mvfw</var> (неименованные) клипы с обратными и прямыми векторами движения, произведенный функцией MAnalyse.</p>
<p><var>time</var>:  положение интерполяционного момента времени между кадрами (в процентах, по умолчанию=50.0, посредине)</p>
<p><var>ml</var>:  масштабный параметр маски. Меньшие величины соответствуют более сильной маске окклюзий
(как в функции MMask, используйте ее для настройки и отладки). По умолчанию=100.
</p>
<p><var>pelclip</var>:  увеличенный исходный клип для использования вместо внутренней субпиксельной интерполяции (для pel=2)
(как в MAnalyse).<br>
По умолчанию не определен.
</p>
<p><var>blend</var>: если True, то смешивать кадры на сменах сцен подобно <code>ConvertFps</code>,
а если False, то повторять последний кадр подобно <code>ChangeFps</code>.
По умолчанию = True.
</p>

<h3>MFlowFps</h3>

<p><code>MFlowFps</code> (<var>clip source, clip super, clip mvbw, clip mvfw, int "num", int "den", int "mask", float "ml",
bool "blend", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Будет изменять частоту кадров (fps) клипа (и число кадров).
Функция может быть использована для преобразования частоты, эффектов замедления движения и т.п.
Она использует обратные "mvbw" и прямые "mvfw" вектора движения
чтобы создать интерполированные изображения в некоторые промежуточные моменты времени между кадрами.
Функция использует по-пиксельный метод компенсации движения (как MFlow, MFlowInter).
Используются внутренние прямая и обратная маски окклюзий - разрывности (методом MMask <var>kind=2</var>)
и временные взвешивающие факторы, чтобы произвести выходное изображение с минимальными артефактами.
Оценка истинного движения настоятельно рекомендуется для этой функции.</p>
<p><var>source</var> : (неименованный) исходный клип, обычно last.</p>
<p><var>super</var> : (неименованный)  многоуровневый суперклип, подготовленный функцией MSuper.</p>
<p><var>mvbw, mvfw</var> (неименованные) клипы с обратными и прямыми векторами движения, произведенный функцией MAnalyse.</p>
<p><var>num</var>:  fps числитель выходной частоты кадров. По умолчанию = 25.
</p>
<p><var>den</var>:  fps знаменатель (по умолчанию = 1). Результирующая частота кадров fps = num/den.
В частности для удвоенной NTSC fps=2*29.97 используйте num=60000, den=1001,
а для удвоенной NTSC FILM fps=2*23.976 используйте num=48000, den=1001.
Причем если <var>num</var> или <var>den</var> равны нулю, подразумевается удвоенная частота входного клипа (с версии 1.8).</p>
<p><var>mask</var>: режим обработки:<br>
mask=0 для простых прямой и обратной масок разрывности (использовался в версиях до 1.4.x, самый быстрый);<br>
mask=1 для подобных масок с дополнительным переходом к статическим нулевым векторам в областях разрывности
(подобный v1.5.x);<br>
mask=2 для использования дополнительных векторов из смежных кадров для снижения ореолов движущихся объектов
в областях разрывности (v1.8, медленный). По умолчанию =2.</p>
<p><var>ml</var>:  масштабный параметр маски. Большие величины соответствуют более слабой маске
разрывности
(как в функции MMask, используйте ее для настройки и отладки). По умолчанию=100.
</p>
<p><var>blend</var>: если True, то смешивать кадры на сменах сцен подобно <code>ConvertFps</code>,
а если False, то или повторять последний кадр подобно <code>ChangeFps</code>.
По умолчанию = True.
</p>


<h3>MBlockFps</h3>

<p><code>MBlockFps</code> (<var>clip, clip super, clip mvbw, clip mvfw, int "num", int "den", int "mode", float "ml",
bool "blend", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Данная функция использует основанную на блоках частичную компенсацию блоков
для изменения частоты кадров (fps) клипа (и число кадров).
Она использует обратные "mvbw" и прямые "mvfw" вектора движения
чтобы создать интерполированные изображения в некоторые промежуточные моменты времени между кадрами.
Некоторые внутренние прямые и обратные маски и временные взвешивающие факторы
используются для производства выходного изображения.
(алгоритм основан на функции MVInter старой версии MVTools 1.9.12.)
Это обычно быстрее, чем MFlowFps, но может дать блочность и другие артефакты.
Оценка истинного движения настоятельно рекомендуется для этой функции.
Некоторые пикселы справа и внизу, не полностью покрытые блоками, будут произведены путем смешения кадров.</p>
<p><var>source</var> : (неименованный) исходный клип, обычно last.</p>
<p><var>super</var> : (неименованный)  многоуровневый суперклип, подготовленный функцией MSuper.</p>
<p><var>mvbw, mvfw</var> (неименованные) клипы с обратными и прямыми векторами движения, произведенный функцией MAnalyse.</p>
<p><var>num</var>:  fps числитель выходной частоты кадров. По умолчанию = 25.
</p>
<p><var>den</var>:  fps знаменатель (по умолчанию = 1). Результирующая частота кадров fps = num/den.
В частности для удвоенной NTSC fps=2*29.97 используйте num=60000, den=1001,
а для удвоенной NTSC FILM fps=2*23.976 используйте num=48000, den=1001.
Причем если <var>num</var> или <var>den</var> равны нулю, подразумевается удвоенная частота входного клипа.</p>
<p><var>mode</var>: режим обработки:<br>
0 - среднее от приведенных прямой и обратной частичных компенсаций движения (быстрый, по умолчанию).<br>
1 - статическая медиана.<br>
2 - динамическая медиана.<br>
3 - взвешенная по времени комбинация принесенных прямых блоков, маскированных смещенными обратными,
и принесенных обратных, маскированных смещенными прямыми.<br>
4 - режим 3, смешанный с простым статическим усреднением по маске разрывности смещенных блоков.<br>
5 - маска разрывности (для отладки).
<br /> 6-8 - режимы подобные 3-5 но вместо маски пазрывности испольуется маска абсолютных разностей SAD.
</p>
<p><var>ml</var>:  масштабный параметр маски. Большие величины соответствуют более слабой маске
разрывности
(как в функции MMask, используйте ее для настройки и отладки). По умолчанию=100.
</p>
<p><var>blend</var>: если True, то смешивать кадры на сменах сцен подобно <code>ConvertFps</code>,
а если False, то повторять последний кадр подобно <code>ChangeFps</code>.
По умолчанию = True.
</p>

<h3>MFlowBlur</h3>

<p><code>MFlowBlur</code> (<var>clip, clip super, clip mvbw, clip mvfw, float "blur", int "prec",
int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Экспериментальная простая функция размытия движения (motion blur).
Она может быть использована для создания эффекта Фильма (чтобы имитировать конечное время открытия затвора кинокамеры).
Она использует обратные "mvbw" и прямые "mvfw" вектора движения
для создания и наложения многих копий частично компенсированных пикселов
в промежуточные моменты времени в некотором интервале размытия вокруг текущего кадра.
Используется по-пиксельная компенсация (метод MFlow).
Оценка истинного движения настоятельно рекомендуется для этой функции.</p>
<p><var>source</var> : (неименованный) исходный клип, обычно last.</p>
<p><var>super</var> : (неименованный)  многоуровневый суперклип, подготовленный функцией MSuper.</p>
<p><var>mvbw, mvfw</var> (неименованные) клипы с обратными и прямыми векторами движения, произведенный функцией MAnalyse.</p>
<p><var>blur</var>: временной интервал размытия между кадрами, время открытия затвора (в процентах, по умолчанию=50.0)</p>
<p><var>prec</var>: точность размытия в единицах пикселов.
 Максимальный шаг между компенсированными размытыми пикселами. По умолчанию =1 (наиболее точно).
</p>
<p><var>pelclip</var>:  увеличенный исходный клип для использования вместо внутренней субпиксельной интерполяции (для pel=2)
(как в MAnalyse).<br>
По умолчанию не определен.
</p>

<h3>MDeGrain1, MDeGrain2 и MDeGrain3</h3>

<p><code>MDeGrain1</code> (<var>clip, clip super, clip mvbw, clip mvfw, int "thSAD", int "thSADC", int "plane", int "limit",
int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)</p>
<p><code>MDeGrain2</code> (<var>clip, clip super, clip mvbw, clip mvfw, clip mvbw2, clip mvfw2, int "thSAD", int "thSADC", int "plane", int "limit",
int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)</p>
<p><code>MDeGrain3</code> (<var>clip, clip super, clip mvbw, clip mvfw, clip mvbw2, clip mvfw2,
   clip mvbw3, clip mvfw3,int "thSAD", int "thSADC", int "plane", int "limit", int "limitC",
   int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)</p>
<p>Производит динамическое понижение шума с компенсацией движения.
Блоки опорных предыдущих и последующих кадров компенсируются и затем усредняются с текущим кадром
с весовыми факторами зависящими от разницы блоков от текущего (SAD). Функции поддерживают режим перекрытия блоков (overlap).
Обработка перекрывающихся блоков реализована  как оконное суммирование блоков
(аналогично FFT3DFilter, величина overlap до blksize/2) для снижения артефактов блочности.</p>
<p>MDeGrain1 имеет временной радиус 1 (использует вектора предыдущего <var>mvfw</var>
и последующего <var>mvbw</var> кадров).<br>
MDeGrain2 имеет временной радиус 2 (использует вектора двух предыдущих <var>mvfw2, mvfw</var>
и двух последующих <var>mvbw, mvbw2</var> кадров). <br />
MDeGrain3 имеет временной радиус 3 (использует вектора трех предыдущих <var>mvfw3, mvfw2, mvfw</var>
и трех последующих <var>mvbw, mvbw2, mvbw3</var> кадров).
Он медленнее, но дает чуть лучшие результаты (более сильное подавление шума).</p>
<p><var>source</var> : (неименованный) исходный клип, обычно last.</p>
<p><var>super</var> : (неименованный)  многоуровневый суперклип, подготовленный функцией MSuper.</p>
<p><var>mvbw, mvfw</var> (неименованные) клипы с обратными и прямыми векторами движения, произведенный функцией MAnalyse.</p>
<p>Параметр "thSAD" определяет мягкий порог суммы абсолютных разностей блоков (SAD),
выше которого блоки не дают вклад при усреднении. Блоки с малым SAD имеют наибольший вес.
Вы должны ввести величину thSAD приведенную к блоку 8x8.
Малые величины могут привести к шахматному понижению шума, большие величины могу привести к призракам и артефактам.
<br>
По умолчанию : <var>thSAD</var>=400.
</p>
<p><var>"thSADC"</var> есть аналогичный порог для каналов цветности.<br>
По умолчанию, если не определен, то одинаковые для яркости и цветности <var>thSADC</var>=<var>thSAD</var>.
Если определен, то <var>thSADC</var> используется для цветности, а <var>thSAD</var>для яркости.</p>
<p>Параметр <var>plane</var> устанавливает обрабатываемые цветовые плоскости:<br>
0 - яркость, 1 - цветность U, 2 - цветность V, 3 - обе цветности, 4 - все. По умолчанию 4.
</p>
<p><var>limit</var>: предел изменения яркости пиксела (пост-обработка подобно плагину DeGrainMedian
и функции LimitChange плагина SSETools, для предотвращения некоторых артефактов).
По умолчанию 255 (нет предела).
</p>
<p><var>limitC</var>: предел изменения цветности пиксела. По умолчанию = <var>limit</var>.
</p>

<h3>MRecalculate</h3>

<p><code>MRecalculate</code> (<var>clip super, clip vectors, int "thSAD", int "smooth", int "blksize", int "blksizeV",
int "search", int "searchparam", int "lambda", bool "chroma",
bool "truemotion", int "pnew", int "overlap", int "overlapV",
string "outfile", int "dct", int "divide", int "sadx264", bool "isse"</var>)
</p>
<p>Уточняет ранее оцененные (MAnalyse) вектора движения <var>vectors</var> (и остальные данные)
для другого клипа <var>super</var> или для новых параметров (например меньших размеров блоков), после деления divide, и т.п.
Этот двух-стадийный метод может также быть полезным для более стабильной (устойчивой) оценки движения.
Уточнение производится только на самом тонком уровне.
Интерполированные вектора старых блоков используются как начальные приближения для новых векторов,
с пересчетом  SAD.
Новые векторы только плохого качества, с SAD выше порога <var>"thSAD"</var>, будут уточняться поиском.
Вы должны ввести величину <var>thSAD</var>, приведенную (масштабированную) к размерам блока 8x8.
По умолчанию <var>thSAD</var>=200.</p>
<p><var>smooth</var> - задает метод деления грубых облоков на меньшие.
0 - использовать вектор движения ближайшего блока, 1 - билинейная интерполяция 4 соседних. По умолчанию 1.</p>
<p>
Другие параметры - те же, что в MAnalyse (но вы можете изменить значения параметров).
Значения по умолчанию - те же, что значения по умолчанию MAnalyse.
</p>

<h2><a name="examples"></a>III) Примеры</h2>

<p>Показать вектора движения (вперед) :
</p>
<pre>AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
vectors = MSuper().MAnalyse(isb = false)
MShow(vectors)</pre>

<p>Показать аналогичное назад:
</p>
<pre>AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
vectors = MSuper().MAnalyse(isb = true)
MShow(vectors)</pre>

<p>Использование MMask :
</p>
<pre>AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
vectors = MSuper().MAnalyse(isb = false)
MMask(vectors)</pre>

<p>Чтобы использовать MDepan с плагином <a href="depan.htm">Depan</a> для чересстрочного видео
(пример функции DepanStabilize):</p>
<pre>AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
AssumeTFF().SeparateFields() # установи корректный порядок полей
vectors = MSuper().MAnalyse(isb = false)
globalmotion = MDepan(vectors, pixaspect=1.094, thSCD1=400)
DepanStabilize(data=globalmotion, cutoff=2.0, mirror=15, pixaspect=1.094)
Weave()
</pre>

<p>Чтобы сгладить проблемные (блочные) области компенсированного кадра с маской заграждения:</p>
<pre>AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
super = MSuper()
vectors = MAnalyse(super, isb = false, lambda = 1000)
compensation = MCompensate(super, vectors) # или используйте MFlow функцию здесь
# приготовим размытый кадр с некоторой сильной функцией блюра или deblock:
blurred = compensation.DeBlock(quant=51) # используем функцию DeBlock
badmask = MMask(vectors, kind = 2, ml=50)
overlay(compensation,blurred,mask=badmask) # или используйте более быструю MaskedMerge
</pre>

<p>Чтобы восстановить испорченные кадры интерполяцией c MFlowInter:</p>
<pre>AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
super = MSuper()
backward_vectors = super.MAnalyse(isb = true, delta=2)
forward_vectors = super.MAnalyse(isb = false, delta=2)
inter = MFlowInter(super, backward_vectors, forward_vectors, time=50, ml=70)
# Предположим плохие кадры 50 и 60
trim(0,49) ++ inter.trim(49,-1) \
 ++ trim(51,59) ++ inter.trim(59,-1) ++ trim(61,0)
</pre>

<p>Чтобы изменить частоту кадров с MFlowFps:</p>
<pre>AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
# предполагаем прогрессивный PAL 25 fps источник
super = MSuper(pel=2)
backward_vec = MAnalyse(super,isb = true)
forward_vec = MAnalyse(super, isb = false)
MFlowFps(super, backward_vec, forward_vec, num=50, den=1, ml=100) # получили 50
</pre>

<p>Чтобы удвоить частоту видео кадров с MFlowFps для самой быстрого проигрывания (почти) в реальном времени:</p>
<pre>AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
# предполагаем прогрессивный PAL 25 fps или NTSC фильм 23.976 источник
super = MSuper(pel=1,hpad=0,vpad=0,chroma=false)
backward_vec = MAnalyse(super, blksize=32, isb = true, chroma=false, searchparam=1,search=0)
forward_vec = MAnalyse(super, blksize=32, isb = false, chroma=false, searchparam=1,search=0)
MFlowFps(super, backward_vec, forward_vec, num=2*FramerateNumerator(last), \
   den=FramerateDenominator(last), mask=0)
</pre>

<p>Чтобы удвоить частоту видео кадров с MFlowFps для 'наилучших' результатов (но медленной обработки):</p>
<pre>AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
# предполагаем прогрессивный PAL 25 fps или NTSC фильм 23.976 источник
super = MSuper(pel=2)
backward_vec = MAnalyse(super, overlap=4, isb = true, search=3)
# используем перекрытие блоков, полупиксельную точность и исчерпывающий поиск
forward_vec = MAnalyse(super, overlap=4, isb = false, search=3)
MFlowFps(super, backward_vec, forward_vec, num=2*FramerateNumerator(), \
   den=FramerateDenominator())
</pre>

<p>Чтобы генерировать приятное размытие движения с MFlowBlur:</p>
<pre>AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
super = MSuper()
backward_vectors = super.MAnalyse(isb = true)
forward_vectors = super.MAnalyse(isb = false)
MFlowBlur(super, backward_vectors, forward_vectors, blur=15)
</pre>

<p>Понижение шума с некоторым внешним фильтром (который использует три кадра: предыдущий, текущий, следующий):</p>
<pre>AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
super = MSuper()
backward_vectors = MAnalyse(super, isb = true)
forward_vectors = MAnalyse(super, isb = false)
forward_compensation = MFlow(super, forward_vectors, thSCD1=500) # или используйте MCompensate
backward_compensation = MFlow(super, backward_vectors, thSCD1=500) # или используйте MCompensate
# создадим чередующиеся трех-кадровые последовательности
interleave(forward_compensation, source, backward_compensation)

DeGrainMedian() # поместите  предпочитаемый Вами временной (пространственно-временной) фильтр здесь

selectevery(3,1) # возвращает фильтрованные только центральные (не компенсированные) кадры
</pre>

<p>Чтобы использовать предварительно отфильтрованный клип для более надежной оценки движения,
но компенсировать движение нефильтрованного клипа (на примере подавления шума):</p>

<pre>AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
super = MSuper()
# Используем некий шумоподавитель (блюр) или стабилизатор яркости для предварительной фильтрации
prefiltered = blur(1.0)
super = MSuper(levels=1) # одного уровня достаточно для MCompensate
superfilt = MSuper(prefiltered) # все уровни для MAnalyse
backward_vectors = MAnalyse(superfilt, isb = true)
forward_vectors = MAnalyse(superfilt, isb = false)
# используем нефильтрованный оригинальный (super) клип для компенсации движения
forward_compensation = MCompensate(super, forward_vectors)
backward_compensation = MCompensate(super, backward_vectors)
# создадим чередующиеся трех-кадровые последовательности
interleave(forward_compensation, last, backward_compensation)

DeGrainMedian() # поместите предпочитаемый Вами временной (пространственно-временной) фильтр здесь

selectevery(3,1) # возвращает фильтрованные только центральные (не компенсированные) кадры
</pre>

<p>Чтобы подавить шум функцией MDegrain2 с перекрывающимися блоками и субпиксельной точностью :</p>
<pre>AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
super = MSuper(pel=2, sharp=1)
backward_vec2 = MAnalyse(super, isb = true, delta = 2, overlap=4)
backward_vec1 = MAnalyse(super, isb = true, delta = 1, overlap=4)
forward_vec1 = MAnalyse(super, isb = false, delta = 1, overlap=4)
forward_vec2 = MAnalyse(super, isb = false, delta = 2, overlap=4)
MDegrain2(super, backward_vec1,forward_vec1,backward_vec2,forward_vec2,thSAD=400)</pre>

<p>Чтобы подавить шум чересстрочного источника функцией MDegrain1 с перекрывающимися блоками и субпиксельной точностью:</p>
<pre>AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
fields=AssumeTFF().SeparateFields() # или AssumeBFF
super = MSuper(fields)
backward_vec2 = MAnalyse(super, isb = true, delta = 2, overlap=2)
forward_vec2 = MAnalyse(super, isb = false, delta = 2, overlap=2)
MDegrain1(fields, super, backward_vec2,forward_vec2,thSAD=400)
Weave()</pre>

<p>Чтобы подавить шум чересстрочного источника функцией функцией MDegrain2i2 :</p>
<pre>function MDegrain2i2(clip source, int "overlap", int "dct")
{
overlap=default(overlap,0) # величина перекрытия (от 0 до 4 для blksize=8)
dct=default(dct,0) # используйте dct=1 для клипов с некоторыми мерцаниями
fields=source.SeparateFields() # разделим на поля
super = fields.MSuper()
backward_vec2 = super.MAnalyse(isb = true, delta = 2, overlap=overlap, dct=dct)
forward_vec2 = super.MAnalyse(isb = false, delta = 2, overlap=overlap, dct=dct)
backward_vec4 = super.MAnalyse(isb = true, delta = 4, overlap=overlap, dct=dct)
forward_vec4 = super.MAnalyse(isb = false, delta = 4, overlap=overlap, dct=dct)
fields.MDegrain2(super, backward_vec2,forward_vec2,backward_vec4,forward_vec4,thSAD=400)
Weave()
}

AVISource("video.avi")
mdegrain2i2(4,0)
</pre>

<p>Как использовать внешний клип субпиксельной интерполяции:</p>
<pre># Загрузим Eedi2 плагин (<a href="http://bengal.missouri.edu/~kes25c/">от tritical</a>) с функцией интерполяции с учетом направлений краев
LoadPlugin("Eedi2.dll")
AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
# создадим увеличенный клип из источника
ups = LanczosResize(2*width(last), 2*height(last), src_left=0.25, src_top=0.25)
super = MSuper(pel=2, pelclip=ups)
bv = MAnalyse(super, isb = true, overlap=4)
MCompensate(super, bv)
</pre>

<p>Как использовать с MT фильтром и специальной <a href="http://forum.doom9.org/showthread.php?t=94996">многопоточной версией AviSynth</a>:</p>
<pre># Загрузим плагин MT от TSP
LoadPlugin("MT.dll")
avisource("some.avi")
MT("""
super = MSuper(pel=2, sharp=1)
backward_vec2 = MAnalyse(isb = true, delta = 2, overlap=4)
backward_vec1 = MAnalyse(isb = true, delta = 1, overlap=4)
forward_vec1 = MAnalyse(isb = false, delta = 1, overlap=4)
forward_vec2 = MAnalyse(isb = false, delta = 2, overlap=4)
MDegrain2(super, backward_vec1,forward_vec1,backward_vec2,forward_vec2,thSAD=400)
""",2) # два потока
</pre>

<p>Замечание: Режим SetMTMode(2) многопоточного AviSynth также поддерживается MVTools с версии 1.8.4.1 (бета тестирование).
MVTools версии 2 должна работать надежнее.
Некоторый пример с SetMTMode:</p>
<pre>SetMTMode(5)
FFmpegSource("some.avi") # avisource не работает с SetMTMode на моих машинах - TSchniede

SetMTMode(2)
super = MSuper(pel=2)
backward_vec2 = MAnalyse(super, isb = true, delta = 2, overlap=4)
backward_vec1 = MAnalyse(super, isb = true, delta = 1, overlap=4)
forward_vec1 = MAnalyse(super, isb = false, delta = 1, overlap=4)
forward_vec2 = MAnalyse(super, isb = false, delta = 2, overlap=4)
MDegrain2(super, backward_vec1,forward_vec1,backward_vec2,forward_vec2,thSAD=400)
</pre>

<p>Как использовать предварительно фильтрованный клип и
пересчитать данные движения для исходного клипа (пример MFlowFPS)</p>
<pre>AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
prefiltered = DeGrainMedian() # некоторое сглаживание
super = MSuper(hpad=16, vpad=16, levels=1) # одного уровня достаточно для MRecalculate
superfilt = MSuper(prefiltered, hpad=16, vpad=16) # все уровни для MAnalyse
backward = MAnalyse(superfilt, isb = true, blksize=16)
forward = MAnalyse(superfilt, isb = false, blksize=16)
# пересчитать для оригинального клипа и другого размера блоков
forward_re = MRecalculate(super, forward, blksize=8, thSAD=100)
backward_re = MRecalculate(super, backward, blksize=8, thSAD=100)
MFlowFps(super, backward_re, forward_re, num=50, den=1)</pre>

<p>Как использовать опцию planar для более быстрой обработки YUY2 (MDegrain3 пример):</p>
<pre>LoadPlugin("SSEToolsS.dll") # для функций преобразования
AVISource("c:\test.avi") # или MPEG2Source, DirectShowSource, некоторый предыдущий фильтр
Interleaved2Planar() # преобразуем клип в планарный
super = MSuper(planar=true)
bv1 = MAnalyse(super, isb = true, delta = 1, overlap=4)
fv1 = MAnalyse(super, isb = false, delta = 1, overlap=4)
bv2 = MAnalyse(super, isb = true, delta = 2, overlap=4)
fv2 = MAnalyse(super, isb = false, delta = 2, overlap=4)
bv3 = MAnalyse(super, isb = true, delta = 3, overlap=4)
fv3 = MAnalyse(super, isb = false, delta = 3, overlap=4)
MDegrain3(super,bv1,fv1,bv2,fv2,bv3,fv3,thSAD=400,planar=true)
Planar2Interleaved() # преобразуем обратно в обычный чередующийся YUY2
</pre>

<h2><a name="disclaimer"></a>IV) Отказ (от гарантий)</h2>
<p>Плагин распространяется на условиях лицензии GNU GPL, без всяких гарантий.
Смотрите 'gpl-rus.txt'.<br>
Документация распространяется на условиях лицензии <a href="http://creativecommons.org/licenses/by-sa/3.0/">CreativeCommons BY-SA 3.0 license.</a><br>
Прошу рассмотреть возможность финансовой <a href="http://avisynth.org.ru/donate-rus.html">поддержки</a>.</p>
<p>MVTools использует части кода из следующих проектов:<br>
Увеличение маски (Resizer) (SimpleResize.cpp) из плагина SimpleResize для Avisynth от Tom Barry. http://www.trbarry.com<br>
Быстрое DCT (fdct_mmx.asm) из XVID MPEG-4 VIDEO CODEC. http://www.xvid.org<br>
DCT общее преобразование (смотри fftwlite.h) из библиотеки FFTW (как вызов DLL). http://www.fftw.org<br>
SATD (pixel-32.asm, pixel.asm) и альтернативная SADx264 (sad-a.asm, x86inc.asm, x86inc-32.asm, cpu-32.asm) из проекта x264. http://www.videolan.org/developers/x264.html
(Loren Merritt, Laurent Aimar, Alex Izvorski et al).
</p>

<h2><a name="revisions"></a>V) Ревизии </h2>
<p>2.5.11.22 (26.04.2016 by Fizick)</p>
<ul>
<li>MflowXXX: выравнивание для исключения странной ошибки для некоторых нечетных размеров кадра и pel=1.</li>
</ul>
<p>2.5.11.21 (22.04.2016 by Fizick)</p>
<ul>
<li>MflowXXX: снято ограничение на длину векторов движения (было до 127/pel).</li>
<li>MMask: возможно масштабирование для kind=3,4,5.</li>
</ul>
<p>2.5.11.20 (02.04.2016 by Fizick)</p>
<ul>
<li>Исправил Mflow, сломанную в 2.5.11.2, исправил несколько мелких ошибок.</li>
<li>MBlockFps: добавил поддержку перекрытия блоков, переименовал параметр thres в ml.</li>
<li>MCompensate, MMask: добавил частичную компенсацию по времени.</li>
<li>Функции масок: улучшил маску разрывности.</li>
<li>MBlockFPS, MMask - добавил опцию использовать SAD вместо маски разрвыности.</li>
<li>Документировал (вслед за Firesledge) отрицательные значения delta 
(вер.2.2.1 быстрый хак для компенсации движенния и слежения в статичных сценах) и исправил некоторые функции соответственно.</li>
</ul>
<p>2.5.11.3 (19.09.2011 by Fizick)</p>
<ul>
<li>MFlowInter: исправлен planar.</li>
<li>MCompensate: исправлен деструктор для recursion.</li>
</ul>
<p>2.5.11.2 beta (20.03.2011 by Fizick)</p>
<ul>
<li>MCompensate: исправлен крах со слишком малыми npad, vpad (спасибо '-Vit-').
</li>
</ul>
<p>2.5.11.1 beta (22.12.2010 by Fizick)</p>
<ul>
<li>MAnalyse, MRecalculate: исправил чисто Горизонтальный и Вертикальный типы поиска (поправка от 'cretindesalpes').
</li>
</ul>
<p>2.5.11 beta (17.10.2010 by Fizick)</p>
<ul>
<li>MAnalyse, MRecalculate: добавил чисто Горизонтальный и Вертикальный типы поиска (просил 'Null Null').
</li>
<li>MRecalculate: исправил Hexagon и UMH типы поиска (обрабатывались как Logarithmic).
</li>
</ul>
<p>2.5.10.1 beta (25.06.2010 by Fizick)</p>
<ul>
<li>MFlowInter: Исправлена некорректная передача последних параметров (blend, etc).
Спасибо Laurent de Soras 'Firesledge'.
Другие интересные обновления его модификации MVTools v2.5.10 beta mod16b
(http://ldesoras.free.fr/src/dither-avsi-1.2.zip) рассматриваются.
</li>
<li>MDepan: исправлена ошибка: если range=1 в MDepan, то отладочный текст (с info=true)
отображался толлько для первого кадра при загрузке скрипта.
Спасибо Boulder за сообщение.
</li>
<li>MRecalculate: исправлена ошибка при отличающихся значениях pel. Спасибо Boulder за сообщеие.</li>
</ul>
<p>2.5.10 beta (8.11.2009 by Fizick)</p>
<ul>
<li>MAnalyse: trymany - пробовать искать вокруг многих предикторов</li>
<li>MAnalyse: заменил третий правый верхний предиктор на правый нижний</li>
<li>MAnalyse: исчерпывающий тип поиска на всех грубых уровнях всегда, удалил параметр <var>full</var></li>
</ul>
<p>2.5.9 (4.11.2009 by Fizick)</p>
<ul>
<li>MAnalyse: восстановил lambda для самого грубого уровня</li>
<li>MAnalyse: исправил full=0 по умолчанию согласно документации</li>
</ul>
<p>2.5.8.1 (26.10.2009 by Fizick)</p>
<ul>
<li>MDegrain2: исправлен limitC (спасибо Terranigma за доклад)</li>
</ul>
<p>2.5.8 (18.10.2009 by Fizick)</p>
<ul>
<li>MAnalyse: исправлены некоторые неверные векторы (спасибо shon26 за доклад)</li>
</ul>
<p>2.5.7 (09.10.2009 by Fizick)</p>
<ul>
<li>MAnalyse: исправлена ошибка (крах для некоторых размеров кадра) (спасибо Mark за доклад)</li>
</ul>
<p>2.5.6 (08.10.2009 by Fizick)</p>
<ul>
<li>MAnalyse: исправлена ошибка (крах для pad>0 и некоторых размеров кадра) с levels (спасибо Mark за доклад)</li>
</ul>
<p>2.5.5 (28.09.2009 by Fizick)</p>
<ul>
<li>MAnalyse: исправлена ошибка (крах для hpad=0) с levels (спасибо Boulder и LaTo за доклад)</li>
<li>MSuper: уточнена интерполяция на краях плоскостей</li>
<li>MDegrain1,2,3: добавил параметр limitC</li>
</ul>
<p>2.5.4 (27.09.2009 by Fizick)</p>
<ul>
<li>MAnalyse: установил по умолчанию temporal=false в соответствии с документацией
(о проблемах с SetMTMode(2) сообщил MAG79)</li>
</ul>
<p>2.5.3 (08.09.2009 by Fizick)</p>
<ul>
<li>MAnalyse: добавил темпоральный предиктор вектора движения</li>
<li>MRecalculate: исправил несправную версию 2.5.2</li>
</ul>
<p>2.5.2 (11.08.2009 by Fizick)</p>
<ul>
<li>MSuper: последовательное по ширине и высоте редуцирование с ассемблерной iSSE оптимизацией</li>
<li>MAnalyse: ограничено число уровней</li>
</ul>
<p>2.5.1 (07.08.2009 by Fizick)</p>
<ul>
<li>MAnalyse: Добавил параметр <var>meander</var> для просмотра рядов блоков попеременно слева направо и справа налево</li>
<li>Небольшая оптимизация функций преобразования YUY2</li>
</ul>
<p>2.5.0 (01.08.2009 by Fizick)</p>
<ul>
<li>MSuper: Более полный размер подуровней</li>
<li>MAnalyse: Увеличил число подуровней (для более длинных векторов)</li>
<li>MAnalyse: Заменил имя параметра <var>level</var> на <var>levels</var>, изменил обработку его положительных и отрицательных величин</li>
<li>MAnalyse:Отменил <var>lambda</var> для самого грубого уровня</li>
<li>MAnalyse: Полный поиск с большим радиусом для самого грубого уровня</li>
</ul>
<p>2.4.7 (28.07.2009 by Fizick)</p>
<ul>
<li>MBlockFPS: Окончательно исправил ошибку для ненулевых дополнений кадра, нецелого числа блоков</li>
</ul>
<p>2.4.6 (26.07.2009 by Fizick)</p>
<ul>
<li>MBlockFPS: Исправил ошибку (справа и внизу, сообщил Shon26) для ненулевых дополнений кадра, нецелого числа блоков</li>
<li>Исправил возможные ошибки с интерполяцией пикселов для низких подуровней иерархии</li>
<li>Более корректный размер подуровней (четная люма для YV12)</li>
<li>MShow: изменил ститль рисования векторов на градиентный</li>
</ul>
<p>2.4.5 (11.07.2009 by Fizick)</p>
<ul>
<li>Добавил размер блока 32x32</li>
<li>Заменил avisynth.h на версию 2.5.8MT от SEt</li>
</ul>
<p>2.4.4 (08.07.2009 by Fizick)</p>
<ul>
<li>Включил все модификации кода от SEt, но:</li>
<li>Заменил avisynth.h с версии 2.5.5 на версию 2.5.8</li>
</ul>
<p>2.4.2_mod2 (30.06.2009 by Pavel Skakov aka SEt)</p>
<ul>
<li>Исправил проблемы потоков, небольшие оптимизации
(avisynth.h от avisynth2.5.8MT бета, инициирование векторов как 0)</li>
</ul>
<p>2.4.2_mod (22.06.2009 by Pavel Skakov aka SEt)</p>
<ul>
<li>Некоторая очистка исходников, проекта, и оптимизация главным образом MDegrain1/2/3 -
в зависимости от ваших установок вы вероятно увидите ускорение 2-15%, результаты с точностью до бита идентичны оригинальной версии 2.4.2:</li>
<li>добавлена Average2 iSSE версия для pel=4,</li>
<li>Degrain1/2/3 MMX и SSE2 версии,</li>
<li>небольшая оптимизация copy8x8 MMX и Horizontal_Wiener SSE,</li>
<li>поправлено детектирование cpu</li>
</ul>
<p>2.4.3 beta (26.04.2009 by Fizick)</p>
<ul>
<li>MDepan: добавил параметры mask (как просил djonline) и planar.</li>
</ul>
<p>2.4.2 (07.04.2009 by Fizick)</p>
<ul>
<li>MAnalyse: Исправил допустимый диапазон векторов для случая бордюров меньших чем размер блока, с крахом программы (спасибо FuPP за доклад об ошибке).</li>
</ul>
<p>2.4.1 beta (24.01.2009 by Fizick)</p>
<ul>
<li>MDegrain: Исправил вес для высоких порогов и больших размеров блоков.</li>
</ul>
<p>2.4.0 beta (09.01.2009 by Fizick)</p>
<ul>
<li>MDegrain: изменил метод взвешивания degrain на более сильный, некоторые внутренние переписывания.</li>
<li>Исправлена документация.</li>
</ul>
<p>2.3.1 (14.12.2008 by Fizick)</p>
<ul>
<li>MSuper: добавил более сглаживающие сокращающие (деление пополам) фильтры rfilter=2,3,4, по умолчанию 2.</li>
<li>MAnalyse: исправил ошибку параметра plevel (версии 2.3.0).</li>
</ul>
<p>2.3.0 (06.12.2008 by Fizick)</p>
<ul>
<li>Переименовал все функции из MVxxx в Mxxx (некоторое переименование запросили LaTo, Mystery Keeper, Sagekilla).
Сообщения об ошибках пока не обновлены.</li>
<li>MAnalyse: добавил параметр pglobal (и небольшие изменения), изменил level=1 по умолчанию.</li>
</ul>
<p>2.2.2 (30.11.2008 by Fizick)</p>
<ul>
<li>MVCompensate: исправил ошибку на сменах сцены (спасибо AVIL за сообщение об ошибке YUY2).</li>
<li>MVShow: изменил SAD на приведенный к блоку 8x8, добавил показ количества плохих векторов.</li>
<li>MVAnalyse: исправлена chroma=false (спасибо LaTo за сообщение).</li>
<li>Переименована в mvtools2.dll (по запросу Naito).</li>
</ul>
<p>2.2.1 (27.11.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: исправил неверное приведение LSAD к размеру блоков (спасибо Shon за сообщение).</li>
<li>MVCompensate: убрал параметр mode, добавил recursion.</li>
</ul>
<p>2.1.2 (23.11.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: удалил опцию mc. Сократил размер данных блока (и увеличил версию потока векторов).</li>
<li>MVDegrain: исправил ошибку с блоками 32x16.</li>
</ul>
<p>2.1.1 (18.11.2008 by Fizick)</p>
<ul>
<li>MVBlockFps: Исправил ошибку левого края</li>
</ul>
<p>2.1.0 (8.11.2008 by Fizick)</p>
<ul>
<li>MVFlowFps, MVBlockFps, MVFlowInter: добавил параметр blend для замены смешивания кадров на смене сцены на повтор.</li>
<li>MVFlowFps, MVBlockFps: более безопасные для больших числителей и знаменателей частоты.</li>
</ul>
<p>2.0.11.2 (6.11.2008 by Fizick)</p>
<ul>
<li>MVDegrain2,3: исправил аварии на сменах сцен.</li>
</ul>
<p>2.0.11.1 (5.11.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: добавил повторный широкий поиск для плохих блоков (параметры badSAD, badrange).</li>
<li>MVAnalyse: добавил типы поиска Hexagon и Uneven Multi Hexagon (UMH).
Изменил (непреднамеренно :) метод по умолчанию с Logarithmic на Hexagon.</li>
<li>MVAnalyse: исправил исчерпывающий поиск от статического центра.</li>
<li>MVAnalyse: lsad теперь масштабируется к блоку 8х8.</li>
<li>MVShow: использует суперклип, дополненный бордюром выход, добавил опцию номера блока number.</li>
</ul>
<p>2.0.9.2 (3.11.2008 by Fizick)</p>
<ul>
<li>Некоторое улучшение производительности</li>
</ul>
<p>2.0.9.1 (20.10.2008 by Fizick)</p>
<ul>
<li>Более оптимальные по памяти функции MVFlowXXX для pel=1</li>
<li>Отменил отладочный режим плагина</li>
<li>Добавил русскую документацию для версии 2</li>
</ul>
<p>2.0.9.0 альфа (13.10.2008 by Fizick)</p>
<ul>
<li>Реализовал больше функций без idx: MVSCDetection, MVDepan, MVFlowInter, MVBlockFps, MVFlowBlur, MVDegrain3, MVRecalculate</li>
<li>Исправил аварию с MVSuper(chroma=false)</li>
<li>Некоторые небольшие изменения и фиксы для v2.0, конечно :)</li>
<li>Документация (английская) для v2.0</li>
</ul>
<p>2.0.7.0 альфа (02.10.2008 by Fizick)</p>
<ul>
<li>Реализовал функции без idx: MVSuper, MVAnalyse, MVFlowFps, MVFlow,
MVCompensate, MVShow, MVMask, MVDegrain1, MVDegrain2</li>
<li>Все функции (кроме MVAnalyse) получили параметр planar для YUY2 планарного ввода и вывода.
По умолчанию = false (то есть обычный чередующийся формат YUY2), медленнее.</li>
<li>Все (обязательные) клиповые параметры потеряли свои имена, и mvbw=vb теперь является некорректным синтаксисом.
Используйте неименованный синтаксис. </li>
</ul>
<p>2.0.0.3 альфа (28.09.2008 by Fizick)</p>
<ul>
<li>Первая публичная альфа ветви 2.0 с функцией MVSuper, чтобы убить idx.</li>
<li>Пока реализованы только новые MVAnalyse и MVDegrain1.</li>
</ul>

<p>1.11.4.4 (15.10.2008 by Fizick)</p>
<ul>
<li>Восстановил старый размер приращения внутреннего кэша как перед версией v1.11.4.2 (есть сообщения о авариях).</li>
</ul>
<p>1.11.4.3 (08.10.2008 by Fizick)</p>
<ul>
<li>MVDenoise: исправил ошибку v.1.11.4 с коррекцией яркости.</li>
<li>MVCompensate: устранил потенциальную утечку памяти (в конструкторе).</li>
</ul>
<p>1.11.4.2 (26.09.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: сократил неиспользуемое компенсацией пространство памяти из клипа векторов (параметр mc).</li>
<li>Уменьшил рост внутреннего кэша.</li>
<li>Все MVFlow функции: исправлена старая ошибка с пикселами для pel=4.</li>
<li>MVAnalyse: добавил параметр rfilter (сглаживающий метод)</li>
<li>MVBlockFps: добавил поддержку YUY2 и pelclip.</li>
<li>Маленькие изменения для стабильности с MT.</li>
</ul>
<p>1.11.0.1 beta (08.09.2008 by Fizick)</p>
<ul>
<li>Новая MVBlockFps для простого поблочного изменения fps (почти в реальном времени :-).</li>
<li>MVAnalyse: более сглаживающий метод сокращения иерархических уровней кадра (подобно ReduceBy2) для сглаживания на каждом уровне.</li>
<li>MVAnalyse: добавил параметр pzero стоимости нулевого вектора для более согласованных векторов движения
(теперь включено по умолчанию, установите в 0, если вам нужен старый алгоритм).</li>
<li>MVAnalyse: понизил внутреннее ограничение снизу pelsearch с pel до 1 (кто-то просил для скорости в ущерб точности).</li>
<li>MVFlowFps,MVFlowFps2, MVFlowInter: удалил параметр thSAD.</li>
<li>Все функции: удалил параметр mmx.</li>
</ul>
<p>1.10.2.1 (28.08.2008 jn Fizick)</p>
<ul>
<li>MVDegrain1-3: исправил старую ошибку округления, приводящую к некоторому изменению цвета
(некоторая благодарность Didee за сообщение, хотя оно могло бы быть более настойчивое и в официальной ветке форума по MVTools :).</li>
<li>Уточнил (надеюсь) документацию о pelclip.</li>
</ul>
<p>1.10.2.0 публичная beta (27.08.2008 от Fizick)</p>
<ul>
<li>Отладил и переименовал MVRefine обратно в MVRecalculate :).</li>
<li>MVAnalyse: изменил порог LSAD с резкого на плавный для немного более согласованного движения в плохих областях.</li>
<li>MVAnalyse: исправил старую ошибку для (редко используемого случая) различных величин
горизонтального и вертикального перекрытия блоков.</li>
</ul>
<p>1.10.1.0 не публичная (22.08.2008 by Fizick)</p>
<ul>
<li>Заменил MVRecalculate более общей функцией MVRefine, которая может уточнять вектора.</li>
</ul>
<p>1.10.0.0 не публичная (18.08.2008 от Fizick)</p>
<ul>
<li>Добавлена функция MVRecalculate для пересчета SAD (как просил Didee).</li>
<li>Исправлены возможные утечки памяти (спасибо josey_wells за замечание)</li>
<li>Другие изменения ветви v.1.9.6.x от josey_wells пока не включены -
 слишком много работы для анализа нового кода и многочисленных косметических переписываний,
  то есть основана на 1.9.5.7</li>
</ul>
<p>1.9.6.x-1.9.7.x ветвь (01.08.2008-26.08.2008 от josey_wells)</p>
<ul>
<li>Добавлены MVAnalyseMulti, MVDegrain, MVMultiExtract функции с внутренней многопоточностью
(которая не требует специального AviSynth, SetMTMode или MT) </li>
<li>Некоторые исправления ошибок (утечки памяти), объединение кода (переписывание)
 для улучшений стабильности и производительности.
Также есть многочисленные изменения из-за добавления класса потоков, семафора, критической секции,
файлов потоков, для MVDegrain, MVAnalyseMulti, а также вынесение общего кода
MVDegrain в отдельный базовый класс, перемещение общего кода и т.д.
Нет изменений алгоритмов.
Смотри <a href="http://forum.doom9.org/showthread.php?t=84770">сообщения форума</a>
 после августа 2008 для загрузки, синтаксиса и обсуждения.</li>
</ul>
<p>1.9.5.7 публичная бета (03.07.2008 от Fizick)</p>
<ul>
<li>Исправил Overlap_2xY_mmx</li>
<li>Добавил (неполный?) список используемых проектов к документации.</li>
</ul>
<p>1.9.5.6 (02.07.2008 от TSchniede)</p>
<ul>
<li>Улучшил Overlap_2xY_mmx, оптимизировал CheckMV2 и LumaSAD.</li>
</ul>
<p>1.9.5.5 (28.06.2008 от TSchniede)</p>
<ul>
<li>Улучшил по умолчанию 2xY SAD и добавил более быстрый 2xY SAD.</li>
</ul>
<p>1.9.5.4 (27.06.2008 by TSchniede)</p>
<ul>
<li>Перенес код авто-детектирования процессора из x264.</li>
<li>Теперь используется x264 SAD автодетектирование по умолчанию</li>
<li>Слил с 1.9.5.1, вновь разрешил режим 32x16 (только для функций не x264)</li>
</ul>
<p>1.9.5.3 (26.06.2008 by TSchniede)</p>
<ul>
<li>Импортировал функции SSD & SATD.</li>
<li>доступ к ним используя sadx264 > 7 или dct > 4.</li>
</ul>
<p>1.9.5.2 (24.06.2008 by TSchniede)</p>
<ul>
<li>Буферировал блок источника в выровненной области перед вычисленем SAD.
Это исправляет крахи если блок источника был невыровнен, из-за overlaped блоков.
В худшем случае это на 1% медленнее, по большей части это увеличивает производительность.</li>
</ul>
<p>1.9.5.1 public beta (21.06.2008 by Fizick)</p>
<ul>
<li>Включил изменения версии v.1.9.5 от TSchniede.</li>
</ul>
<p>1.9.5 (21.06.2008 by TSchniede), основана на v.1.9.3</p>
<ul>
<li>MVAnalyse: добавил опцию sadx264.</li>
<li>Внутренние модификации - выровнена память плоскостей яркости и цветности, и
 модифицирована MVTools для интерфейса SAD функций, используемых в x264.</li>
<li>незначительные исправления (деактивировал DebugPrint возможные проблемы)</li>
</ul>
<p>1.9.4.1 beta (12.06.2008 от Fiziick, выпущена 21.06.2008)</p>
<ul>
<li>Исправлено для pel=4 с sharp=2 (спасибо Pustovetov за сообщение и поправку).</li>
<li>MVCompensate: добавлен размер блока 16x2 (сообщение AVIL).</li>
</ul>
<p>1.9.4 бета (08.06.2008 от Fizick)</p>
<ul>
<li>MVAnalyse и др.: добавил размер блока 32x16 (запрос MAG79).</li>
</ul>
<p>1.9.3.1 (05.06.2008 от Fizick)</p>
<ul>
<li>MVIncrease: была неработоспособна (спасибо MAG79 за выявление).</li>
</ul>
<p>1.9.3 (20.04.2008 от Fizick)</p>
<ul>
<li>MVAnalyse: Исправлена ошибка для pelclip (глюк с версии 1.8.5).</li>
<li>MVDegrain: добавил thSADC как порог для цветности (запрос Terranigma).</li>
</ul>
<p>1.9.2 (29.01.2008 от Fizick, но все ошибки были найдены josey_wells)</p>
<ul>
<li>MVDegrain3: исправлена ошибка в коде для блока 16x8; исправлена опечатка (MVDegrain2 вместо MVDegrain3) в сообщениях.</li>
<li>MVAnalyse: исправлена старая ошибка в NStepSearch.</li>
</ul>
<p>1.9.1 бета (15.12.2007 от Fizick)</p>
<ul>
<li>MVAnalyse: увеличил скорость (на 20%) оценки глобального движения (другой метод).</li>
<li>MVAnalyse: добавил ассемблерную оптимизацию для SAD малых блоков (скорость на 50%).</li>
<li>MVMask: Добавил kind=5 цветную карту движения как x,y компоненты векторов,
 показанные на цветовых плоскостях U, V.</li>
</ul>
<p>1.9.0 (04.12.2007 от Fizick)</p>
<ul>
<li>Добавил MVDegrain3.</li>
</ul>
<p>1.8.6 (02.12.2007 от Fizick)</p>
<ul>
<li>Добавил маски составляющих x,y векторов движения к MVMask (как просил Terka).</li>
</ul>
<p>1.8.5.1 (12.11.2007 от нас:)</p>
<ul>
<li>Слил изменения v1.8.4.3 и v1.8.5, добавил пример MT.</li>
</ul>
<p>1.8.4.3 (05.10.2007 by Tsp)</p>
<ul>
<li>Реализовал детектирование пропусков внутреннего кэш-буфера с ростом буфера (как предложил IanB).</li>
</ul>
<p>1.8.5 (05.11.2007 by Fizick)</p>
<ul>
<li>Добавил параметр pelsearch как параметр поиска (радиус) на самом тонком уровне (просил Terranigma).</li>
<li>Уменьшил внутренний буфер для уменьшения используемой памяти, немного изменены критические секции.</li>
<li>Добавил блоки 16x2 (просил ab_99).</li>
</ul>
<p>1.8.4.2 (25.10.2007 by Tsp)</p>
<ul>
<li>Добавлена критическая секция в интерполяции кадров для исправления редкой ошибки при многопоточной обработке.</li>
</ul>
<p>1.8.4.1 (23.10.2007 by Tsp)</p>
<ul>
<li>Реализован безопасный к потокам доступ к внутреннему буферу
для корректной многопоточной обработки с SetMTmode(2) в версии Avisynth MT (для многоядерных процессоров).</li>
</ul>
<p>1.8.4 (22.08.2007 by Fizick)</p>
<ul>
<li>divide теперь работает вместе с overlap.</li>
</ul>
<p>1.8.3 (17-20.08.2007 by Fizick)</p>
<ul>
<li>MVFlowFps: переименовал параметр "mode" в "mask", mask=2 по умолчанию.</li>
<li>MVFlowFps2: добавил параметр "mask".</li>
<li>MVFlowFPS, MVFlowFPS2: Восстановил значения по умолчанию num=25, den=1 (как было в версиях 1.7 и ранее)</li>
<li>MVDegrain1, MVGegrain2 - добавил параметр "limit".</li>
</ul>
<p>1.8.2 beta (30.07.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: исправил (увеличил) радиус поиска на самом детальном уровне для pel>1.</li>
<li>Добавил возможность pel=4 для четверть-пиксельной точности.</li>
<li>Переименовал параметр "clip2x" в "pelclip".</li>
</ul>
<p>1.8.1 beta (28.06.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: добавил пост-обработку векторов движения путем деления блоков на подблоки
для снижения размера зоны интерполяции векторов движения.</li>
<li>MVFlowFps: добавлен параметр "mode" для выбора метода обработки в разрыных областях (и скорости).</li>
<li>Некоторые внутренние изменения (padding в MVAnalysisData, заголовок к кадрам векторных потоков и др.).</li>
</ul>
<p>1.8.0 beta (22.06.2007 by Fizick)</p>
<ul>
<li>MVFlowInter, MVFlowFPS, MVFlowFPS2, MVMask: улучшил маску разрывности по протяженности</li>
<li>MVFlowInter, MVFlowFPS, MVFlowFPS2: уменьшил ореолы объектов в областях разрывности использованием векторов движения смежных кадров</li>
<li>MVFlowInter, MVFlowFPS, MVFlowFPS2: отменил маску SAD и параметр thSAD</li>
<li>MVFlowFPS, MVFlowFPS2: изменил значение выходного fps на удвоенное от входного (num, den = 0)</li>
<li>MVShow: исправил показываемое положение векторов</li>
<li>Добавил сообщения об ошибке при пропущенных векторных клипах</li>
</ul>
<p>1.7.0 beta (05.06.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: добавил параметры blksizeV и overlapV для неквадратных блоков 8x4 и 16x8.</li>
</ul>
<p>1.6.4 (30.05.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: изменил порядок векторов для Исчерпывающего поиска (расширяющиеся квадраты).</li>
<li>MVAnalyse: исправил ошибку с dct=3.</li>
<li>MVFlowFps, MVFlowFPS2, MVFlowInter: теперь смешивают кадры с плохой оценкой движения (на сменах сцен, вспышках).</li>
<li>MVFlowFps, MVFlowFPS2: исправил ошибку с параметром thSAD (и соответтствующей маской).</li>
</ul>
<p>1.6.3 (06.05.2007 by Fizick)</p>
<ul>
<li>MVDepan: больше совместимости с DepanEstimate (параметр range и т.д.).</li>
</ul>
<p>1.6.2 (11.11.2006 by Fizick)</p>
<ul>
<li>MVAnalyse: изменил режим DCT=2 на зависящий от глобальной яркости.</li>
</ul>
<p>1.6.1 beta (25.10.2006 by Fizick)</p>
<ul>
<li>MVAnalyse: добавил экспериментальный режим DCT, чтобы улучшить оценку движения при мерцаниях и затуханиях яркости (быстрый только для blksize=8).</li>
</ul>
<p>1.5.8 beta (14.10.2006 by Fizick)</p>
<ul>
<li>Многие функции: добавил параметр <var>clip2x</var> для использования 2X увеличенного клипа вместо внутренней субпиксельной интерполяции для pel=2</li>
<li>MVFlowFps, MVFlowFps2: добавил параметр <var>thSAD</var>; используем локальное смешение пикселов соседних кадров
 в областях с плохими векторами движения</li>
<li>MVFlowFps, MVFlowFps2: могут использовать вектора движения для произвольного расстояния между кадрами <var>delta</var></li>
<li>MVFlowFps, MVFlowFps2: исправил ошибку видео с большими делимыми и делителями (спасибо Trixter за доклад)</li>
<li>MVCompensate: добавил экспериментальный параметр <var>fields</var>
 чтобы компенсировать вертикальное смещение полей основанного на полях видео для pel=2</li>
<li>MVAnalyse: изменил параметр pnew на относительный к величине SAD</li>
</ul>
<p>1.5.3 beta (01.10.2006 by Fizick)</p>
<ul>
<li>MVAnalyse: улучшил оценку нулевого движения для разделенного на поля видео для pel=2</li>
<li>Временно вернул MVIncrease, MVChangeCompensation, MVDenoise (с хранением компенсации в клипе векторов)</li>
<li>Присоединил v1.4.12-1.4.13 изменения</li>
</ul>
<p>1.5.1 beta (05.09.2006 by Fizick)</p>
<ul>
<li>Присоединил v1.4.11 изменения</li>
</ul>
<p>1.5.0 beta (23.08.2006 by Fizick)</p>
<ul>
<li>Скорректировал интерполяцию предикторов векторов (от грубой к тонкой шкале) для overlap>0.</li>
<li>MVFlowInter: добавил параметр thSAD.</li>
<li>MVFlowInter: локальное смешивание пикселов соседних кадров
 в регионах с плохими векторами движения.</li>
<li>Удалил хранение компенсации в клипе векторов.</li>
<li>Удалил функции MVIncrease, MVChangeCompensation, MVDenoise
(она использовала компенсацию в клипе векторов, и не поддерживала перекрытие).</li>
<li>Удалил режим петли mode=2 MVCompensation, режим mode=0 тепрь обрабатывается как mode=1.</li>
<li>Добавил параметр thSAD к MVCompensation для безопасной (фиктивной) компенсации как просил Didee.</li>
</ul>
<p>1.4.13 (28.09.2006 by Fizick)</p>
<ul>
<li>Исправлена ошибка с возможными ошибочными указателями кадров в ядре (MVClip.Update),
маскируемая кэшированием (спасибо IanB за совет)</li>
</ul>
<p>1.4.12 (25.09.2006 by Fizick)</p>
<ul>
<li>Вроде исправлена ошибка с кэшированием кадров в MVDenoise (и возможно в MVDegrain) (спасибо il9ad за доклад)</li>
</ul>
<p>1.4.11 (06.09.2006 by Fizick)</p>
<ul>
<li>Подправил интерполяцию предикторов векторов (от грубого до тонкого масштаба) для overlap>0.</li>
<li>Исправлена ошибка с шириной для overlap=0, YV12 в MVDegrain1 (спасибо Boulder за доклад)</li>
</ul>
<p>1.4.10 (18.08.2006 by Fizick)</p>
<ul>
<li>Подправил обработку правого и нижнего края в MVCompensate для произвольных размеров кадра.</li>
<li>Изменил значения по умолчанию в MVAnalyse: pel=2, truemotion=true, sharp=2.</li>
</ul>
<p>1.4.9 (14.08.2006 by Fizick)</p>
<ul>
<li>Исправил ошибку в MMX оптимизации к режиму перекрытия в MVDeGrain, MVCompensate для YUY2 с blksize=8
 (спасибо TSchniede за доклад).</li>
</ul>
<p>1.4.8 (31.07.2006 by Fizick)</p>
<ul>
<li>Добавил некоторую MMX оптимизацию к режиму перекрытия в MVDeGrain, MVCompensate.</li>
<li>Исправил ошибку с последними (не обрабатываемыми) строками в MVDeGrain.</li>
</ul>
<p>1.4.7 (25.07.2006 by Fizick)</p>
<ul>
<li>Снизил сеточность перекрытия в MVDeGrain1, MVDeGrain2, MVCompensate.</li>
<li>Добавил пример с MVDeGrain1 для чересстоочного</li>
</ul>
<p>1.4.6 (24.07.2006 by Fizick)</p>
<ul>
<li>Снижено шумоподавление в MVDeGrain1, MVDeGrain2.</li>
<li>Параметр plane в MVDeGrain1, MVDeGrain2 теперь работает :)</li>
</ul>
<p>1.4.5 (22.07.2006 by Fizick)</p>
<ul>
<li>Добавлен параметр plane в MVDeGrain1, MVDeGrain2.</li>
</ul>
<p>1.4.4 (19.07.2006 by Fizick)</p>
<ul>
<li>Исправил значение по умолчанию thSAD=400 в MVDeGrain1, MVDeGrain2.</li>
<li>Исправил ошибку с цветовой плоскостью V в MVChangeCompensate.</li>
</ul>
<p>1.4.3 (17.07.2006 by Fizick)</p>
<ul>
<li>Снизил сеточность перекрытия в MVDeGrain1, MVDeGrain2.</li>
</ul>
<p>1.4.2 (16.07.2006 by Fizick)</p>
<ul>
<li>Исправил ошибку доступа к памяти в MVDeGrain1, MVDeGrain2. Спасибо krieger2005 за доклад.</li>
</ul>
<p>1.4.1 (23.06.2006 by Fizick)</p>
<ul>
<li>Изменил режим MVDeGrain1, MVDeGrain2 на взвешивание по SAD.</li>
<li>Изменил thSCD1 по умолчанию с 300 до 400.</li>
</ul>
<p>1.4.0 (19.06.2006 by Fizick)</p>
<ul>
<li>Добавил MVDeGrain1, MVDeGrain2 ограниченные усредняющие шумоподавители.</li>
<li>Исправил масштаб thSAD в MVDenoise.</li>
<li>Исправил документацию о SAD.</li>
</ul>
<p>1.3.1 (11.06.2006 by Fizick)</p>
<ul>
<li>Добавил бикубический метод субпиксельной интерполяции для pel=2 (с iSSE оптимизацией для sharp=1,2).</li>
<li>Ассемблерная SSE оптимизация скорости для метода компенсации с перекрытием блоков.</li>
</ul>
<p>1.3.0 (05.06.2006 by Fizick)</p>
<ul>
<li>Реализовал компенсацию движения перекрывающихся блоков в MVCompensation(mode=1).</li>
<li>Изменил режим по умолчанию на mode=1 в MVCompensation как наиболее универсальный.</li>
<li>Добавил метод резкой субпиксельной интерполяции для pel=2.</li>
<li>Исправил ошибку для blksize=16 с YUY2.</li>
<li>(Список на будущее: ассемблерная SSE оптимизация скорости для новых методов компенсации и интерполяции.)</li>
</ul>
<p>1.2.6 beta (21.05.2006 by Fizick)</p>
<ul>
<li>Добавил опцию выводить данные по векторам движения в лог файл, как просил Endre.</li>
</ul>
<p>1.2.5 (08.05.2006 by Fizick)</p>
<ul>
<li>Снижен вес нулевого вектора, погрешнось итераций в MVDepan</li>
</ul>
<p>1.2.4 (07.04.2006 by Fizick)</p>
<ul>
<li>Исправлена ошибка v.1.2.3 в режиме info в MVDepan</li>
</ul>
<p>1.2.3 (31.03.2006 by Fizick)</p>
<ul>
<li>Реализована обработка разделеного на поля чересстрочного видео в MVDepan;</li>
<li>добавлена опция лог-файла в MVDepan.</li>
</ul>
<p>1.2.2 beta (01.03.2006 by Fizick)</p>
<ul>
<li>Исправлена ошибка сдвига кадра v1.2.1 MMX YUY2 преобразования (спасибо <b>WorBry</b> за сообщение)</li>
</ul>
<p>1.2.1 beta (20.02.2006 by Fizick)</p>
<ul>
<li>Fixed bug of v1.2,</li>
<li>Скорость восстановлена,</li>
<li>MMX YUY2 преобразование (из Avisynth 2.6 функции от sh0dan) </li>
<li>Но режим overlap кажется все еще работает неверно</li>
</ul>
<p>1.2 beta (17.02.2006 by Fizick)</p>
<ul>
<li>YUY2 формат (кроме MVIncrease), без оптимизации </li>
</ul>
<p>1.1.1 (16.02.2006 by Fizick)</p>
<ul>
<li>Удалил фильтры DeBlock и Corrector (не используют вектора движения, будут отдельными плагинами)</li>
<li>Документировал старую функцию MVSCDetection.</li>
<li>Очистил проект от неиспользуемых исходных файлов.</li>
</ul>

<p>1.1 (не публичный выпуск 9.01.2006 by Fizick)</p>
<ul>
<li>Достаточно большая ревизия (бета). Новая опция для оценки движения перекрывающихся блоков в MVAnalyse
для использования в MVFlow, MVFlowInter, MVFlowFps для улучшенной компенсации движения.</li>
<li>Таблицы для интерполяции движения.</li>
<li>Небольшая коррекция величины смещения в MVFlowFps2.</li>
</ul>
<p>1.0.3 (Выпущена 30.12.2005 by Fizick)</p>
<ul>
<li>Исправил ошибку смещения в MVFlowInter, MVFlowFps (введенную в v1.0.2).</li>
</ul>
<p>1.0.2 (Выпущена 28.12.2005 by Fizick)</p>
<ul>
<li>Скорректровал величину смещения в MVFlow (немного).</li>
</ul>
<p>1.0.1 (Выпущена 24.12.2005 by Fizick)</p>
<ul>
<li>Исправил утечку памяти в MVAnalyse с глобальным движением (спасибо <b>AI</b> за доклад).</li>
<li>Удалил пенальти для нулевого вектора-предиктора в MVAnalyse (был введен в v1.0).</li>
<li>Изменил chroma=true по умолчанию в MVAnalyse.</li>
<li>Добавил пример предварительной фильтрации.</li>
</ul>
<p>1.0 (Выпущена 29.11.2005 by Fizick)</p>
<ul>
<li>Восстановил нулевой вектор как предиктор в MVAnalyse.</li>
<li>Изменил масштаб времени блюра в MVFlowBlur (100 это полностью открытый затвор теперь) как просил <b>Mug Funky</b>.</li>
</ul>
<p>0.9.13.3 (Выпущена 27.11.2005 by Fizick)</p>
<ul>
<li>Добавил вектор глобального движения (простой метод) в качестве предиктора в MVAnalyse.</li>
<li>Поиск векторов прекращается (для скорости), если найден хороший предиктор (с SAD &lt; pnew).</li>
<li>Параметр <var>scale</var> в MVShow теперь работает правильно.</li>
<li>Отменил вывод некоторой отладочной и профилирующей инфомации (для увеличения скорости).</li>
<li>Изменил значение по умолчанию <var>prec</var>=1 (было 2) в MVFlowBlur.</li>
</ul>
<p>0.9.13.2 (Выпущена 22.11.2005 by Fizick)</p>
<ul>
<li>Исправил ошибку в MVFlowFps, MVFlowFps2 для нецелых частот.</li>
</ul>
<p>0.9.13.1 (Выпущена 21.11.2005 by Fizick)</p>
<ul>
<li>Исправил ошибку в MVFlowFps, MVFlowFps2, MVFlowInter, MVFlowBlur (введенную в 0.9.13).</li>
<li>Убрал параметр <var>plen</var> из MVAnalyse как бесполезный.</li>
</ul>
<p>0.9.13 (Выпущена 20.11.2005 by Fizick)</p>
<ul>
<li>Добавил <var>truemotion</var> пресет к MVAnalyse.</li>
<li>Добавил экспериментальную MVFlowFps2.</li>
<li>Изменил метод округления при интерполяции вектора во всех MVFLow... функциях.</li>
<li>Немного отредактирована документация, обновлена русская.</li>
</ul>
<p>0.9.12.4 (Выпущена 15.11.2005 by Fizick)</p>
<ul>
<li>Изменил тип параметра <var>ml</var> в MVMask, MVFlowInter, MVFlowFps с int на float.</li>
<li>Добавил проверки диапазона параметров <var>ml, time, blur</var>.</li>
<li>Исправил малую возможную ошибку (emms).</li>
<li>Частично обновил документацию. Но я не уверен, что <b>sh0dan</b> запрашивал <b>имено такое</b> обновление :).
Это все еще не руководство пользователя, а справочник по функциям.</li>
</ul>
<p>0.9.12.3 (Выпущена 14.11.2005 by Fizick)</p>
<ul>
<li>Исправлена ошибка для цветности для ширины не кратной 16 в MVMask (введена в v0.9.11).</li>
<li>Некоторая оптимизация скорости MVFlowFps.</li>
<li>Переустановил размер внутренего буфера кадров в превоначальную величину 10. Пробуйте разные версии.</li>
</ul>
<p>0.9.12.2 (Выпущена 13.11.2005 by Fizick)</p>
<ul>
<li>Добавил экспериментальный точную но медленую функцию MVFlowBlur как запрашивал <b>scharfis_brain</b>.</li>
<li>Временно изменил разиер внутреннего буфера на 5.</li>
</ul>
<p>0.9.12.1 (Выпущена 12.11.2005 by Fizick)</p>
<ul>
<li>Добавил экспериментальную функцию MVFlowFps.</li>
<li>Убрал функцию MVInter.</li>
<li>Временно изменил размер внутреннего буфера кадров с 10 до 3 для снижения использования памяти.
Скорость должна быть протестирована для сложных скриптов.</li>
</ul>
<p>0.9.12 (Выпущена 09.11.2005 by Fizick)</p>
<ul>
<li>Добавлена функция MVFlowInter. Функция MVInter будет удалена из следующего выпуска (она хуже).</li>
<li>Изменил масштаб <var>ml</var> для kind=2 MVMask до более оптимального умолчания.</li>
<li>Исправил небольшую ошибку в Bilinear.asm (странные пикселы у правой границы для pel=2).</li>
</ul>
<p>0.9.11.1 (Выпущена 06.11.2005 by Fizick)</p>
<ul>
<li>Добавил поддержку полу-пикселов pel=2 к MVFlow.</li>
<li>Увеличен максимальный <var>quant</var> с 51 до 60 в DeBlock для очень сильного подавления блочности.</li>
<li>Исправлена документация.</li>
</ul>
<p>0.9.11 (Выпущена 04.11.2005 by Fizick)</p>
<ul>
<li>Улучшена MVMask: Заменен булевый параметр <var>showsad</var> на целый <var>kind</var>,
добавил опцию маски окклюзий, изменил код билинейного масштабирования на более корректный и быстрый SimpleResize.</li>
</ul>
<p>0.9.10.1 (Выпущена 01.11.2005 by Fizick)</p>
<ul>
<li>Исправил ошибку с малым изменением яркости и цветности в MVInter (ошибка округления).</li>
<li>Интерполяция векторов в MVFlow и маски в MVInter теперь корректны (благодаря исправлению ошибки в SimpleResize).</li>
</ul>
<p>0.9.10 (Выпущена 31.10.2005 by Fizick)</p>
<ul>
<li>Добавлены некоторые опции оценки истинного (сглаженного) движения к MVAnalyse</li>
<li>Добавлена функция MVFlow для по-пиксельной компенсации</li>
<li>Добавлена функция MVInter для интерполяции движения (очень экспериментальная).</li>
</ul>
<p>0.9.9.1 (Выпущена 20.01.2005 by Manao)</p>
<ul>
  <li>Больше нет необходимости в stlport_vcxxxx.dll </li>
</ul>
<p>0.9.9</p>
<ul>
  <li>Добавлена функция: Corrector </li>
  <li>Добавлена
функция: MVIncrease </li>
  <li>Возможен новый размер
блока: 16 </li>
  <li>Новый параметр в MVAnalyse : <var>chroma</var></li>
  <li>Изменения в ядре</li>
</ul>
<p>0.9.8.5</p>
<ul>
  <li>MVCompensate изменена: новый параметр idx,
работающий как idx в
MVAnalyse, и позволяющий увеличить скорость при многократной
компенсации тех же кадров. </li>
</ul>
<p>0.9.8.4</p>
<ul>
  <li>Оценка движения (ME) теперь берет в расчет и
цветовую информацию, как просил tsp. </li>
</ul>
<p>0.9.8.3</p>
<ul>
  <li>Добавлена функция Corrector, как просил scharfi. </li>
</ul>
<p>0.9.8.2</p>
<ul>
  <li>Новая функция MVDepan (добавлена Fizick) для
плагина Depan. </li>
</ul>
<p>0.9.8
</p>
<ul>
  <li>Вновь некоторые изменения в синтаксисе фильтров.Сильно изменено
ядро, в основном с целью выигрыша по скорости где возможно. Однако, по
умолчанию выигрыш в скорости не заметен, необходимо корректно
сконфигурировать анализирующий фильтр с помощью параметра "idx" для
выигрыша в скорости (в режиме "pel" = 2). </li>
  <li>Устранены
ошибки в MVDenoise, и цветовом шумоподавлении в
MVDenoise. </li>
  <li>Теперь фильтры, стоящие ниже по
цепочке фильтров, говорят фильтру анализа, если нуждаются в
компенсации, так что вы не должны об этом заботиться на стадии анализа.</li>
</ul>
<p>0.9.7</p>
<ul>
  <li>Вновь многое переписано. Отключены
интерполирующие фильтры (на
время), все другие фильтры работают и предположительно, стабильны.
Слегка изменен синтаксис, и будет меняться до достижения версии 1.0
(если она однажды будет достигнута). Изменения затронули главным
образом <code>MVAnalyse</code>. Новый фильтр:
 <code>MVChangeCompensate</code>. </li>
</ul>
<p>0.9.6.2</p>
<ul>
<li> Исправлена ошибка в параметрах <code>MVMask</code>.</li>
</ul>

<p>0.9.6.1</p>
<ul>
<li>Lot of bugfixes for the existing filters. MVMask, MVShow, MVCompensate, MVDenoise and MVSCDetection, and MVAnalyse should work .
Other may crash unexpectedly.</li>
<li>Now, for the three new filters. Two have nothing to do with motion compensation,
but I didn't want to put them in separate binaries, since they'll mainly be used with filters from this package.
The third one uses vectors, and integrates somehow the two others.</li>
<li>QDeQuant(clip c, int quant, int level) : takes a clip and quantizes it, using an approximation of the H264 DCT.
It filters the three planes ( 4x4 blocks for each of them, so the chroma isn't processed as in H264 ).
It's not exactly the H264 DCT because at q1, it's lossless, and a q51 it's not that bad, but you can raise quant over 51.
Level is the reference level of the picture.
By default it's zero, but it can be set, for example, to 128.
The picture is then treates as if pixels were ranging from -128 to 127, hence avoiding errors around 128.</li>
<li>Deblock(clip c, int quant, int aOffset, int bOffset ) : takes a clip, and deblock it using H264 deblocking,
as if the picture was made only of inter blocks. This time, quant ranges from 0 to 51 as in H264, and has the same impact.
aOffset and bOffset allow to raise / lower the quant when deciding for some internal thresholds.
They are set by default to 0. Be warned that the filter should do nothing at quant &lt; 16, if aOffset and bOffset are both zero.
It's a wanted behavior ( thus it respect the partially the norm ).</li>
<li>EncDenoise(clip c, clip vectors, bool scbehavior, int quant, int aOffset, int bOffset, int thSCD1, int thSCD2) :
it merges Deblock, QDeQuant and MVCompensate, taking from them the name and behavior of their parameters.
It basically does a h264 encode as if all blocks were 8x8 inter blocks.
Reference frame is the previous frame output by the filter ( if it is the correct one, else it's the previous frame of the source ),
mvs are those given by mvanalyse on the source. The reference frame is compensated by the vectors,
then the residual difference is quantized / dequantized and added to the result of the motion compensation.
Finally, the frame is deblocked, and serves as reference for the next one.</li>
</ul>

<p>0.9.5.3</p>
<ul>
<li>Mainly a bugfixe ( several filters were affected by a silly bug , and MVCompensate now do padded motion compensation,
and compensate also the chroma ( though it rounds the vector to odd coordinates to do so )</li>
<li>A new feature, as asked by Fizick, for mvcompensate :
"scbehavior", a boolean set to true by default, will allow you to keep the previous frame over a scenechange if you set it to false.</li>
</ul>

<p>0.9.5.2</p>
<ul>
<li>MVMask has two new parameters : showsad (bool) which allows to build the mask of the SAD values instead of the mask of the vectors' length. Ysc allows you to set the value taken by the mask on scene changes</li>
<li>MVCompensate : behavior modification on scene changes. Now, the current frame is left untouched if a scene change was detected.</li>
<li>New filter : MVSCDetection, with one parameter, Ysc, which works as previously.</li>
<li>MVInterpolate, MVConvertFPS and MVBlur are enabled, but may be buggy ( though I wasn't able to make MVConvertFPS crash )</li>
</ul>

<p>0.9.5</p>
<ul>
  <li>Очень существенно переписано
исполняемое ядро. Вектора теперь
ищутся с точностью от пикселя и выше (в связи с тем, что никакой другой
фильтр, кроме MVShow, еще не может работать с большей точностью).
Механизм поиска сейчас быстрый (что не обязательно подразумевает, что и
фильтры, использующие его информацию тоже быстрые)</li>
  <li>Новый параметр в MVAnalyse : lambda. Смотри документацию выше о
том, как он работает</li>
  <li>MVDenoise работает лучше.</li>
</ul>
<p>0.9.4</p>
<ul>
  <li>Вектора можно сохранять в файле. С этой
целью в фильтре MVAnalyse
добавлен параметр filename="C:\foo.bar". Если файл не существует,
вектора будут сохраняться в нем. Если он существует, то вектора будут
из него читаться. Но обратите внимание:
    <ul>
      <li>Файл для целого фильма будет около 500 MБ</li>
      <li>Сохранение / считывание файла требует в этот момент наличие
прямого доступа к кадрам, потому его можно использовать только во время
кодирования фильма, но не в процессе случайного доступа к его кадрам.</li>
      <li>Прирост скорости не настолько велик, как я надеялся, так как
SAD-ы не могут быть сохранены (это требует слишком много места) и
должны пересчитываться.</li>
    </ul>
  </li>
  <li>Фильтр
MVDenoise теперь работает на 5 кадрах, и его параметры
теперь "thT" и "sadT" (смотрите в документации как они работают). Он
работает весьма приятно (очень хорошо для тяжелого
шумоподавления)</li>
  <li>Порог детектирования смены сцен
слегка изменен. Теперь блок
изменяется, если его SAD больше thSCD1. По умолчанию thSCD1 = 300, и
thSCD2 = 130. Работает хорошо (лучше, чем предыдущий SCD-механизм).</li>
</ul>
<p>0.9.3</p>
<ul>
  <li>Последние чистки в механизме поиска векторов.Теперь должно
работать слегка быстрее</li>
  <li>Больше
параметров поиска, устанавливаемых пользователем, особенно
алгоритм поиска. Смотри документацию </li>
  <li>Обеспечивается
работа клиент / сервер. Теперь сначала
используется MVAnalyse, а потом уже желаемый фильтр. Смотри
документацию и примеры, которые я изменил.</li>
  <li>MVCompensate отделена от MVShow (это более логично). На данный
момент не работает с цветовыми компонентами (поведение аналогично
MVShow в последних версиях)</li>
  <li>Некоторые чистки в MVBlur / MVInterpolate / MVConvertFPS, но
работают они примерно так-же. Теперь MVBlur выполняет размытие в
пределах кадра, а не между текущим и предыдущим кадром.</li>
  <li>Проделано
половина работы для записи векторов в файл. Но
результирующий файл будет больше (около 500 MБ - 1 ГБ, я думаю).</li>
  <li>MVDenoise слегка быстрее (по крайней мере - должен быть)</li>
  <li>Оптимизировано копирование в фильтре, благодаря функциям
копирования AviSynth.</li>
  <li>MVShow может отображать
средний SAD компенсации (с использованием
showsad = true)</li>
</ul>
<p>0.9.2.1</p>
<ul>
  <li>Возвращена функция MVInterpolate.</li>
  <li>MVConvertFPS должна работать и на последних кадрах клипа</li>
</ul>
<p>0.9.2</p>
<ul>
  <li>MVInterpolate больше не существует.</li>
  <li>MVBlur и MVConvertFPS улучшены. Они так же обзавелись новыми
параметрами, смотрите об этом в документации.</li>
  <li>в MVShow возвращен режим компенсации ( MVShow(cm = true) )</li>
</ul>
<p>0.9.1 - 12.05.2004</p>
<ul>
  <li>Первая версия переименованная в MVTools. </li>
</ul>
<p>0.1-0.6 - Выпущена 24.01.2004 - 01.04.2004 by Manao</p>
<ul>
  <li>Первые публичные версии MotionVectors (Motion.dll). </li>
</ul>

<h2><a name="download"></a>VI) Скачать (Download)</h2>

<h3>Последняя версия Fizick: <a href="mvtools-v2.5.11.22.zip">Download MVTools v2.5.11.22</a></h3>
<p>Предыдущая версия: <a href="mvtools-v2.5.11.20.zip">Download MVTools v2.5.11.20</a></p>
<p>Ранняя версия: <a href="mvtools-v2.5.11.3.zip">Download MVTools v2.5.11.3</a></p>

<p>MVTools 2 mod16 dither version by Laurent de Soras 'Firesledge':  
<a href="http://ldesoras.free.fr/prod.html#src_avs">http://ldesoras.free.fr/</a></p>
<p>На форумах вы можете найти и другие 'неофициальные' билды, в том числе 64 битные.</p>

<p>Документация и ссылки для скачивания версий предыдущей ветви 1.X находятся по адресу
<a href="http://avisynth.org.ru/mvtools/mvtools-rus.html">http://avisynth.org.ru/mvtools/mvtools-rus.html</a></p>

<p>Старая версия MVTools v.0.9.9.1 может быть скачена с <a href="http://manao4.free.fr/">сайта Manao</a></p>

<p><kbd>$English Date: 2006/09/17 17:47:05 - более свежие версии пока не на CVS $<br>
Русский перевод версии 0.9.9.1 08.07.2005 Turyst04 <a
 href="mailto:Turyst04@nextmail.ru">Turyst04@nextmail.ru</a><br>
Редакция и дополнения 14.07.2005 Fizick http://bag.hotmail.ru<br>
Подробное введение, добавленные функции и примеры 2005-2016 Fizick http://avisynth.org.ru</kbd></p>
</body>
</html>

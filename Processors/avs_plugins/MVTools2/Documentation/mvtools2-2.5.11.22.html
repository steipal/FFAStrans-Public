<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
<title>MVTools</title>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link rel="stylesheet" type="text/css" href="avisynth.css"/>
</head>
<body>
<h1>MVTools</h1>
<h2>Abstract</h2>
<p>
<b>authors:</b> Manao, Fizick(Alexander Balakhnin), Tsp, TSchniede, SEt
<br><b>version:</b> 2
<br><b>download:</b> <a href="http://avisynth.org.ru/mvtools/mvtools2.html#download">http://avisynth.org.ru/</a> <br>
<b>category:</b>  Misc Plugins<br>
<b>requirements:</b> YV12 or YUY2 Color format<br>
<b>license:</b> GPL
</p>
<hr>
<h2>Table of contents
</h2>
<ul>
  <li><a href="#mvtools">
I) About MVTools</a>
  </li>
  <li><a href="#version2">Ia) About MVTools version 2</a></li>
  <li><a href="#functions">II) Function descriptions</a></li>
  <li><a href="#examples">III) Examples</a></li>
  <li><a href="#disclaimer">IV) Disclaimer (don't skip that part, but we don't
force you to learn it either)</a></li>
  <li><a href="#revisions">V) Revisions</a></li>
  <li><a href="#download">VI) Download</a></li>
</ul>
<h2><a name="MVTools"></a>I) About MVTools
</h2>
<p>MVTools plugin for AviSynth 2.5 is collection of functions
for estimation and compensation of objects motion in video clips.
Motion compensation may be used for strong temporal denoising, advanced framerate conversions,
image restoration and other tasks.
</p>
<p>The plugin contains the motion estimation server-function MAnalyse to find the motion vectors and
 several motion compensation client-functions (MCompensate, MMask and others)
which use these vectors.
</p>
<p>Plugin uses block-matching method of motion estimation (similar methods are used in MPEG2, MPEG4, etc).
At analysis stage plugin divides frames by small blocks and try to find for every block in current frame
the most similar (matching) block in second frame (previous or next).
The relative shift of these blocks is motion vector.
The main measure of block similarity is sum of absolute differences (SAD)
of all pixels of these two blocks compared.
SAD is a value which says how good the motion estimation was.
The output of MAnalyse (server) is special clip with motion vector information in some format.
</p>
<p>At compensation stage the plugin client functions read the motion vectors
and use them to move blocks and form motion compensated frame
(or realize some other full or partial motion compensation or interpolation function).
Every object (block) in this (fully) compensated frame is placed in the same position as this object in current frame.
So, we may (for example) use strong temporal denoising even for quite fast moving objects
without producing annoying artefactes and ghosting
(object's features and edges are coincide if compensation is perfect).
Plugin can create compensated neighbor frames for every current frame,
and denoise it by internal function.
Alternatively, you can use compensated and original frames to create interleaved clip,
denoise it by any external temporal filter,
and select central cleaned original frames for output (see examples).
</p>
<p>Of course, the motion estimation and compensation is not ideal and precise.
In some complex cases (video with fading, ultra-fast motion, or periodic structures)
the motion estimation may be completely wrong, and compensated frame will be blocky and (or) ugly.
Severe difficulty is also due to objects mutual screening (occlusion) or reverse opening.
Complex Avisynth scripts with many motion compensation functions may eat huge amount of memory
and result in very slow processing.
It is not simple but quite advanced plugin. Use it for appropriate cases only, and try tune its parameters.
There are many discussions about motion compensation using at doom9 Avisynth forum.
In particular see <a href="http://forum.doom9.org/showthread.php?t=76041">old MVTools thread</a>,
<a href="http://forum.doom9.org/showthread.php?t=102071">true motion thread</a>,
<a href="http://forum.doom9.org/showthread.php?t=84770">new MVTools thread</a> and some other.
Try read postings in addition to this documentation and ask for support there.
If you really interested in motion estimation and compensation topics,
you can easy find numerous scientific publications (use WWW search).
</p>
<p>Notes: The plugin is still under development. Current version has some limitations.
Only progressive YV12, YUY2 video is supported.
Use color format conversion and try use (smart) bob-deinterlace for interlaced video
(SeparateFields may works too with or without SelectEven/SelectOdd).
Some complex scripts (MVBOB, MCBOB, TempGaussMC) use MVTools for <a href="http://forum.doom9.org/showthread.php?t=84725"> motion compensated deinterlace.</a><br>
Alternatively you can try to use <a href="http://forum.doom9.org/showthread.php?t=101859">Motion plugin</a> by mg262.
</p>

<h2><a name="version2"></a>Ia) About MVTools version 2</h2>

<p>MVTools version 2 is a major internal and external upgrade.
Main goals of MVTools v2.X branch are clarity and stability
(in particular for multithreaded environment with multicore CPU) and of course performance and memory usage improving.</p>
<p>Main mean for goals achievement is removing MVTools internal buffer
with mysterious (for many people) index (idx) and some other internal tricks
(see thread <a href="http://forum.doom9.org/showthread.php?t=131033">MVTools without idx</a>).
To implement this without performance degradance we use normal effective Avisynth cache
and introduce new mandatory preparation stage (before motion estimation by <code>MAnalyse</code>).
At this stage a new function <code>MSuper</code> will get source clip and prepare special "super" clip
with multilevel (hierarchical scaled) frames data
(in previous MVTools versions 0.X-1.X these multilevel datas were prepared, saved and cached internally
with idx as an index of pseudo-clip of these "superframes" ).
The super clip is then used by both <code>MAnalyse</code> function and client motion compensation functions.</p>
<p>Related syntax change: some <code>MAnalyse</code> parameters (pel, sharp) are moved to <code>MSuper</code> function.</p>
<p>Other essential external change is replacing all named clips parameters by unnamed
(mandatory, without double-quotes in description) for normal work of Avisynth implicit "last" clip.</p>
<p>Also faster planar processing for YUY2 is implemented in v2.0.</p>
<p>Since v2.2 MVTools.dll is renamed to MVTools2.dll, and
since v2.3  all functions are renamed from MVxxx to Mxxx (e.g. from MVAnalyse to MAnalyse),
so you can continue to use old MVTools 1.x with your old scripts,
and you are able to use / make new scripts with MvTools 2.x without changing the load dll.</p>
<p>I also have an intention to remove (not implement) some obsolete functions like MVDenoise, MVFlowFps2 (please, vote).</p>
<p>Full list of changes see at <a href="#revisions">Revisions</a> section.</p>
<p>Generally, new MVTools 2.0 should provide similar results as v1.11.4.
Algorithm improvements is planned in v2.1 and later.</p>
<p>Note: v2 currently has alpha (beta?) status (it should be rather stable for processing, but some syntax may be changed).
Welcome for possible bug reports and suggestions (features requests).</p>
<p>Final note: MVTools v1.x branch is not developed and not supported anymore (by Fizick).
</p>

<h2><a name="functions"></a>II) Function descriptions
</h2>

<h3>Common parameters</h3>

<p>Filters that use motion vectors have common parameters. Those are the scene-change
detection thresholds, and the isse mmx flag. They also use one or
several vectors stream, which are produced by <code>MAnalyse</code>.
</p>
<p><var>thSCD1</var> (int): threshold which decides whether a block has changed
between the previous frame and the current one. When a block has changed, it
means that motion estimation for it isn't relevant. It occurs
for example at scene changes. So it is one of the thresholds used to tweak the
scene changes detection engine. Raising it will lower the
number of blocks detected as changed. It may be useful for noisy or flickered video.
The threshold is compared to the SAD
(Sum of Absolute Differences, a value which says how bad the motion estimation was ) value.
For exactly identical blocks we have SAD=0. But real blocks are always different because of objects complex movement
(zoom, rotation, deformation), discrete pixels sampling, and noise.
Suppose we have two compared 8x8 blocks with every pixel different by 5.
It this case SAD will be 8x8x5 = 320 (block will not detected as changed for thSCD1=400).
If you use 4x4 blocks, SAD will be 320/4.
If you use 16x16 blocks, SAD will be 320*4.
Really this parameter is scaled internally in MVTools,
and you must always use reduced to block size 8x8 value.
Default is 400 (since v.1.4.1).
</p>
<p><var>thSCD2</var> (int): threshold which sets how many blocks have to change
for the frame to be considered as a scene change. It is ranged from 0 to 255, 0
meaning 0 %, 255 meaning 100 %. Default is 130 ( which means 51 % ).
</p>
<p><var>isse</var> (int): flag which allows to enable (if set to True)
or disable (if set to False) ISSE, MMX and other CPU optimizations (for debugging).
Default is True. If your processor doesn't support CPU optimizations, it will be
disabled anyway ( and you won't be able to activate them ).</p>
<p><var>planar</var> (bool): flag to use special planar color format for YUY2 clips both for input and output of function.
It uses special trick for storing of frames with planar color data organisation
(separate Y, U, V planes in memory) in normal interleaved YUY2 frames format as a container.
This way we can avoid numerous internal interleaved to planar conversions and increase speed.
You can convert normal interleaved YUY2 source clip to planar format with <code>Interleaved2planar</code> function
from <a href="http://home.pages.at/kassandro/RemoveGrain/">RemoveGrain plugin by kassandro</a>,
and convert final result by <code>Planar2interleaved</code> function.
This special planar YUY2 format is also supported by Removegrain plugin by Kassandro, MaskTools2 plugin by Manao and some others.
This trick will not be needed in Avisynth v2.6 with native support of planar YV16 format.
This paramenter is ignored for YV12 clips. Note: super clip is always planar.
Default is planar=false. </p>

<h3>MSuper</h3>

<p><code>MSuper</code> (<var>clip, int "hpad", int "vpad", int "pel", int "levels", bool "chroma",
int "sharp", int "rfilter", clip "pelclip", bool "isse", bool "planar"</var>)
</p>
<p>Get source clip and prepare special "super" clip with multilevel (hierarchical scaled) frames data.
The super clip is used by both <code>MAnalyse</code> and motion compensation (client) functions.
For storing and transferring its parameters we use audio properties of super clip (specifically, num_audio_samples) as a trick.
So, audio is killed in super clip. That is one of reasons why we additionally use source clip with client functions.
You may have a look to super clip yourself (it has normal format).</p>
<p><var>hpad</var> : it is horizontal padding added to source frame (both left and right).
Small padding is added for more correct motion estimation near frame borders.
(In MVTools before v2.0 the value of padding = block size was always used internally. Now it is not strict but recommended value.) Default=8.
</p>
<p><var>vpad</var> : it is vertical padding added to source frame (both top and bottom). Default=8.
</p>
<p><var>pel</var> : it is the accuracy of the motion estimation.  Value can only be 1, 2 or 4. 1 means a
precision to the pixel. 2 means a precision to half a pixel, 4 means a precision to quarter a pixel,
produced by spatial interpolation (more accurate but slower and not always better due to big level scale step).
Default is 2 since v1.4.10.</p>
<p><var>levels</var> : it is the number of hierarchical levels in super clip frames.
MAnalyse is need in all levels,
but for other client functions single finest level is enough (courser levels are not used).
Default : 0 (auto, all possible levels are produced).
</p>
<p><var>chroma</var> : if set to true, it allows to prepare chroma planes too in superclip. (false - luma only). Default is true.
</p>
<p><var>sharp</var>:  subpixel interpolation method for <var>pel</var>=2,4. <br>
Use 0 for soft interpolation (bilinear), 1 for bicubic interpolation (4 tap Catmull-Rom),
 2 for sharper Wiener interpolation (6 tap, similar to Lanczos).<br>
Default is 2.
</p>
<p><var>rfilter</var>:  hierarchical levels smoothing and reducing (halving) filter.<br/>
0 is simple 4 pixels averaging like unfiltered SimpleResize (old method);<br/>
1 is triangle (shifted) filter like ReduceBy2 for more smoothing (decrease aliasing);<br/>
2 is triangle filter like BilinearResize for even more smoothing;<br/>
3 is quadratic filter for even more smoothing;<br/>
4 is cubic filter like BicubicResize(b=1,c=0) for even more smoothing.<br/>
Default is 2 (since v2.3.1).
You may also try to apply some external filter to superclip or its coarse bottom part (by appropriate crop and overlay).
</p>
<p><var>pelclip</var>: optional upsampled source clip for using instead of internal subpixel interpolation (for pel>1).<br>
Pixels at rows and colunms positions multiple to pel (0,2,4,... for pel=2) (without padding) must be original source pixels,
other pixels must be interpolated.<br>
Example for pel=2: <code>LanczosResize(width*2,height*2,src_left=0.25, src_top=0.25)</code>.
(Recent note: it is true for luma, but is not exactly corresponded to chroma pixels positions of internal MVTools interpolation.
Nevertheless vectors and motion compensation are quite similar for usual clips,
same chroma would be with src_left=0.5 for YUY2 and additionally src_top=0.5 for YV12).<br>
Other useful example is EEDI2 edge-directed resampler.<br>
Default is not defined.
</p>

<h3>MAnalyse</h3>

<p><code>MAnalyse</code> (<var>clip super, int "blksize", int "blksizeV", int "levels", int "search",
int "searchparam", int "pelsearch", bool "isb", int "lambda", bool "chroma", int "delta",
bool "truemotion", int "lsad", int "plevel", bool "global", int "pnew", int "pzero", int "pglobal", int "overlap", int "overlapV",
string "outfile", int "dct", int "divide", int "sadx264", int "badSAD", int "badrange", bool "isse", bool "meander", bool "temporal", bool "trymany"</var>)
</p>
<p>Get prepared multilevel super clip, estimate motion by block-matching method
and produce special output clip with motion vectors data (used by other functions).<br>
Some hierarchical multi-level search methods are implemented (from coarse image scale to finest).
Function uses zero vector and neighbors blocks vectors as a predictors for current block.
Firstly difference (SAD) are estimated for predictors,
then candidate vector changed by some values to some direction,  SAD is estimated, and so on.
The accepted new vector is the vector with minimal SAD value (with some penalty for motion coherence).
</p>
<p><var>super</var> (unnamed) is multilevel super clip prepared by MSuper function.</p>
<p><var>blksize</var> : Size of a block (horizontal). It's either 4, 8, 16 or 32 ( default is 8 ).
Larger blocks are less sensitive to noise, are faster, but also less accurate.</p>
<p><var>blksizeV</var> : vertical size of a block. Default is equal to horizontal size.
Additional options are: 4 for blksize=8, 8 or 2 for blksize=16, 16 for blksize=32.</p>
<p><var>levels</var> : positive value is the number of levels used in the hierarchical
analysis made while searching for motion vectors. <br>
Negative or zero value is the number of coarse levels NOT used in the hierarchical
analysis made while searching for motion vectors.The lower the usually better (vectors with any length can be found). It is
kept variable for study's purposes mostly.
Sometimes <var>levels</var> is useful to prevent large (false) vectors (computer graphics, etc).
Default = 0 since v.2.5 (all levels are used).</p>
<p><var>search, searchparam, pelsearch</var> : <var>search</var> decides the type of search at every level, and
<var>searchparam</var> is an additional parameter (step, radius) for this search,
and <var>pelsearch</var> is the radius parameter at finest (pel) level:
</p>
<ul>
	<li><var>search </var>= 0 : 'OneTimeSearch'. <var>searchparam</var> is the step between
  each vectors tried ( if <var>searchparam</var> is superior to 1, step will be
  progressively refined ).</li>
	<li><var>search </var>= 1 : 'NStepSearch'. N is set by <var>searchparam</var>. It's the
  most well known of the MV search algorithm.</li>
  <li><var>search </var>= 2 : Logarithmic search, also named Diamond Search.
  <var>searchparam</var> is the	initial step search, there again, it is refined
  progressively. </li>
  <li><var>search </var>= 3 : Exhaustive search, <var>searchparam</var> is the radius (square side is 2*radius+1). It is
  slow, but it gives the best results, SAD-wise.</li>
  <li><var>search </var>= 4 : Hexagon search, <var>searchparam</var> is the range. (similar to x264).</li>
  <li><var>search </var>= 5 : Uneven Multi Hexagon (UMH) search, <var>searchparam</var> is the range. (similar to x264).</li>
  <li><var>search </var>= 6 : pure Horizontal exhaustive search, <var>searchparam</var> is the radius (width is 2*radius+1). </li>
  <li><var>search </var>= 7 : pure Vertical exhaustive search, <var>searchparam</var> is the radius (height is 2*radius+1). </li>
</ul>
<p>
Defaults are: <var>search</var>=4, <var>searchparam</var>=2, <var>pelsearch</var>=<var>pel</var>.</p>
<p><var>isb</var> : allows to choose between a forward search (motion from
the previous frame to current one) for <var>isb</var>=false and a backward search (motion from following
frame to the current one) for <var>isb</var>=true (isb stands for "IS Backward",
it is implemented and named exactly as written here, do not ask :-). Default <var>isb</var>=false.</p>
<p><var>chroma</var> : set to true, it allows to take chroma into account when
doing the motion estimation (false - luma only). Default is true.
</p>
<p><var>delta</var> : set the frame interval between the reference frame and the current
frame. By default, it's 1, which means that the motion vectors are searched between the current frame
and the previous ( or next ) frame. Setting it to 2 will allow you to search mvs between the frame n and n-2
or n+2 ( depending on the <var>isb</var> setting ).
If delta is negative or null, -delta is the absolute index of a fixed reference frame.
In this case, the <var>isb</var> value is ignored.
Only a few functions are compatible with fixed reference frame (MCompensate, MFlow, MMask, MShow).</p>
<p> There are few advanced parameters which set coherence of motion vectors for so called true motion estimation.
Some matched blocks from other frame may be most similar to sample blocks of current frame by intensity criterion (SAD),
but not correspond to true object motion.
For example, they may belong to other similar object in different corner of the frame or belong to some periodic structure.
"True motion" parameters try maintain the motion field more coherent, instead of some random vectors distribution.
It is especially important for partial motion compensation and interpolation.
Some parameters are experimental and may be removed (replaced) in next versions after testing. Please report your conclusions.
</p>
<p><var>truemotion</var> is a preset of these parameters values.
It allows easy to switch default values of all "true motion" parameters at once.
Set it <var>true</var> for true motion search (high vector coherence),
set it <var>false</var> to search motion vectors with best SAD.
Default is true since v1.4.10.
In any case you can tune each parameter individually.</p>
<p><var>lambda</var> : set the coherence of the field of vectors. The higher,
the more coherent. However, if set too high, some best motion vectors can be
missed. Values around 400 - 2000 (for block size 8) are strongly recommended.
Internally it is coefficient for SAD penalty of vector squared difference from predictor (neighbors),
scaled by 256. <br>
Default is 0 for <var>truemotion</var>=false and 1000*blksize*blksizeV/64 for <var>truemotion</var>=true.
</p>
<p><var>lsad</var>: SAD limit for <var>lambda</var> using. Local <var>lambda</var> is decreased (smoothly since v1.10.2)
if SAD value of vector predictor (formed from neighbor blocks) is greater than the limit.
It prevents bad predictors using but decreases the motion coherence.
Values above 1000 are recommended for true motion. Scaled to blocksize=8 internally (since v2.0.11).<br>
Default is 400 for <var>truemotion</var>=false and 1200 for <var>truemotion</var>=true.
</p>
<p><var>pnew</var>: relative penalty (scaled to 256) to SAD cost for new candidate vector.
New candidate vector must be better will be accepted as new vector only if
its SAD with penalty (SAD + SAD*pnew/256) is lower then predictor cost (old SAD).
It prevent replacing of quite good predictors by new vector with a little better SAD
but different length and direction.<br>
Default is 0 for <var>truemotion</var>=false and 50 for <var>truemotion</var>=true.
</p>
<p><var>plevel</var>:  penalty factor <var>lambda</var> level scaling mode.
Value=0 - no scaling, 1 - linear, 2 - quadratic dependence from hierarchical level size.
Note, that vector length is smaller at lower level.<br>
Default is 0 for <var>truemotion</var>=false and 1 for <var>truemotion</var>=true
</p>
<p><var>global</var>:  estimate global motion (at every level) and use it as an additional predictor.
Only pan shift is estimated (no zoom and rotation).
Use false to disable, use true to enable.
Default is false for <var>truemotion</var>=false and true for <var>truemotion</var>=true.
</p>
<p><var>pzero</var>: relative penalty (scaled to 256) to SAD cost for zero vector.
It prevent replacing of quite good predictor by zero vector with a little better SAD
(<var>lambda</var> is not used for zero vector). Default is equal to <var>pnew</var> since v1.11.
</p>
<p><var>pglobal</var>: relative penalty (scaled to 256) to SAD cost for global predictor vector.
(<var>lambda</var> is not used for global vector). Default is 0.
</p>
<p><var>overlap</var>:  block overlap value (horizontal). Must be even and less than block size
(up to blksize/2 for MCompensate).
The step between blocks for motion estimation is equal to (blksize-overlap).
N blocks cover the size ((blksize-overlap)*N + overlap) on frame.
Try use overlap value from blksize/4 to blksize/2.
The greater overlap, the more blocks number, and the lesser the processing speed.
Default value is 0. <br>
Functions with overlap support are: MFlow, MFlowInter, MFlowFps, MShow, MMask, MCompensate, MDeGrain1, MDeGrain2, MDeGrain3.
</p>
<p><var>overlapv</var>:  vertical block overlap value. Default is equal to horizontal.
Must be even for YV12 and less than block size.
</p>
<p><var>outfile</var>:  name of file to write motion vectors data.
This data may be used by some external program
or may be by next MVTools versions for second pass coding, etc. <br>
Produced binary file has a header (MVAnalysisData structure, see MVInterface.h source code),
and the data sequence:<br>
frame number, vector data (Vx, Vy, SAD) of every block,
next valid frame number, this frame vector data, and so on.<br>
Default - empty string, do not write.</p>
<p><var>dct</var>: using of block DCT (frequency spectrum) for blocks difference (SAD) calculation.
In particular it can improve motion vector estimation at luma flicker and fades.<br>
0 - usual spatial blocks, do not use DCT;<br>
1 - use block DCT instead of spatial data (slow for block size 8x8 and very slow for other sizes);<br>
2 - mixed spatial and DCT data; weight is dependent on mean frame luma difference;<br>
3 - adaptive per-block switching from spatial to equal-weighted mixed mode (experimental, a little faster).<br>
4 - adaptive per-block switching from spatial to mixed mode with more weight of DCT (experimental, a little faster).<br>
added in v1.9.5.3 modes:  (require sadx264 0-7, uses fastest SATD function, luma only!) <BR>
5 - SATD instead of SAD for luma<BR>
6 - same as 2 only use SATD<BR>
7 - same as 3 only use SATD<BR>
8 - same as 4 only use SATD<BR>
9 - similar to 2, use SATD and weight ranges from SAD only to equal SAD & SATD<BR>
10 - similar to 3/4,use SATD weight is on SAD, only on strong luma changes<BR>
Default = 0.
</p>
<p><var>divide</var>: post-processing motion vectors by dividing every block into 4 subblocks.<br>
0 - do not divide;<br>
1 - divide blocks and assign the original vector to all 4 subblocks;<br>
2 - divide blocks and assign median (with 2 neighbors) vectors to subblocks;<br>
Default = 0. Block size and overlap values must be selected to be acceptable after internal dividing.
</p>
<p><var>sadx264</var>: use SAD functions from x264 codec if available for the blocksize<BR>
0 - Autodetect CPU and select best function<BR>
1 - use MMX 16x16, 16x8, 8x8, 8x4, 4x4 (8x16, 4x8 used on chroma only)<BR>
2 - use MMX 16x16, 16x8, 8x8, 8x4 (8x16, used on chroma only) aligned to 32 Byte blocks<BR>
3 - use MMX 16x16, 16x8, 8x8, 8x4 (8x16, used on chroma only) aligned to 64 Byte blocks, best for Pentium M<BR>
4 - use SSE2 16x16, 16x8 (no special alignment)<BR>
5 - use SSE2 16x16, 16x8, aligned to 64 Byte blocks (good option on Core)<BR>
6 - use SSE3 16x16, 16x8 (seems only to work faster on Pentium 4E & Core1)<BR>
7 - use SSSES3 16x16, 16x8, aligned to 64 Byte blocks (good option on Core2)<BR>
Modes 8-12 are meant for debug testing only - use dct >4 instead.<BR>
Using sadx264 > 7 means: use selected instead of SAD for any luma/chroma SAD where possible!<BR>
for SAD / SATD mix and luma only use dct<BR>
8 - use SSD mmx, works on any mode as 1<BR>
9 - use SATD mmx, works on any mode as 1<BR>
10 - use SATD SSE2, works ony any mode like 2<BR>
11 - use SATD SSSE3, works ony any mode like 2<BR>
12 - use SATD SSSE3 with PHADD on 8xY, works ony any mode like 2<BR>
Default is 0, use -1 or >=13 to use old v1.9.4 SAD algo and completely deactivate x264 SAD functions<BR>
</p>
<p><var>badSAD</var>: SAD threshold to make more wide second search for bad vectors. Value is scaled to block size 8x8.
Default is 10000 (disabling value), recommended is about 1000-2000.<br>
</p>
<p><var>badrange</var>: the range (radius) of wide search for bad blocks.
Default is 24 (image pixel units). Use positive value for UMH search and negative for Exhaustive search.
</p>
<p><var>meander</var>: Alternate blocks scan in rows from left to right and from right to left. Default is True (since v2.5.1).
</p>
<p><var>temporal</var>: use temporal predictors from previous frame motion vectors. Default is False. (not compatible with SetMTMode).
</p>
<p><var>trymany</var>: try to start searches around many predictors (besides finest level). Default is false.
</p>

<p>Try use <code>MShow</code> function to check estimated motion field and tune parameters.</p>
<p>Note: MAnalyse (if Pel=2) detects fieldbased video flag (after SeparateFields) and automatically
makes correction of motion vectors according to verticlal shift of fields with different parity.
Try use AssumeFrameBased if you do not need in it.</p>

<h3>MCompensate</h3>

<p><code>MCompensate</code> (<var>clip source, clip super, clip vectors, bool "scbehavior", float "recursion", int "thSAD",
bool "fields", float "time", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Do a full motion compensation of the frame. It means that the blocks pointed
by the mvs in the reference frame will be moved along the vectors to reach their places
in the current frame.</p>
<p><var>super</var> (unnamed) is multilevel super clip prepared by MSuper function.</p>
<p><var>vectors</var> (unnamed) is clip with motion vectors data produced by MAnalyse function.</p>
<p><var>scbehavior</var> ( by default true ), decide which frame will be kept on
a scene change. If true, the frame is left unchanged. Else, the reference frame is
copied into the current one. Same for right and bottom padded area.</p>
<p><var>recursion</var> is percent weight of previously compensated frames used for new compensation
in special recursive mode. Rest weight is taken (uniformly) from given reference frame (used in ordinary mode).
Recursion=100 is full recursion similar to in-loop mode=2 of old MVTools v0.9.x.
Do not use recursive mode unless you know what do you do. Default recursion=0.</p>
<p><var>thSAD</var> is SAD threshold for safe (dummy) compensation. If block SAD is above the thSAD,
the block is bad, and we use source block instead of the compensated block. Default is 10000 (practically disabled).
</p>
<p><var>fields</var>: if set to true and <var>pel</var>=2 or 4, then we add appropriate vertical shift
 (by halfpixel) of fields for fieldbased video.
 Try use it for deinterlacing (not for denoising).<br>
Default is false.
<p><var>time</var>:  percent of motion compensation (default=100.0, full compensation),
define time moment between reference and current frame.</p>
<p>Overlapped blocks processing is implemented as window block summation
(like FFT3DFilter, overlap value up to blksize/2) for blocking artefactes decreasing.
</p>

<h3>MMask</h3>

<p><code>MMask</code> (<var>clip source, clip vectors, float "ml", float "gamma",
int "kind", int "Ysc", float "time", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Creates mask clip from source clip with motion vectors data.
Mask is defined by blocks data, but is interpolated to fit full frame size.
The mask is created both on the luma and on chroma planes. Mask values may be from 0 (min) to 255 (max).</p>
<p><var>kind</var> parameter defines kind of mask.</p>
<p>Mode <var>kind=0</var> creates motion mask from the motion vectors length. It builds a better
mask than <code>MotionMask</code> function of MaskTools plugin because motion vectors are a lot more reliable than the
algorithm of MotionMask. Mask value 0 means no motion at all ( the
length of the motion vector is null ). The longer vector length, the larger mask value (saturated to 255),
the scale is defined by <var>ml</var>.</p>
<p><var>kind=1</var> allows to build a mask of the SAD (sum of absolute differences) values instead of the
vectors' length. It can be useful to find problem areas with bad motion estimation.
(Internal factor blocksize*blocksize/4 is used for normalization of scale <var>ml</var>.)
</p>
<p><var>kind=2</var> allows to build a occlusion mask (bad blocks due to rupture, tensile).
Currently, some normalized sum of positive blocks motion differences is used. It can be scaled with <var>ml</var>.</p>
<p><var>kind=3</var> allows to build a mask of horizontal component of motion vector in pel units plus 128.
It can be scaled with <var>ml</var>.</p>
<p><var>kind=4</var> allows to build a mask of vertical component of motion vector in pel units plus 128.
It can be scaled with <var>ml</var>.</p>
<p><var>kind=5</var> - motion colormap as x,y components of motion vector shown in U, V color planes
(in pel units plus 128, It can be scaled with <var>ml</var>).</p>
<p><var>ml</var> parameter defines the scale of motion mask.
When the vector's length (or other kind value) is superior or equal to <var>ml</var>, the output
value is saturated to 255. The lesser value results to lesser output.
</p>
<p><var>gamma</var> is used to defined the exponent of relation output to input.
<var>gamma</var> = 1.0 implies a linear relation, whereas <var>gamma</var> = 2.0 gives a
quadratic relation.</p>
<p><var>time</var>:  percent of motion compensation (default=100.0, full compensation),
define time moment between reference and current frame.</p>
<p>And finally, <var>Ysc</var> is the value taken by the mask on scene change</p>
<p>Defaults are : <var>kind</var> = 0,  <var>ml</var> = 100, <var>gamma</var> = 1.0, and
<var>Ysc</var> = 0.</p>

<h3>MSCDetection</h3>

<p><code>MSCDetection</code> (<var>clip source, clip vectors, int "Ysc", int "thSCD1", int "thSCD2", bool "isse"</var>)
</p>
<p>Creates scene detection mask clip from motion vectors data.
The mask is created both on the luma and on chroma planes. Output without scene change is 0.</p>
<p><var>Ysc</var> is the value taken by the mask on scene change, default is 255.</p>

<h3>MShow</h3>

<p><code>MShow</code> (<var>clip super, clip vectors, int "scale", int
"sil", int "tol", bool "showsad", int "number", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Shows the motion vectors on padded source by super clip opening (since v2.0.11).
</p>
<p><var>scale</var> allows to enlarge the motion
vectors, in order for example to gain in accuracy ( when
<var>pel</var> &gt; 1 and <var>scale</var> = 1, you can't see
a variation of less than one pixel ).
</p>
<p><var>sil</var> allows to see a different level of analysis ( when searching for
motion vectors, a hierarchical analysis is done, and it may be interesting to see
what happens at higher levels ).
</p>
<p><var>tol</var> is a tolerance threshold. If the distortion induced by the
motion vector is over <var>tol</var> the vector isn't shown.
</p>
<p><var>showsad</var> allows to show the mean (scaled to block 8x8) SAD after compensating the
picture and quantity (ThSCD1) of bad (ThSCD1) blocks.
</p>
<p><var>number</var> allows to mark given block (with this number) as white. Default=-1.
</p>
<p>Defaults are : <var>scale</var> = 1, <var>sil</var> = 0, <var>tol</var> =
20000 and <var>showsad</var> = false ( which shows all vectors ).</p>

<h3>MDepan</h3>

<p><code>MDepan</code> (<var>clip, clip vectors, clip "mask", bool "zoom", bool "rot", float
"pixaspect", float "error", bool "info", string "log", float "wrong", float "zerow", int "range",
int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Get the motion vectors, estimate global motion and put data to
output frame in special format for <code>DePan</code> plugin (by Fizick).</p>
<p>Inter-frame global motion (pan, zoom, rotation) is estimated by iterative
procedure, with good blocks only.
</p>
<p>Rejected blocks: 1) near frame borders or by mask; 2) with big SAD (by <var>thSCD1</var>
parameter); 3) with motion different from neighbors or global.</p>
<p><var>mask</var> clip (if defined) is used to set weight of blocks vectors equal to correspondent mask frame pixels values
(use deep black to reject block).
If the mask clip is not defined, then 4 blocks at every border are rejected (old pre v2.4.3 algorithm.)</p>
<p><i>zoom</i> and <i>rot</i> parameters switch zoom and rotation estimation, <var>
pixaspect </var> is pixel aspect (1.094 for standard PAL, 0.911 for
standard NTSC), <var>error </var>is maximum mean motion difference.</p>
<p>The frame estimated global motion is switched to null for big motion error or
at scene change (by <var>thSCD1, thSCD2</var> parameters).
</p>
<p><var>info</var> parameter allows to type global motion info for debug.
</p>
<p><var>log</var> parameter allows to set log file name in DeShaker, Depan format.</p>
<p><var>wrong</var> parameter defines limit to disable blocks very different from neighbors.
</p>
<p><var>zerow</var> parameter defines weight of zero motion vectors (to decrease its influence).
</p>
<p><var>range</var> - number of previous (and also next) frames (fields) near requested frame to estimate their motion.
</p>
<p>Defaults are : <var>zoom</var> = true, <var>rot</var> = true, <var>pixaspect</var> = 1.0,
<var>error</var> = 15.0, <var>info</var> = false, <var>wrong</var>=10, <var>zerow</var>=0.05, <var>range</var>=0.</p>
<p>For global motion estimation of interlaced source, you must separate fields
 (for both MAnalyse and MDepan).</p>

<h3>MFlow</h3>

<p><code>MFlow</code> (<var>clip source, clip super, clip vectors, float "time", int "mode", bool "fields",
int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Do a motion compensation of the frame not by blocks (like MCompensate), but by pixels.
Motion vector for every pixel is calculated by bilinear interpolation of motion vectors
of current and neighbor blocks (according to pixel position).
It means that the pixels pointed by the vector in the reference frame
will be moved (flow) along the vectors to reach their places in the current frame.
This flow motion compensation method does not produce any blocking artefactes, and is good for denoising,
but sometimes can create very strange deformed pictures :).
True motion estimation is strongly recommended for this function.
Motion compensation may be full or partial (at intermediate time).
</p>
<p><var>super</var> (unnamed) is multilevel super clip prepared by MSuper function.</p>
<p><var>vectors</var> (unnamed) is clip with motion vectors data produced by MAnalyse function.</p>
<p><var>time</var>:  percent of motion compensation (default=100.0, full compensation),
define time moment between reference and current frame.</p>
<p><var>mode</var> can be either 0 ( default ), or 1. <br>
mode=0 - fetch pixels to every place of destination. It is main producing mode.<br>
mode=1 - shift pixels from every place of source (reference).
It is debug (learning) mode with some empty spaces (with null intensity).
It can be used for occlusion mask creation.
</p>
<p><var>fields</var>: if set to true and <var>pel</var> =2 or 4, then we add appropriate vertical shifts
 (by halfpixel) of fields for fieldbased video.
 Try use it for deinterlacing (not for denoising).<br>
Default is false.
</p>

<h3>MFlowInter</h3>

<p><code>MFlowInter</code> (<var>clip source, clip super, clip mvbw, clip mvfw, float "time", float "mL",
bool "blend", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Motion interpolation function. It is not the same (but similar) as MVInterpolate function of older MVTools version.
It uses backward "mvbw" and forward "mvfw" motion vectors
to create picture at some intermediate time moment between current and next (by delta) frame.
It uses pixel-based (by MFlow method) motion compensation from both frames.
Internal forward and backward occlusion masks (MMask <var>kind=2</var> method)
and time weighted factors are used to produce the output image with minimal artefactes.
True motion estimation is strongly recommended for this function.</p>
<p><var>super</var> (unnamed) is multilevel super clip prepared by MSuper function.</p>
<p><var>mvbw, mvfw</var> (unnamed) is clips with backward and forward motion vectors data produced by MAnalyse function.</p>
<p><var>time</var>:  interpolation time position between frames (in percent, default=50.0, half-way)</p>
<p><var>mL</var>: mask scale parameter. Lower values are corresponded to more strong occlusion mask
(as in MMask function, use it to tune and debug). Default=100.
</p>
<p>
	<var>blend</var>: blend frames at scane change like ConvertFps if true,
	or repeat last frame like ChangeFps if false.
	Default is true.
</p>

<h3>MFlowFps</h3>

<p><code>MFlowFps</code> (<var>clip source, clip super, clip mvbw, clip mvfw, int "num", int "den", int "mask", float "ml",
bool "blend", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Will change the framerate (fps) of the clip (and number of frames).
The function can be use for framerate conversion, slow-motion effect, etc.
It uses backward "mvbw" and forward "mvfw" motion vectors
to create interpolated pictures at some intermediate time moments between frames.
The function uses pixel-based motion compensation (as MFlow, MFlowInter).
Internal forward and backward occlusion masks (MMask <var>kind=2</var> method)
and time weighted factors are used to produce the output image with minimal artefactes.
True motion estimation is strongly recommended for this function.</p>
<p><var>super</var> (unnamed) is multilevel super clip prepared by MSuper function.</p>
<p><var>mvbw, mvfw</var> (unnamed) is clips with backward and forward motion vectors data produced by MAnalyse function.</p>
<p><var>num</var>:  output clip fps numerator. Default=25.</p>
<p><var>den</var>:  fps denominator (default=1). Resultant fps = num/den.
In particular for doubled NTSC fps=2*29.97 use <var>num</var>=60000 and <var>den</var>=1001,
and for doubled NTSC FILM fps=2*23.976 use <var>num</var>=48000 and <var>den</var>=1001.
When <var>num</var> or <var>den</var> is equal to 0, then doubled fps of input clip is assumed for output (since v1.8.1).</p>
<p><var>mask</var>: processing mask mode:<br>
mask=0 is simple backward and forward occlusion masks (used in versions up to 1.4.x, fastest);<br>
mask=1 is similar masks with additional switching to static zero vectors at occlusion areas (similar to v1.5.x);<br>
mask=2 is for using extra vectors from adjacent frames for decreasing objects halo at occlusion areas (v1.8, slowest). Default=2.</p>
<p><var>ml</var>: mask scale parameter. The greater values are corresponded to more weak occlusion mask
(as in MMask function, use it to tune and debug). Default=100.
</p>
<p>
	<var>blend</var>: blend frames at scane change like ConvertFps if true,
	or repeat last frame like ChangeFps if false.
	Default is true.
</p>


<h3>MBlockFps</h3>

<p><code>MBlockFps</code> (<var>clip, clip super, clip mvbw, clip mvfw, int "num", int "den", int "mode", float "ml",
bool "blend", int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>The function uses block-based partial motion compensation
to change the framerate (fps) of the clip (and number of frames).
It uses backward "mvbw" and forward "mvfw" motion vectors
to create interpolated pictures at some intermediate time moments between frames.
Some internal forward and backward masks
and time weighted factors are used to produce the output image.
(Algorithm is based on MVInter function of old MVTools v1.9.12.)
It is usually faster than MFlowFps but may produce blocking and other artefactes if overlap is not set.
True motion estimation is strongly recommended for this function.
Some pixels at right and bottom which are not entirely covered by blocks will be produced by frames blend.
</p>
<p><var>super</var> (unnamed) is multilevel super clip prepared by MSuper function.
</p>
<p><var>mvbw, mvfw</var> (unnamed) is clips with backward and forward motion vectors data produced by MAnalyse function.</p>
<p><var>num</var>:  output clip fps numerator. Default=25.</p>
<p><var>den</var>:  fps denominator (default=1). Resultant fps = num/den.
In particular for doubled NTSC fps=2*29.97 use <var>num</var>=60000 and <var>den</var>=1001,
and for doubled NTSC FILM fps=2*23.976 use <var>num</var>=48000 and <var>den</var>=1001.
When <var>num</var> or <var>den</var> is equal to 0, then doubled fps of input clip is assumed for output.</p>
<p><var>mode</var>: processing mode:<br>
0 - average of fetched forward and backward partial motion compensation (fastest).<br>
1 - static median.<br>
2 - dynamic median.<br>
3 - time weigthed combination of fetched forward blocks masked by shifted backward
and fetched backward masked by shifted forward (now default mode);<br>
4 - mode 3 mixed with simple static time average by occlusion mask of shifted blocks.<br>
5 - occlusion mask (for debug).
<br /> 6 to 8 - modes like 3 to 5 but SAD mask is used as occlusion mask.
</p>
<p><var>ml</var>: mask scale factor. Default=100.
</p>
<p><var>blend</var>: blend frames at scane change like <code>ConvertFps</code> if True,
or repeat last frame like <code>ChangeFps</code> if False.
Default is True.
</p>

	<h3>MFlowBlur</h3>

<p><code>MFlowBlur</code> (<var>clip, clip super, clip mvbw, clip mvfw, float "blur", int "prec",
int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)
</p>
<p>Experimental simple motion blur function. It may be used for FILM-effect (to simulate finite shutter time).
It uses backward "mvbw" and forward "mvfw" motion vectors
to create and overlay many copies of partially compensated pixels
at intermediate time moments in some blurring interval around current frame.
It uses pixel-based motion compensation (as MFlow).
True motion estimation is strongly recommended for this function.</p>
<p><var>super</var> (unnamed) is multilevel super clip prepared by MSuper function.</p>
<p><var>mvbw, mvfw</var> (unnamed) is clips with backward and forward motion vectors data produced by MAnalyse function.</p>
<p><var>blur</var>: blur time interval between frames, open shutter time (in percent, default=50.0)</p>
<p><var>prec</var>: blur precision in pixel units. Maximal step between compensated blurred pixels. Default =1 (most precise).
</p>

<h3>MDeGrain1, MDeGrain2 and MDegrain3</h3>

<p><code>MDeGrain1</code> (<var>clip, clip super, clip mvbw, clip mvfw, int "thSAD", int "thSADC", int "plane", int "limit",
int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)</p>
<p><code>MDeGrain2</code> (<var>clip, clip super, clip mvbw, clip mvfw, clip mvbw2, clip mvfw2, int "thSAD", int "thSADC", int "plane", int "limit",
int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)</p>
<p><code>MDeGrain3</code> (<var>clip, clip super, clip mvbw, clip mvfw, clip mvbw2, clip mvfw2,
   clip mvbw3, clip mvfw3,int "thSAD", int "thSADC", int "plane", int "limit", int "limitC",
   int "thSCD1", int "thSCD2", bool "isse", bool "planar"</var>)</p>
<p>Makes a temporal denoising with motion compensation.
Blocks of previous and next frames are motion compensated and then averaged with current frame
with weigthing factors depended on block differences from current (SAD). Functions support overlapped blocks mode.
Overlaped blocks processing is implemented as window block summation
(like FFT3DFilter, overlap value up to blksize/2) for blocking artefactes decreasing.
</p>
<p>MDeGrain1 has temporal radius 1 (uses vectors of previous <var>mvfw</var> and next <var>mvbw</var> frames).
MDeGrain2 has temporal radius 2 (uses vectors of two previous <var>mvfw2, mvfw</var> and two next <var>mvbw,mvbw2</var> frames).
MDeGrain3 has temporal radius 3 (uses vectors of three previous <var>mvfw3, mvfw2, mvfw</var> and three next <var>mvbw, mvbw2, mvbw3</var> frames).
It is slower, but produces a little better results (more strong denoising).</p>
<p><var>super</var> (unnamed) is multilevel super clip prepared by MSuper function.</p>
<p><var>mvbw, mvfw</var> (unnamed) is clips with backward and forward motion vectors data produced by MAnalyse function.</p>
<p><var>"thSAD"</var> parameter defines soft threshold of block sum absolute differences.
Block with SAD above threshold <var>thSAD</var> have a zero weight for averaging (denoising).
Block with low SAD has highest weight. Rest of weight is taken from pixels of source clip.
You must enter <var>thSAD</var> value reduced to block size 8x8.
Low values can result in staggered denoising, large values can rezult in ghosting and artefactes.
<br>
Default <var>thSAD</var>=400.</p>
<p><var>"thSADC"</var> is the threshold for chroma planes.<br>
Default (if not defined) : <var>thSADC</var>=<var>thSAD</var>.
If defined then <var>thSADC</var>is used for chroma and <var>thSAD</var> is used for luma.</p>
<p><var>plane</var> parameter set procesed color plane:<br>
0 - luma, 1 - chroma U, 2 - chroma V, 3 - both chromas, 4 - all. Default is 4.
</p>
<p><var>limit</var>: maximal change of pixel luma (post-process like DeGrainMedian plugin
and LimitChange function of SSETools plugin, to prevent some artefactes).
Default is 255 (no limit).
</p>
<p><var>limitC</var>: maximal change of pixel chroma. Default value = <var>limit</var>.
</p>

<h3>MRecalculate</h3>

<p><code>MRecalculate</code> (<var>clip super, clip vectors, int "thSAD", int "smooth", int "blksize", int "blksizeV",
int "search", int "searchparam", int "lambda", bool "chroma",
bool "truemotion", int "pnew", int "overlap", int "overlapV",
string "outfile", int "dct", int "divide", int "sadx264", bool "isse"</var>)
</p>
<p>Refines and recalculates motion data of previously estimated (by MAnalyse) motion <var>vectors</var>
with different <var>super clip</var> or new parameters set (e.g. lesser block size), after divide, etc.
The two-stage method may be also useful for more stable (robust) motion estimation.
The refining is at finest hierarchical level only.
Interpolated vectors of old blocks are used as predictors for new vectors, with recalculation of SAD.
Only bad quality new vectors with SAD above threshold <var>thSAD</var> will be re-estimated by search.
Enter <var>thSAD</var> value reduced (scaled) to block size 8x8. Default <var>thSAD</var>=200.
Good vectors are not changed, but its SAD will be updated (re-calculated).
</p>
<p><var>smooth</var> is method how to divide coarse blocks to smaller.
0 - use motion of nearest block, 1 - bilinear interpolation of 4 neighbors. Default 1.</p>
<p>Other parameters have the same meaning as MAnalyse (but you can use other values).
Default settings are same as defaults of MAnalyse.
</p>


<h2><a name="examples"></a>III) Examples
</h2>

<p>To show the motion vectors ( forward ) :
</p>
<pre>AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
vectors = MSuper().MAnalyse(isb = false)
MShow(vectors) # implicit last works properly</pre>

<p>To show the backward one :
</p>
<pre>AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
vectors = MSuper().MAnalyse(isb = true)
MShow(vectors)</pre>

<p>To use MMask :
</p>
<pre>AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
vectors = MSuper().MAnalyse(isb = false)
MMask(vectors)</pre>

<p>To use MDepan with <a href="depan.htm">Depan</a> plugin for interlaced source
 (DepanStabilize function example):</p>
<pre>AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
AssumeTFF().SeparateFields() # set correct fields order
vectors = MSuper().MAnalyse(isb = false)
globalmotion = MDepan(vectors, pixaspect=1.094, thSCD1=400)
DepanStabilize(data=globalmotion, cutoff=2.0, mirror=15, pixaspect=1.094)
Weave()
</pre>

<p>To blur problem (blocky) areas of compensated frame with occlusion mask:</p>
<pre>AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
super = MSuper()
vectors = MAnalyse(super, isb = false)
compensation = MCompensate(super,vectors) # or use MFlow function here
# prepare blurred frame with some strong blur or deblock function:
blurred = compensation.DeBlock(quant=51) # Use DeBlock function here
badmask = MMask(vectors, kind = 2, ml=50)
overlay(compensation,blurred,mask=badmask) # or use faster MaskedMerge function of MaskTools
</pre>

<p>To recreate bad frames by interpolation with MFlowInter:</p>
<pre>AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
super = MSuper()
backward_vectors = MAnalyse(super, isb = true, delta=2)
forward_vectors = MAnalyse(super, isb = false, delta=2)
inter = MFlowInter(super, backward_vectors, forward_vectors, time=50, ml=70)
# Assume bad frames are 50 and 60
trim(0,49) ++ inter.trim(49,-1) \
 ++ trim(51,59) ++ inter.trim(59,-1) ++ trim(61,0)
</pre>

<p>To change fps with MFlowFps:</p>
<pre>AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
# assume progressive PAL 25 fps source
super = MSuper(pel=2)
backward_vec = MAnalyse(super, isb = true)
forward_vec = MAnalyse(super, isb = false)
MFlowFps(super, backward_vec, forward_vec, num=50, den=1, ml=100) # get 50 fps
</pre>

<p>To double fps with MFlowFps for fastest (almost) real-time playing:</p>
<pre>AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
# assume progressive PAL 25 fps or NTSC Film 23.976 source
super = MSuper(pel=1,hpad=0,vpad=0,chroma=false)
backward_vec = MAnalyse(super, blksize=32, isb = true, chroma=false, searchparam=1,search=0)
forward_vec = MAnalyse(super, blksize=32, isb = false, chroma=false, searchparam=1,search=0)
MFlowFps(super, backward_vec, forward_vec, num=2*FramerateNumerator(last), \
   den=FramerateDenominator(last), mask=0)
</pre>

<p>To double fps with MFlowFps for 'best' results (but slower processing):</p>
<pre>AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
# assume progressive PAL 25 fps or NTSC Film 23.976 source
super = MSuper(pel=2)
backward_vec = MAnalyse(super, overlap=4, isb = true, search=3)
# Use block overlap, halfpixel accuracy and Exhaustive search
forward_vec = MAnalyse(super, overlap=4, isb = false, search=3)
MFlowFps(super, backward_vec, forward_vec, num=2*FramerateNumerator(last), \
   den=FramerateDenominator(last))
</pre>

<p>To generate nice motion blur with MFlowBlur:</p>
<pre>AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
super = MSuper()
backward_vectors = MAnalyse(super, isb = true)
forward_vectors = MAnalyse(super, isb = false)
MFlowBlur(super, backward_vectors, forward_vectors, blur=15)
</pre>

<p>To denoise with some external denoiser filter (which uses 3 frames: prev, cur, next):</p>
<pre>AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
super = MSuper()
backward_vectors = MAnalyse(super, isb = true)
forward_vectors = MAnalyse(super, isb = false)
forward_compensation = MFlow(super, forward_vectors, thSCD1=500) # or use MCompensate
backward_compensation = MFlow(super, backward_vectors, thSCD1=500)
# create interleaved 3 frames sequences
interleave(forward_compensation, last, backward_compensation)

DeGrainMedian() # place your preferred temporal (spatial-temporal) denoiser here

selectevery(3,1) # return filtered central (not-compensated) frames only
</pre>

<p>To use prefiltered clip for more reliable motion estimation,
but compensate motion of not-prefiltered clip (denoising example)</p>

<pre>AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
# Use some denoiser (blur) or deflicker for prefiltering
prefiltered = blur(1.0)
super = MSuper(levels=1) # one level is enough for MCompensate
superfilt = MSuper(prefiltered) # all levels for MAnalyse
backward_vectors = MAnalyse(superfilt, isb = true)
forward_vectors = MAnalyse(superfilt, isb = false)
# use not-prefiltered (super) clip for motion compensation
forward_compensation = MCompensate(super, forward_vectors)
backward_compensation = MCompensate(super, backward_vectors)
# create interleaved 3 frames sequences
interleave(forward_compensation, last, backward_compensation)

DeGrainMedian() # place your preferred temporal (spatial-temporal) denoiser here

selectevery(3,1) # return filtered central (not-compensated) frames only
</pre>

<p>To denoise by MDegrain2 with overlapped blocks (blksize=8) and subpixel precision:</p>
<pre>AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
super = MSuper(pel=2, sharp=1)
backward_vec2 = MAnalyse(super, isb = true, delta = 2, overlap=4)
backward_vec1 = MAnalyse(super, isb = true, delta = 1, overlap=4)
forward_vec1 = MAnalyse(super, isb = false, delta = 1, overlap=4)
forward_vec2 = MAnalyse(super, isb = false, delta = 2, overlap=4)
MDegrain2(super, backward_vec1,forward_vec1,backward_vec2,forward_vec2,thSAD=400)</pre>

<p>To denoise interlaced source by MDegrain1 with overlapped blocks (blksize=8) and subpixel precision:</p>
<pre>AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
fields=AssumeTFF().SeparateFields() # or AssumeBFF
super = MSuper(fields)
backward_vec2 = MAnalyse(super, isb = true, delta = 2, overlap=2)
forward_vec2 = MAnalyse(super, isb = false, delta = 2, overlap=2)
MDegrain1(fields, super, backward_vec2,forward_vec2,thSAD=400)
Weave()</pre>

<p>To denoise interlaced source with function MDegrain2i2:</p>
<pre>function MDegrain2i2(clip source, int "overlap", int "dct")
{
overlap=default(overlap,0) # overlap value (0 to 4 for blksize=8)
dct=default(dct,0) # use dct=1 for clip with light flicker
fields=source.SeparateFields() # separate by fields
super = fields.MSuper()
backward_vec2 = super.MAnalyse(isb = true, delta = 2, overlap=overlap, dct=dct)
forward_vec2 = super.MAnalyse(isb = false, delta = 2, overlap=overlap, dct=dct)
backward_vec4 = super.MAnalyse(isb = true, delta = 4, overlap=overlap, dct=dct)
forward_vec4 = super.MAnalyse(isb = false, delta = 4, overlap=overlap, dct=dct)
fields.MDegrain2(super, backward_vec2,forward_vec2,backward_vec4,forward_vec4,thSAD=400)
Weave()
}

AVISource("video.avi")
mdegrain2i2(4,0)
</pre>

<p>How to use external subpixel interpolation clip:</p>
<pre># Load Eedi2 plugin (<a href="http://bengal.missouri.edu/~kes25c/">by tritical</a>) with edge-directed interpolation function
LoadPlugin("Eedi2.dll")
AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
# create upsampled clip of source
ups = EEDI2(field=1).LanczosResize(2*width(last), 2*height(last), src_left=0.25)
super = MSuper(pel=2, pelclip=ups)
bv = MAnalyse(super, isb = true, overlap=4)
MCompensate(super, bv)
</pre>

<p>How to use with MT filter and special <a href="http://forum.doom9.org/showthread.php?t=94996">multithreaded AviSynth</a>:</p>
<pre># Load MT plugin by TSP
LoadPlugin("MT.dll")
avisource("some.avi")
MT("""
super = MSuper(pel=2, sharp=1)
backward_vec2 = super.MAnalyse(isb = true, delta = 2, overlap=4)
backward_vec1 = super.MAnalyse(isb = true, delta = 1, overlap=4)
forward_vec1 = super.MAnalyse(isb = false, delta = 1, overlap=4)
forward_vec2 = super.MAnalyse(isb = false, delta = 2, overlap=4)
MDegrain2(super, backward_vec1,forward_vec1,backward_vec2,forward_vec2,thSAD=400)
""",2) # two threads
</pre>
<p>Note: SetMTMode(2) mode of multithreaded AviSynth is also supported since MVTools v.1.8.4.1 (beta testing).
MVtools version 2 should works more stable.
Same example with SetMTMode:</p>
<pre>SetMTMode(5)
FFmpegSource("some.avi") # avisource doesn't work with SetMTMode on my machines - TSchniede

SetMTMode(2)
super = MSuper(pel=2)
backward_vec2 = MAnalyse(super, isb = true, delta = 2, overlap=4)
backward_vec1 = MAnalyse(super, isb = true, delta = 1, overlap=4)
forward_vec1 = MAnalyse(super, isb = false, delta = 1, overlap=4)
forward_vec2 = MAnalyse(super, isb = false, delta = 2, overlap=4)
MDegrain2(super, backward_vec1,forward_vec1,backward_vec2,forward_vec2,thSAD=400)
</pre>

<p>How to use prefiltered clip and recalculate motion data with original source (MFlowFPS example)</p>
<pre>AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
prefiltered = DeGrainMedian() # some smoothing
super = MSuper(hpad=16, vpad=16, levels=1) # one level is enough for MRecalculate
superfilt = MSuper(prefiltered, hpad=16, vpad=16) # all levels for MAnalyse
backward = MAnalyse(superfilt, isb = true, blksize=16)
forward = MAnalyse(superfilt, isb = false, blksize=16)
# recalculate for original source clip and other block size
forward_re = MRecalculate(super, forward, blksize=8, thSAD=100)
backward_re = MRecalculate(super, backward, blksize=8, thSAD=100)
MFlowFps(super, backward_re, forward_re, num=50, den=1)</pre>

<p>How to use planar option for faster processing of YUY2 (MDegrain3 example):</p>
<pre>LoadPlugin("SSEToolsS.dll") # for conversion functions
AVISource("c:\test.avi") # or MPEG2Source, DirectShowSource, some previous filter, etc
Interleaved2Planar() # convert clip to planar
super = MSuper(planar=true)
bv1 = MAnalyse(super, isb = true, delta = 1, overlap=4)
fv1 = MAnalyse(super, isb = false, delta = 1, overlap=4)
bv2 = MAnalyse(super, isb = true, delta = 2, overlap=4)
fv2 = MAnalyse(super, isb = false, delta = 2, overlap=4)
bv3 = MAnalyse(super, isb = true, delta = 3, overlap=4)
fv3 = MAnalyse(super, isb = false, delta = 3, overlap=4)
MDegrain3(super,bv1,fv1,bv2,fv2,bv3,fv3,thSAD=400,planar=true)
Planar2Interleaved() # convert back to normal interleave YUY2
</pre>

<h2><a name="disclaimer"></a>IV) Disclaimer
</h2>
<p>This plugin is distributed under terms of the GNU GPL license, without any warranty. See 'gpl.txt'.<br>
Documentation is distributed under <a href="http://creativecommons.org/licenses/by-sa/3.0/">CreativeCommons BY-SA 3.0 license.</a><br>
<p>Please consider to make some <a href="http://avisynth.org.ru/donate.html">donation</a> for support.</p>
<p>MVTools uses portions of code of following projects:<br>
Resizer (SimpleResize.cpp) is from SimpleResize Avisynth plugin by Tom Barry. http://www.trbarry.com<br>
Fast DCT (fdct_mmx.asm) is from XVID MPEG-4 VIDEO CODEC. http://www.xvid.org<br>
DCT general transform (see fftwlite.h) is from FFTW library (as DLL call). http://www.fftw.org<br>
SATD (pixel-32.asm, pixel.asm) and alternative SADx264 (sad-a.asm, x86inc.asm, x86inc-32.asm, cpu-32.asm) are from x264 project. http://www.videolan.org/developers/x264.html
(Loren Merritt, Laurent Aimar, Alex Izvorski et al).
</p>

<h2><a name="revisions"></a>V) Revisions
</h2>
<p>2.5.11.22 (26.04.2016 by Fizick)</p>
<ul>
<li>MflowXXX: aligned to fix strange bug for some odd frame sizes and pel=1.</li>
</ul>
<p>2.5.11.21 (22.04.2016 by Fizick)</p>
<ul>
<li>MflowXXX: remove limit of motion vectors length (was 127/pel).</li>
<li>MMask: possible vector scaling for kind=3,4,5.</li>
</ul>
<p>2.5.11.20 (02.04.2016 by Fizick)</p>
<ul>
<li>Fixed Mflow broken in 2.5.11.2, fixed several other small bugs.</li>
<li>MBlockFps: added support of overlap, renamed parameter thres to ml.</li>
<li>MCompensate, MMask: added partial time compensation.</li>
<li>Masked functions: improved occlusion mask.</li>
<li>MBlockFPS, MMask - added option to use SAD as occlusion mask.</li>
<li>Documented (after Firesledge) negative delta values (v.2.2.1 quick hack for static scene compensation and motion tracking)
 and fixed some functions accordingly.</li>
</ul>
<p>2.5.11.3 (19.09.2011 by Fizick)</p>
<ul>
<li>MFlowInter: fixed planar.</li>
<li>MCompensate: fixed destructor for recursion.</li>
</ul>
<p>2.5.11.2 beta (20.03.2011 by Fizick)</p>
<ul>
<li>MCompensate: fixed crash with too small npad, vpad (thanks to '-Vit-'). Optimized MFlow.
</li>
</ul>
<p>2.5.11.1 beta (22.12.2010 by Fizick)</p>
<ul>
<li>MAnalyse, MRecalculate: fixed pure Horizontal and Vertical search types (fix by 'cretindesalpes').
</li>
</ul>
<p>2.5.11 beta (17.10.2010 by Fizick)</p>
<ul>
<li>MAnalyse, MRecalculate: added pure Horizontal and Vertical search types (requested by 'Null Null').
</li>
<li>MRecalculate: Fixed Hexagon and UMH search types (was processed as Logarithmic).
</li>
</ul>
<p>2.5.10.1 beta (25.06.2010 by Fizick)</p>
<ul>
<li>MFlowInter: Fixed incorrect transmission of last parameters (blend, etc).
Thanks to Laurent de Soras 'Firesledge'.
Other interesting updates (dither, time clip, multitheading, multivector) from his MVTools 2 mod16 fork
(http://ldesoras.free.fr/prod.html) are under consideration.
</li>
<li>MDepan: Fixed bug : if range=1 in MDepan, the debug text (with info=true)
was only displayed in the first frame when loading the script.
Thanks Boulder for report.
</li>
<li>MRecalculate: Fixed bug if pel values are different. Thanks Boulder for report.</li>
</ul>
<p>2.5.10 beta (8.11.2009 by Fizick)</p>
<ul>
<li>MAnalyse: try many predictors</li>
<li>MAnalyse: replace third right-top predictor by right-bottom</li>
<li>MAnalyse: exhaustive search at all coarse levels (always), removed <var>full</var> parameter</li>
</ul>
<p>2.5.9 (4.11.2009 by Fizick)</p>
<ul>
<li>MAnalyse: restored lambda for coarsest level)</li>
<li>MAnalyse: fixed full=0 default according to doc</li>
</ul>
<p>2.5.8.1 (26.10.2009 by Fizick)</p>
<ul>
<li>MDegrain2: fixed limitC (thanks Terranigma for bug report)</li>
</ul>
<p>2.5.8 (18.10.2009 by Fizick)</p>
<ul>
<li>MAnalyse: fixed some wrong vectors (thanks to shon26 for bug report)</li>
</ul>
<p>2.5.7 (09.10.2009 by Fizick)</p>
<ul>
<li>MAnalyse: fix bug (crash for some frame sizes) (thanks to Mark bug report)</li>
</ul>
<p>2.5.6 (08.10.2009 by Fizick)</p>
<ul>
<li>MAnalyse: fix bug (crash for pad>0 and some frame sizes) with levels (thanks to Mark bug report)</li>
</ul>
<p>2.5.5 (28.09.2009 by Fizick)</p>
<ul>
<li>MAnalyse: fix bug (crash for hpad=0) with levels (thanks to Boulder and LaTo for bug report)</li>
<li>MSuper: corrected interpolation at planes borders</li>
<li>MDegrain1,2,3: added limitC parameter</li>
</ul>
<p>2.5.4 (27.09.2009 by Fizick)</p>
<ul>
<li>MAnalyse: set default temporal=false according to doc (some problem with SetMTMode(2) was reported by MAG79)</li>
</ul>
<p>2.5.3 (08.09.2009 by Fizick)</p>
<ul>
<li>MAnalyse: added temporal predictor of motion vector</li>
<li>MRecalculate: fixed broken v2.5.2</li>
</ul>
<p>2.5.2 (11.08.2009 by Fizick)</p>
<ul>
<li>MSuper: separable width and height reducing with assembler iSSE optimization</li>
<li>MAnalyse: limit levels value</li>
</ul>
<p>2.5.1 (07.08.2009 by Fizick)</p>
<ul>
<li>MAnalyse: Added <var>meander</var> parameter for blocks scan in rows from left to right and from right to left</li>
<li>Small optimization of YUY2 conversion</li>
</ul>
<p>2.5.0 (01.08.2009 by Fizick)</p>
<ul>
<li>MSuper: More full size of sublevels</li>
<li>MAnalyse: Increased number of sublevels (for more long vectors)</li>
<li>MAnalyse: Replaced parameter name <var>level</var> by <var>levels</var>, changed meaning of its positive and negative values</li>
<li>MAnalyse: Disabled <var>lambda</var> for most coarse level</li>
<li>MAnalyse: Full search with large radius at smallest level</li>
</ul>
<p>2.4.7 (28.07.2009 by Fizick)</p>
<ul>
<li>MBlockFPS: finally fixed bug for non-zero pad, non-integer  number of blocks</li>
</ul>
<p>2.4.6 (26.07.2009 by Fizick)</p>
<ul>
<li>MBlockFPS: fixed bug (at right and bottom, repored by Shon26) for non-zero pad, non-integer  number of blocks</li>
<li>Fixed possible bug with pixels interpolation at low hierarhical  levels</li>
<li>More correct size of sublevels (even luma  for YV12)</li>
<li>MShow: change draw vector style to gradient</li>
</ul>
<p>2.4.5 (11.07.2009 by Fizick)</p>
<ul>
<li>Added block size 32x32</li>
<li>Replaced avisynth.h with v2.5.8MT by SEt</li>
</ul>
<p>2.4.4 (08.07.2009 by Fizick)</p>
<ul>
<li>Merged all code mods by SEt, but:</li>
<li>Replaced avisynth.h v2.5.5 by v2.5.8</li>
</ul>
<p>2.4.2_mod2 (30.06.2009 by Pavel Skakov aka SEt)</p>
<ul>
<li>Corrected threading problems, minor optimizations
(avisynth.h from avisynth2.5.8MT beta, init vectors as 0)</li>
</ul>
<p>2.4.2_mod (22.06.2009 by Pavel Skakov aka SEt)</p>
<p>Some source/project settings cleanup and optimized primary for MDegrain1/2/3 -
depending on your settings you'll probably see 2-15% speedup, results are bit-identical to original 2.4.2:
</p>
<ul>
<li>added Average2 iSSE version for pel=4,</li>
<li>Degrain1/2/3 MMX and SSE2 versions,</li>
<li>small optimization of copy8x8 mmx and Horizontal_Wiener SSE,</li>
<li>fixed cpu detection</li>
</ul>
<p>2.4.3 beta (26.04.2009 by Fizick)</p>
<ul>
<li>MDepan: added mask (requested by djonline) and planar parameters.</li>
</ul>
<p>2.4.2 (07.04.2009 by Fizick)</p>
<ul>
<li>MAnalyze: Fixed valid vector range for case of padding lesser than block size, with program crash (thanks to FuPP for bug report).</li>
</ul>
<p>2.4.1 beta (24.01.2009 by Fizick)</p>
<ul>
<li>MDegrain: Fixed weight for high threshold and big block size.</li>
</ul>
<p>2.4.0 beta (09.01.2009 by Fizick)</p>
<ul>
<li>MDegrain: Changed degrain weight method to more strong, some internal rewriting.</li>
<li>Fixed documentation.</li>
</ul>
<p>2.3.1 (14.12.2008 by Fizick)</p>
<ul>
<li>MSuper: added more smoothing reducing filters rfilter=2,3,4, by default 2.</li>
<li>MAnalyse: fixed bug with plevel parameter (version 2.3.0).</li>
</ul>
<p>2.3.0 (6.12.2008 by Fizick)</p>
<ul>
<li>Renamed all functions from MVxxx to Mxxx (some renaming was requested by LaTo, Mystery Keeper, Sagekilla).
Error messages is still not updated.</li>
<li>MAnalyse: added pglobal parameter (with small changes), changed default level=1.</li>
</ul>
<p>2.2.2 (30.11.2008 by Fizick)</p>
<ul>
<li>MVShow: changes SAD by reduced to block size 8x8, added quantity of bad blocks.</li>
<li>MVCompensate: fixed bug at scene changes (thanks to AVIL for bug report about YUY2).</li>
<li>MVAnalyse: fixed chroma=false (thanks to LaTo for bug report).</li>
<li>Renamed to mvtools2.dll (requested by Naito).</li>
</ul>
<p>2.2.1 (27.11.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: fixed wrong scaling of LSAD to block size (thanks to Shon for bug report).</li>
<li>MVCompensate: removed mode parameter, added recursion.</li>
</ul>
<p>2.1.2 (23.11.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: removed option mc. Reduced size of block data (increment version of vector stream).</li>
<li>MVDegrain: fixed bug with block size 32x16</li>
</ul>
<p>2.1.1 (18.11.2008 by Fizick)</p>
<ul>
<li>MVBlockFps: fixed left border bug</li>
</ul>
<p>2.1.0 (8.11.2008 by Fizick)</p>
<ul>
<li>MVFlowFps, MVBlockFps, MVFlowInter: added blend parameter for ChangeFps-like mode at scene changes</li>
<li>MVFlowFps, MVBlockFps: more safe for big nominator and denominator.</li>
</ul>
<p>2.0.11.2 (6.11.2008 by Fizick)</p>
<ul>
<li>MVDegrain2,3: fixed crashes at scene changes for YUY2</li>
</ul>
<p>2.0.11.1 (5.11.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: added second wide search for bad blocks (badSAD, badrange parameters).</li>
<li>MVAnalyse: added Hexagon and Uneven Multi Hexagon (UMH) search types.
Changed (not intentionally :) the default method from Logarithmic to Hexagon.</li>
<li>MVAnalyse: fixed exhaustive search to static center.</li>
<li>MVAnalyse: lsad is now scaled to blksize 8.</li>
<li>MVShow: use super clip, padded output, added number block option.</li>
</ul>
<p>2.0.9.2 (3.11.2008 by Fizick)</p>
<ul>
<li>Some performance improving</li>
</ul>
<p>2.0.9.1 (20.10.2008 by Fizick)</p>
<ul>
<li>More memory-optimal MVFlowXXX functions for pel=1</li>
<li>Disabled plugin debug mode</li>
<li>Added Russian documentation</li>
</ul>
<p>2.0.9.0 alpha (13.10.2008 by Fizick)</p>
<ul>
<li>Implemented more functions without idx: MVSCDetection, MVDepan, MVFlowInter, MVBlockFps, MVFlowBlur, MVDegrain3, MVRecalculate</li>
<li>Fixed crashes with MVSuper(chroma=false)</li>
<li>Some small changes and fixes for v2.0 of course :)</li>
<li>Documentation for v2.0</li>
</ul>
<p>2.0.7.0 alpha (02.10.2008 by Fizick)</p>
<ul>
<li>Implemented functions without idx: MVSuper, MVAnalyse, MVFlowFps, MVFlow,
MVCompensate, MVShow, MVMask, MVDegrain1, MVDegrain2</li>
<li>All functions (besides MVAnalyse) got planar parameter for YUY2 planar input and output.
Default = false (i.e. normal interleaved YUY2), slower.</li>
<li>All (mandatory) clip parameters lost their names, and mvbw=vb is not correct syntax now.
Use unnamed syntax instead. </li>
</ul>
<p>2.0.0.3 alpha (28.09.2008 by Fizick)</p>
<ul>
<li>First 2.0 branch public alpha with MVSuper function to kill idx.</li>
<li>MVAnalyse and MVDegrain1 are implemented only.</li>
</ul>

<p>1.11.4.4 (15.10.2008 by Fizick)</p>
<ul>
<li>Restore old internal cache size growing as before v1.11.4.2 (some crashes reported).</li>
</ul>
<p>1.11.4.3 (08.10.2008 by Fizick)</p>
<ul>
<li>MVDenoise: fixed error of v.1.11.4 with luma correction.</li>
<li>MVCompensate: fix potential memory leakage (in constructor).</li>
</ul>
<p>1.11.4.2 (26.09.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: cut unused compensation memory space from vector clip (mc parameter).</li>
<li>Decreased internal cache size growing.</li>
<li>All MVFlow functions: fixed old bug with pixels for pel=4.</li>
<li>MVAnalyse: added rfilter parameter (smooth method).</li>
<li>MVBlockFps: added YUY2 and pelclip support.</li>
<li>Tiny stability fixes for MT.</li>
</ul>
<p>1.11.0.1 beta (08.09.2008 by Fizick)</p>
<ul>
<li>New MVBlockFps for simple fps change (almost realtime :-).</li>
<li>MVAnalyse: more smooth method of frame hierarchical level reducing (like ReduceBy2) for smoothing at every level.</li>
<li>MVAnalyse: Added pzero parameter of zero vector cost for more coherent motion vectors (now switched ON by default, set to 0 if you need in old algo).</li>
<li>MVAnalyse: Decreased pelsearch internal clipping from pel to 1 (asked by somebody for speed).</li>
<li>MVFlowFps,MVFlowFps2, MVFlowInter: removed thSAD parameter.</li>
<li>All functions: Removed mmx parameter.</li>
</ul>
<p>1.10.2.1 (28.08.2008 by Fizick)</p>
<ul>
<li>MVDegrain1-3: fixed old rounding error resulted in some chroma tint
(some thanks to Didee for bugreport, but it could be more persevering in official MVTools forum thread :)</li>
<li>Made doc about pelclip more accurate (hopely).</li>
</ul>
<p>1.10.2.0 beta (27.08.2008 by Fizick)</p>
<ul>
<li>Debugged and renamed MVRefine back to new MVRecalculate :).</li>
<li>MVAnalyse: changed LSAD threshold from hard by soft for a little more coherent motion at bad areas.</li>
<li>MVAnalyse: fixed old bug for (rarely used) different horizontal and vertical overlap sizes.</li>
</ul>
<p>1.10.1.0 not public (22.08.2008 by Fizick)</p>
<ul>
<li>Change MVRecalculate by more general function (MVRefine) which can re-estimate vectors.</li>
</ul>
<p>1.10.0.0 not public (18.08.2008 by Fizick)</p>
<ul>
<li>Added MVRecalculate function to update SAD (as requested by Didee).</li>
<li>Fixed possible memory leaks (thanks to josey_wells for note)</li>
<li>Other changes of v1.9.6-1.9.7 branch by josey_wells are still not merged -
 too many work to analyse new code and numerous cosmetic rewriting,
 so based on v1.9.5.7</li>
</ul>
<p>1.9.6.x-1.9.7.x series branch (01.08.2008-26.08.2008 by josey_wells)</p>
<ul>
<li>Added MVAnalyseMulti, MVDegrain, MVMultiExtract functions with internal multitheading
(that does not require any special AviSynth, SetMTMode or MT) </li>
<li>Some bug fixes (memory leaks), code consolidation (rewriting) for stability and performance improvements.
Also there is a multitude of changes due to the addition of threading class,
semaphore class, critical section class, thread files for MVDegrain, MVAnalyseMulti
as well as factoring out common code for MVDegrain into a single base class moving out common code etc.
There are no changes of algorithms.
See <a href="http://forum.doom9.org/showthread.php?t=84770">messages at forum</a> since August 2008 for download, syntax and discussion.</li>
</ul>
<p>1.9.5.7 public beta (03.07.2008 by Fizick)</p>
<ul>
<li>Fixed Overlap_2xY_mmx</li>
<li>Added (incomplete?) list of used projects to doc.</li>
</ul>
<p>1.9.5.6 (02.07.2008 by TSchniede)</p>
<ul>
<li>Improved my, added Overlap_2xY_mmx, optimized CheckMV2 and LumaSAD.</li>
</ul>
<p>1.9.5.5 (28.06.2008 by TSchniede)</p>
<ul>
<li>Improved default 2xY SAD and added new faster 2xY SAD.</li>
</ul>
<p>1.9.5.4 (27.06.2008 by TSchniede)</p>
<ul>
<li>Ported CPU detection from x264.</li>
<li>Now using x264 SAD autoddetect is default</li>
<li>Merge with 1.9.5.1, re-enabled 32x16 mode (only default functions)</li>
</ul>
<p>1.9.5.3 (26.06.2008 by TSchniede)</p>
<ul>
<li>Imported SSD and SATD functions.</li>
<li>access using sadx264 > 7 or dct > 4.</li>
</ul>
<p>1.9.5.2 (24.06.2008 by TSchniede)</p>
<ul>
<li>Buffered source block in aligned area before calculating SAD.</li>
<li>This fixes crashes if source block was unaligned due to overlaped blocks.</li>
<li>Worst case was &lt; 1% slower, most of the time it further increases performance.</li>
</ul>
<p>1.9.5.1 public beta (21.06.2008 by Fizick)</p>
<ul>
<li>Merge v.1.9.5 changes by TSchniede.</li>
</ul>
<p>1.9.5 (21.06.2008 by TSchniede), based on v.1.9.3</p>
<ul>
<li>MVAnalyse: added sadx264 option.</li>
<li>Internal modifications - aligned memory of luma&chroma planes and modified MVTools to the interface of the SAD functions used in x264.</li>
<li>minor bugfix (deactivate DebugPrint possible)</li>
</ul>
<p>1.9.4.1 beta (12.06.2008 by Fizick, released 21.06.2008)</p>
<ul>
<li>Fixed bug for pel=4 with sharp=2 (thanks to Pustovetov for report and fix).</li>
<li>MVCompensate: added block size 16x2 (bug reported by AVIL).</li>
</ul>
<p>1.9.4 not public beta (08.06.2008 by Fizick)</p>
<ul>
<li>MVAnalyse and other: added block size 32x16 (requested by MAG79).</li>
</ul>
<p>1.9.3.1 (05.06.2008 by Fizick)</p>
<ul>
<li>MVIncrease: was broken (as noted by MAG79).</li>
</ul>
<p>1.9.3 (20.04.2008 by Fizick)</p>
<ul>
<li>MVAnalyse: fixed bug for pelclip (broken since v1.8.5).</li>
<li>MVDegrain: added thSADC as chroma threshold (request by Terranigma).</li>
</ul>
<p>1.9.2 (29.01.2008, all bugs were found by josey_wells)</p>
<ul>
<li>MVDegrain3: fixed bug in code for 16x8 block; fix typo (MVDegrain2 instead of MVDegrain3).</li>
<li>MVAnalyse: fixed old bug in NStepSearch.</li>
</ul>
<p>1.9.1 beta (15.12.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: Increased speed (by 20%) of global motion estimation (other algo).</li>
<li>MVAnalyse: Added assembler optimization for small blocksizes SAD (speed by 50%).</li>
<li>MVMask: Added kind=5 motion colormap as x,y components of motion vector shown in U, V color planes.</li>
</ul>
<p>1.9.0 (04.12.2007 by Fizick)</p>
<ul>
<li>Added MVDegrain3.</li>
</ul>
<p>1.8.6 (02.12.2007 by Fizick)</p>
<ul>
<li>Added components x,y motion vector mask kind=3,4 to MVMask (requested by Terka).</li>
</ul>
<p>1.8.5.1 (12.11.2007 by we:)</p>
<ul>
<li>Merge v1.8.4.3 and v1.8.5 changes, added MT example.</li>
</ul>
<p>1.8.4.3 (05.10.2007 by Tsp)</p>
<ul>
<li>Implemented internal cache buffer miss detection with buffer growing (as suggested by IanB).</li>
</ul>
<p>1.8.5 (05.11.2007 by Fizick)</p>
<ul>
<li>Added pelsearch parameter as search parameter (radius) at finest level (request by Terranigma).</li>
<li>Decreased internal buffer to decrease memory usage, with some changes in critical sections.</li>
<li>Added block size 16x2 (requested by ab_99).</li>
</ul>
<p>1.8.4.2 (25.10.2007 by Tsp)</p>
<ul>
<li>Added critical section in frame refining to fix rare bug in multi-threaded processing.</li>
</ul>
<p>1.8.4.1 (23.10.2007 by Tsp)</p>
<ul>
<li>Implemented thread-safe internal buffer access
for correct multithreaded processing with SetMTmode(2) in Avisynth MT version (for multi CPU).</li>
</ul>
<p>1.8.4 (22.08.2007 by Fizick)</p>
<ul>
<li>"divide" now works with "overlap".</li>
</ul>
<p>1.8.3 (17-20.08.2007 by Fizick)</p>
<ul>
<li>MVFlowFps: renamed "mode" parameter to "mask".</li>
<li>MVFlowFps2: added "mask" parameter.</li>
<li>MVFlowFPS, MVFlowFPS2: Restored default values num=25, den=1 (as was in version 1.7 and early)</li>
<li>MVDegrain1, MVGegrain2 - added "limit" parameter.</li>
</ul>
<p>1.8.2 beta (30.07.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: corrected (increased) search radius at finest level for pel>1.</li>
<li>Added pel=4 option for quarter pixel precision.</li>
<li>Renamed clip2x parameter to pelclip.</li>
</ul>
<p>1.8.1 beta (28.06.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: added postrocessing motion vectores by dividing blocks into subblocks to decrease zone of motion vectors interpolation.</li>
<li>MVFlowFps: added "mode" parameter to select processing method at occlusion areas (and speed).</li>
<li>Some internal changes (padding in MVAnalysisData, header to vector stream frames, etc).</li>
</ul>
<p>1.8.0 beta (22.06.2007 by Fizick)</p>
<ul>
<li>MVFlowInter, MVFlowFPS, MVFlowFPS2, MVMask: improved occlusion mask by extent</li>
<li>MVFlowInter, MVFlowFPS: decreased objects halo at occlusion areas by using motion vectors of adjacent frames</li>
<li>MVFlowInter, MVFlowFPS: disabled SAD mask and thSAD parameter</li>
<li>MVShow: fixed drawn positon of vectors</li>
<li>MVFlowFPS, MVFlowFPS2: Changed default output fps to double of input (default num, den = 0) </li>
<li>Added error messages on missed vector clips</li>
</ul>
<p>1.7.0 beta (05.06.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: added blksizeV and overlapV parameters for non-square blocks 8x4 and 16x8.</li>
</ul>
<p>1.6.4 (30.05.2007 by Fizick)</p>
<ul>
<li>MVAnalyse: modified vectors order for Enhausted search (expanding squares).</li>
<li>MVAnalyse: fixed bug with dct=3.</li>
<li>MVFlowFps, MVFlowFPS2, MVFlowInter: now blend frames with bad motion estimaton (at scenechanges, flashes).</li>
<li>MVFlowFps, MVFlowFPS2: fixed bug with thSAD parameter (and correspondent mask).</li>
</ul>
<p>1.6.3 (06.05.2007 by Fizick)</p>
<ul>
<li>MVDepan: more compatible with DepanEstimate (range parameter, etc).</li>
</ul>
<p>1.6.2 (11.11.2006 by Fizick)</p>
<ul>
<li>MVAnalyse: changed DCT=2 mode to global luma dependent.</li>
</ul>
<p>1.6.1 beta (25.10.2006 by Fizick)</p>
<ul>
<li>MVAnalyse: added experimental DCT mode to improve motion estimation at luma flicker and fades (fast for blksize=8 only).</li>
</ul>
<p>1.5.8 beta (14.10.2006 by Fizick)</p>
<ul>
<li>Many functions: added <var>clip2x</var> parameter to use 2X upsampled clip instead of internal subpixel interpolation for pel=2</li>
<li>MVFlowFps, MVFlowFps2: added <var>thSAD</var> parameter; use local blending of neighbour frames pixels
 in regions with bad motion vectors</li>
<li>MVFlowFps, MVFlowFps2: may use motion vectors for any frames <var>delta</var></li>
<li>MVFlowFps, MVFlowFps2: fixed a bug for video with big nominators and denominators (thanks to Trixter for report)</li>
<li>MVCompensate: added experimental <var>fields</var> parameter
 to compensate fields shift of fieldbased video for pel=2</li>
<li>MVAnalyse: changed pnew parameter to relative of SAD</li>
</ul>
<p>1.5.3 beta (01.10.2006 by Fizick)</p>
<ul>
<li>MVAnalyse: improved zero motion estimation for fieldbased video for pel=2</li>
<li>Merged v1.4.12-1.4.13 changes</li>
<li>Temporary restored MVIncrease, MVChangeCompensation, MVDenoise (with compensation stored in vector clip)</li>
</ul>
<p>1.5.1 beta (05.09.2006 by Fizick)</p>
<ul>
<li>Merged v1.4.11 changes</li>
</ul>
<p>1.5.0 beta (23.08.2006 by Fizick)</p>
<ul>
<li>Corrected vector predictors interpolation (from coarse to fine scale) for overlap>0.</li>
<li>MVFlowInter: added thSAD parameter.</li>
<li>MVFlowInter: local blending of neighbour frames pixels
 in regions with bad motion vectors.</li>
<li>Removed compensation storage in vector clip</li>
<li>Removed functions MVIncrease, MVChangeCompensation, MVDenoise
(it used compensation in vector clip, and did not support overlapping).</li>
<li>Removed  mode=2 loop option of MVCompensation, mode=0 is processed as mode=1 now.</li>
<li>Added thSAD parameter to MVCompensation for safe (dummy) compensation as requested by Didee</li>
</ul>
<p>1.4.13 (28.09.2006 by Fizick)</p>
<ul>
<li>Fixed bug with possible wrong frames pointers in core (MVClip.Update),
hided by caching (thanks to IanB for advice)</li>
</ul>
<p>1.4.12 (25.09.2006 by Fizick)</p>
<ul>
<li>Seems fixed bug with frames caching in MVDenoise (and possible in MVDegrain) (thanks to il9ad for report)</li>
</ul>
<p>1.4.11 (06.09.2006 by Fizick)</p>
<ul>
<li>Corrected vector predictors interpolation (from coarse to fine scale) for overlap>0.</li>
<li>Fixed bug with pitch for overlap=0, YV12 in MVDegrain1 (thanks to Boulder for report)</li>
</ul>
<p>1.4.10 (18.08.2006 by Fizick)</p>
<ul>
<li>Corrected right and bottom borders processing in MVCompensate for arbitrary frame sizes.</li>
<li>Changed defaults in MVAnalyse: pel=2, truemotion=true, sharp=2.</li>
</ul>
<p>1.4.9 (14.08.2006 by Fizick)</p>
<ul>
<li>Fixes a bug in MMX optimization of overlap mode in MVDeGrain, MVCompensate for YUY2 with blksize=8
 (thanks to TSchniede for report).</li>
</ul>
<p>1.4.8 (31.07.2006 by Fizick)</p>
<ul>
<li>Added some MMX optimization of overlap mode in MVDeGrain, MVCompensate.</li>
<li>Fixed a bug with last (not processed) rows in MVDeGrain.</li>
</ul>
<p>1.4.7 (25.07.2006 by Fizick)</p>
<ul>
<li>Decreased overlap gridness in MVDeGrain1, MVDeGrain2, MVCompensate.</li>
<li>Added example with MVDeGrain1 for interlaced.</li>
</ul>
<p>1.4.6 (24.07.2006 by Fizick)</p>
<ul>
<li>Decreased denoising in MVDeGrain1, MVDeGrain2.</li>
<li>Plane parameter in MVDeGrain1, MVDeGrain2 now works :)</li>
</ul>
<p>1.4.5 (22.07.2006 by Fizick)</p>
<ul>
<li>Added plane parameter to MVDeGrain1, MVDeGrain2.</li>
</ul>
<p>1.4.4 (19.07.2006 by Fizick)</p>
<ul>
<li>Corrected default thSAD=400 in MVDeGrain1, MVDeGrain2.</li>
<li>Fixed a bug with V color plane in MVChangeCompensate.</li>
</ul>
<p>1.4.3 (17.07.2006 by Fizick)</p>
<ul>
<li>Decrease overlap gridness in MVDeGrain1, MVDeGrain2.</li>
</ul>
<p>1.4.2 (16.07.2006 by Fizick)</p>
<ul>
<li>Fixed a memory access bug in MVDeGrain1, MVDeGrain2. Thanks to krieger2005 for report.</li>
</ul>
<p>1.4.1 (23.06.2006 by Fizick)</p>
<ul>
<li>Changed MVDeGrain1, MVDeGrain2 mode to SAD weigthing.</li>
<li>Chanded thSCD1 default from 300 to 400.</li>
</ul>
<p>1.4.0 (19.06.2006 by Fizick)</p>
<ul>
<li>Added MVDeGrain1, MVDeGrain2 limited averaging denoisers.</li>
<li>Corrected thSAD scale in MVDenoise.</li>
<li>Corrected documentation about SAD.</li>
</ul>
<p>1.3.1 (11.06.2006 by Fizick)</p>
<ul>
<li>Added bicubic subpixel interpolation method for pel=2 (with iSSE optinization for sharp=1,2).</li>
<li>Assembler iSSE speed optimization for overlapped block compensation.</li>
</ul>
<p>1.3.0 (05.06.2006 by Fizick)</p>
<ul>
<li>Implemented overlapped block motion compensation to MVCompensation(mode=1).</li>
<li>Changed default to mode=1 in MVCompensation as the most universal.</li>
<li>Added sharp subpixel interpolation method for pel=2.</li>
<li>Fixed bug for blksize=16 with YUY2.</li>
<li>(To-do list: assembler SSE speed optimization for new compensation and interpolation methods.)</li>
</ul>
<p>1.2.6 beta (21.05.2006 by Fizick)</p>
<ul>
<li>Added option to write motion vectors data to log file as requested by Endre.</li>
</ul>
<p>1.2.5 (08.05.2006 by Fizick)</p>
<ul>
<li>Decreased zero vector weight, iteration accuracy in MVDepan</li>
</ul>
<p>1.2.4 (07.04.2006 by Fizick)</p>
<ul>
<li>Fixed bug v.1.2.3 with info mode in MVDepan</li>
</ul>
<p>1.2.3 (31.03.2006 by Fizick)</p>
<ul>
<li>Implemented MVDepan for interlaced source separated by fields;</li>
<li>added optional MVDepan log file.</li>
</ul>
<p>1.2.2 beta (01.03.2006 by Fizick)</p>
<ul>
<li>Fixed frame shift bug of v1.2.1 with mmx YUY2 conversion (thanks to <b>WorBry</b> for bug report)</li>
</ul>
<p>1.2.1 beta (20.02.2006 by Fizick)</p>
<ul>
<li>Fixed bug of v1.2,</li>
<li>Speed restored,</li>
<li>mmx YUY2 conversion (from avisynth 2.6 function by sh0dan) </li>
<li>But it seems, overlap mode still does not work properly</li>
</ul>
<p>1.2 beta (17.02.2006 by Fizick)</p>
<ul>
<li>YUY2 format support (besides MVIncrease), no optimization</li>
</ul>
<p>1.1.1 (16.02.2006 by Fizick)</p>
<ul>
<li>Removed DeBlock and Corrector filters (will be separate plugins)</li>
<li>Documented old MVSCDetection function.</li>
<li>Cleaned project from unused source files.</li>
</ul>
<p>1.1 (non-public build 9.01.2006 by Fizick)</p>
<ul>
<li>Quite large revision (beta). New option for overlapped block motion estimation in MVAnalyse
for usage in MVFlow, MVFlowInter, MVFlowFps for improved motion compensation.</li>
<li>Lookup tables for motion interpolation.</li>
<li>Small correction of  displacement value in MVFlowFps2.</li>
</ul>
<p>1.0.3 (Released 30.12.2005 by Fizick)</p>
<ul>
<li>Fixed bug with displacement in MVFlowInter, MVFlowFps (introduced in v1.0.2).</li>
</ul>
<p>1.0.2 (Released 28.12.2005 by Fizick)</p>
<ul>
<li>Corrected value of displacement in MVFlow (a little).</li>
</ul>
<p>1.0.1 (Released 24.12.2005 by Fizick)</p>
<ul>
<li>Fixed memory leakage bug in MVAnalyse with global motion (thanks to <b>AI</b> for report).</li>
<li>Removed penalty for zero vector predictor in MVAnalyse (was introduced in v1.0).</li>
<li>Changed chroma=true as default in MVAnalyse.</li>
</ul>
<p>1.0 (Released 29.11.2005 by Fizick)</p>
<ul>
<li>I'm tired of long version numbers :). But the plugin is stil experimental :(.</li>
<li>Restored zero vector predictor in MVAnalyse.</li>
<li>Changed blur time scale in MVFlowBlur (100 is fully open shutter now) as <b>Mug Funky</b> requested.</li>
</ul>
<p>0.9.13.3 (Released 27.11.2005 by Fizick)</p>
<ul>
<li>Added global motion (simple method) vector predictor to MVAnalyse.</li>
<li>Vector search is skipped (for speed) if good predictor was found (with SAD &lt; pnew).</li>
<li>Parameter <var>scale</var> in MVShow works properly now.</li>
<li>Disabled some debug and profiling info output (for speed increasing).</li>
<li>Changed default <var>prec</var>=1 (was 2) in MVFlowBlur.</li>
</ul>
<p>0.9.13.2 (Released 22.11.2005 by Fizick)</p>
<ul>
<li>Fixed bug in MVFlowFps, MVFlowFps2 for non-integer fps.</li>
</ul>
<p>0.9.13.1 (Released 21.11.2005 by Fizick)</p>
<ul>
<li>Fixed bug in MVFlowFps, MVFlowFps2, MVFlowInter, MVFlowBlur (introduced in v0.9.13).</li>
<li>Removed <var>plen</var> parameter from MVAnalyse as not useful.</li>
</ul>
<p>0.9.13 (Released 20.11.2005 by Fizick)</p>
<ul>
<li>Added <var>truemotion</var> preset to MVAnalyse.</li>
<li>Added experimental MVFlowFps2.</li>
<li>Change interpolated vector rounding method in all MVFLow... functions.</li>
<li>Edited documentation a little.</li>
</ul>
<p>0.9.12.4 (Released 15.11.2005 by Fizick)</p>
<ul>
<li>Changed type of <var>ml</var> parameter in MVMask, MVFlowInter, MVFlowFps from int to float.</li>
<li>Added bound check of <var>ml, time, blur</var> parameters.</li>
<li>Small possible bug fixed (emms).</li>
<li>Partially updated documentation. But I am not sure that <b>sh0dan</b> requested <b>exactly such</b> updating :).
It is still not user guide but functions reference.</li>
</ul>
<p>0.9.12.3 (Released 14.11.2005 by Fizick)</p>
<ul>
<li>Fixed bug for chroma for width not divisible by 16 in MVMask (introduced in v0.9.11).</li>
<li>Some speed optimizing of MVFlowFps.</li>
<li>Reset size of internal frames buffer to original value 10. Try various versions.</li>
</ul>
<p>0.9.12.2 (Released 13.11.2005 by Fizick)</p>
<ul>
<li>Added experimental precise but slow MVFlowBlur function as <b>scharfis_brain</b> requested.</li>
<li>Temporary changed size of internal frames buffer to 5.</li>
</ul>
<p>0.9.12.1 (Released 12.11.2005 by Fizick)</p>
<ul>
<li>Added experimental MVFlowFps function.</li>
<li>Disabled MVInter function.</li>
<li>Temporary changed size of internal frames buffer from 10 to 3 for memory usage decreasing.
Speed must be tested for complex scripts.</li>
</ul>
<p>0.9.12 (Released 09.11.2005 by Fizick)</p>
<ul>
<li>Added MVFlowInter function. MVInter function will be removed in next release (it is worse).</li>
<li>Changed scale of <var>ml</var> parameter for kind=2 of MVMask to more optimal default.</li>
<li>Fixed small bug in Bilinear.asm (strange pixels near right border for pel=2).</li>
</ul>
<p>0.9.11.1 (Released 06.11.2005 by Fizick)</p>
<ul>
<li>Added half-pel support to MVFlow.</li>
<li>Increased max <var>quant</var> from 51 to 60 in DeBlock for very strong deblocking .</li>
<li>Corrected documentation.</li>
</ul>
<p>0.9.11 (Released 04.11.2005 by Fizick)</p>
<ul>
<li>Improved MVMask: Replaced boolean <var>showsad</var> parameter to integer <var>kind</var>,
added occlusion mask option. Changed bilinear resize code to more correct and fast SimpleResize.</li>
</ul>
<p>0.9.10.1 (Released 01.11.2005 by Fizick)</p>
<ul>
<li>Fixed bug with chroma and luma small changes in MVInter (rounding error).</li>
<li>Vector interpolation in MVFlow and mask in MVInter are correct now (due to fixing bug in SimpleResize).</li>
</ul>
<p>0.9.10 (Released 31.10.2005 by Fizick)</p>
<ul>
<li>Added some true motion (smoothed) estimation options to MVAnalyse</li>
<li>Added function MVFlow for per-pixel motion compensation</li>
<li>Added function MVInter for motion interpolation (very experimental)</li>
</ul>
<p>0.9.9.1 (Released 20.01.2005 by Manao)</p>
<ul>
<li>No need anymore of stlport_vcxxxx.dll</li>
</ul>
<p>0.9.9</p>
<ul>
<li>Filter added : Corrector</li>
<li>Filter added : MVIncrease</li>
<li>New available blocksize : 16</li>
<li>New parameter in MVAnalyse : <var>chroma</var></li>
<li>Changes in the core</li>
</ul>
<p>0.9.8.5</p>
<ul><li><code>MVCompensate</code> changed : a new parameter, idx, which works as idx in <code>MVAnalyse</code>,
and which allows speed up when compensating the same frames several times.</li>
</ul>
<p>0.9.8.4</p>
<ul><li>ME takes into account the chroma now, as requested by tsp.</li>
</ul>
<p>0.9.8.3</p>
<ul><li>Added <code>Corrector</code> function, as requested by scharfi.</li>
</ul>
<p>0.9.8.2</p>
<ul><li>New function <code>MVDepan</code> (added by Fizick) for Depan plugin.</li>
</ul>
<p>0.9.8.1</p>
<ul><li>Several bugfixes</li>
</ul>
<p>0.9.8</p>
<ul><li>Yet another little changes in the filters' syntax. The core changed a lot,
in order to gain speed were it was possible. However, by default, the speed gain won't be
visible, you'll need to configure correctly the analysis filter through its "idx"
parameter in order to gain speed ( in the mode "pel" = 2 ).</li>
<li>Bugfixes in MVDenoise, and chroma denoising in MVDenoise.</li>
<li>Now, the filters down the filter's chain tell to the analysis filter if they need
the compensation, so you don't have to worry about that at the analysis stage.</li>
</ul>
<p>0.9.7</p>
<ul><li>Yet again, a lot of rewriting. Interpolating filters are disabled ( for the moment ),
all the other filters work and should be considered as stable. Syntax has changed a lot,
and will change again before reaching 1.0 ( if it's reached one day ). Changes mainly affect
<code>MVAnalyse</code>. New filter :  <code>MVChangeCompensate</code>.
</li></ul>
<p>0.9.6.2</p>
<ul>
<li> Fixed bug in <code>MVMask</code> parameters.</li>
</ul>

<p>0.9.6.1</p>
<ul>
<li>Lot of bugfixes for the existing filters. MVMask, MVShow, MVCompensate, MVDenoise and MVSCDetection, and MVAnalyse should work .
Other may crash unexpectedly.</li>
<li>Now, for the three new filters. Two have nothing to do with motion compensation,
but I didn't want to put them in separate binaries, since they'll mainly be used with filters from this package.
The third one uses vectors, and integrates somehow the two others.</li>
<li>QDeQuant(clip c, int quant, int level) : takes a clip and quantizes it, using an approximation of the H264 DCT.
It filters the three planes ( 4x4 blocks for each of them, so the chroma isn't processed as in H264 ).
It's not exactly the H264 DCT because at q1, it's lossless, and a q51 it's not that bad, but you can raise quant over 51.
Level is the reference level of the picture.
By default it's zero, but it can be set, for example, to 128.
The picture is then treates as if pixels were ranging from -128 to 127, hence avoiding errors around 128.</li>
<li>Deblock(clip c, int quant, int aOffset, int bOffset ) : takes a clip, and deblock it using H264 deblocking,
as if the picture was made only of inter blocks. This time, quant ranges from 0 to 51 as in H264, and has the same impact.
aOffset and bOffset allow to raise / lower the quant when deciding for some internal thresholds.
They are set by default to 0. Be warned that the filter should do nothing at quant lesser 16, if aOffset and bOffset are both zero.
It's a wanted behavior ( thus it respect the partially the norm ).</li>
<li>EncDenoise(clip c, clip vectors, bool scbehavior, int quant, int aOffset, int bOffset, int thSCD1, int thSCD2) :
it merges Deblock, QDeQuant and MVCompensate, taking from them the name and behavior of their parameters.
It basically does a h264 encode as if all blocks were 8x8 inter blocks.
Reference frame is the previous frame output by the filter ( if it is the correct one, else it's the previous frame of the source ),
mvs are those given by mvanalyse on the source. The reference frame is compensated by the vectors,
then the residual difference is quantized / dequantized and added to the result of the motion compensation.
Finally, the frame is deblocked, and serves as reference for the next one.</li>
</ul>

<p>0.9.5.3</p>
<ul>
<li>Mainly a bugfixe ( several filters were affected by a silly bug , and MVCompensate now do padded motion compensation,
and compensate also the chroma ( though it rounds the vector to odd coordinates to do so )</li>
<li>A new feature, as asked by Fizick, for mvcompensate :
"scbehavior", a boolean set to true by default, will allow you to keep the previous frame over a scenechange if you set it to false.</li>
</ul>

<p>0.9.5.2</p>
<ul>
<li>MVMask has two new parameters : showsad (bool) which allows to build the mask of the SAD values instead of the mask of the vectors' length.
Ysc allows you to set the value taken by the mask on scene changes</li>
<li>MVCompensate : behavior modification on scene changes. Now, the current frame is left untouched if a scene change was detected.</li>
<li>New filter : MVSCDetection, with one parameter, Ysc, which works as previously.</li>
<li>MVInterpolate, MVConvertFPS and MVBlur are enabled, but may be buggy ( though I wasn't able to make MVConvertFPS crash )</li>
</ul>

<p>0.9.5
</p>
<ul>
  <li>Huge rewritting of the core engine. Vectors are now searched with a
   precision up to the pixel ( because no other filters can use yet more
   precise vectors, except MVShow ). The search engine is now fast ( which
   doesn't mean necessarily that the filters which use it are fast )</li>
   <li>A new parameter for MVAnalyse : lambda. See the documentation of the
   filter to see how it works</li>
   <li>MVDenoise works better.</li>
</ul>
<p>0.9.4
</p>
<ul>
  <li>Vectors can be saved to a file. In order to do so, add the parameter
filename="C:\foo.bar" to the filter MVAnalyse. If the file doesn't exist,
vectors will be saved into it. If it exists, vectors will be read from it. But,
be warned :
    <ul>
      <li>The file for a whole movie will be around 500 MB</li>
      <li>Saving / reading from a file need for the moment a linear access to
the frames, so it has to be used only when encoding the movie, not when doing
random access in it.</li>
      <li>The speed gain is not as great as one may hope, because SADs can't be
saved ( it would take too much space ) and so have to be recomputed.</li>
    </ul>
  </li>
  <li>The filter MVDenoise now works on 5 frames, and its parameters are now
"thT" and "sadT" ( have a look in the documentation to see how they work ). It
works nice ( very good for heavy denoising )</li>
  <li>The scene change detection thresholds have slightly changed. Now, a block
has changed if its SAD it over thSCD1. The default for thSCD1 is 300, and for
thSCD2 it is 130. It orks well ( better than the previous SCD engine ).<br>
  </li>
</ul>
<p>0.9.3</p>
<ul>
  <li>Last cleanings in the search of the motion vectors. It should be slightly
faster</li>
  <li>More search parameters can be set by the user, especially the search
algorithm. See the documentation</li>
  <li>Server / client implemented. You now first have to use MVAnalyse, and
then the filter you want. Look at the documentation and at the examples I'll
give alter.</li>
  <li>MVCompensate is separated from MVShow ( it's more logic that way ). For
the moment, it doesn't move the chroma ( same behavior as MVShow in the latest
releases )</li>
  <li>Some cleaning in MVBlur / MVInterpolate / MVConvertFPS, but still some
work to do. Now, MVBlur blurs around the frame, not between the frame and the
previous one.</li>
  <li>Half of the work is done for writing vectors to a file. But the resulting
file will be large ( around 500 MB - 1 GB I guess ).</li>
  <li>MVDenoise is slightly faster ( at least it should )</li>
  <li>Copies are optimized inside the filter, thanks to avisynth's copy
functions.</li>
  <li>MVShow can display the mean SAD of the compensation ( using showsad =
true )</li>
</ul>
<p>0.9.2.1</p>
<ul>
  <li>MVInterpolate makes its come back.</li>
  <li>MVConvertFPS should work on the last few frames of the clip</li>
</ul>
<p>0.9.2</p>
<ul>
  <li>MVInterpolate doesn't exist anymore.</li>
  <li>MVBlur and MVConvertFPS have been improved. They also have got new
parameters, have a look at the documentation.</li>
  <li>MVShow gets back its compensate mode ( MVShow(cm = true) )</li>
</ul>
<p>0.9.1 - 12.05.2004</p>
<ul>
  <li>First version renamed to MVTools. </li>
</ul>
<p>0.1-0.6 Released 24.01.2004 - 01.04.2004 by Manao</p>
<ul>
  <li>First public versions MotionVectors (Motion.dll). </li>
</ul>

<h2><a name="download"></a>VI) Download</h2>

<h3>Latest version by Fizick: <a href="http://avisynth.org.ru/mvtools/mvtools-v2.5.11.22.zip">Download MVTools v2.5.11.22</a></h3>
<p>Previous version: <a href="http://avisynth.org.ru/mvtools/mvtools-v2.5.11.20.zip">Download MVTools v2.5.11.20</a></p>
<p>Early version: <a href="http://avisynth.org.ru/mvtools/mvtools-v2.5.11.3.zip">Download MVTools v2.5.11.3</a></p>

<p>MVTools 2 mod16 dither version by Laurent de Soras 'Firesledge':  
<a href="http://ldesoras.free.fr/prod.html#src_avs">http://ldesoras.free.fr</a></p>
<p>You can found other 'unofficial' builds at forums, also 64 bit.</p>

<p>Older version 1.X documentation and download link are at
<a href="http://avisynth.org.ru/mvtools/mvtools.html">http://avisynth.org.ru/mvtools/mvtools.html</a></p>

<p>Older MVTools v.0.9.9.1 can be downloaded from <a href="http://manao4.free.fr/">Manao's site</a></p>
</body>
</html>
